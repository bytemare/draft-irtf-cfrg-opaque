{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-02-14T00:46:28.362528+00:00",
  "repo": "cfrg/draft-irtf-cfrg-opaque",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "next-version",
      "description": "Issue to fix in next version",
      "color": "86E6A4"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWU2MjAyNDU1MjQ=",
      "title": "Drop TLS integration details",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/2",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should reference and rely on [1] when it's updated.\r\n\r\n[1] https://tools.ietf.org/html/draft-sullivan-tls-opaque-00",
      "createdAt": "2020-05-18T14:15:17Z",
      "updatedAt": "2020-06-19T15:14:46Z",
      "closedAt": "2020-06-19T15:14:46Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU2MjAyNDg5NTU=",
      "title": "Move security property discussion to considerations section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/3",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This will shorten the introduction and help readers get straight to the protocol details. HPKE does a good job with this sort of structure, so we might look there as a guide.",
      "createdAt": "2020-05-18T14:19:28Z",
      "updatedAt": "2020-10-28T13:03:22Z",
      "closedAt": "2020-10-28T13:03:22Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This has since been done.",
          "createdAt": "2020-10-28T13:03:22Z",
          "updatedAt": "2020-10-28T13:03:22Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU2MjAyNDkzNDk=",
      "title": "Clarify server trust",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/4",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Should we clarify how much trust we place in the server? For example, since OPAQUE stores encrypted keys in the server, and that same server has the OPRF secret key, it could in theory do a dictionary attack and recover the private key for each user. This is pretty nonsensical, but I think it does highlight that OPAQUE assumes the server is honest-but-curious, rather than entirely malicious.\r\n\r\nThis is sort of fundamental, but some folks might miss it.",
      "createdAt": "2020-05-18T14:19:58Z",
      "updatedAt": "2020-12-21T16:45:52Z",
      "closedAt": "2020-12-21T16:45:51Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is already discussed in the \"Password salt and storage implications\" section. Closing.",
          "createdAt": "2020-12-21T16:45:51Z",
          "updatedAt": "2020-12-21T16:45:51Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU2MjAyNTQwMzM=",
      "title": "Reconsider \"cost\" details section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/5",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The \"cost\" details are written assuming a traditional DH-based KE protocol. Should we try to generalize this, e.g., to cover KEM-based protocols? Moreover, the cost details might not age well as TLS 1.3 develops and possibly moves away from signatures, via, e.g., semi-static DH. Or we might just remove this section entirely. ",
      "createdAt": "2020-05-18T14:25:57Z",
      "updatedAt": "2020-11-02T22:18:22Z",
      "closedAt": "2020-11-02T22:18:22Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU2MjAyNTQ0MDA=",
      "title": "Add wire format details for registration and login flow messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/6",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "TLS notation would be easiest, given its ubiquity. ",
      "createdAt": "2020-05-18T14:26:28Z",
      "updatedAt": "2020-06-04T23:18:09Z",
      "closedAt": "2020-06-04T23:18:09Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU2MjAyNTQ5NTM=",
      "title": "Highlight the importance of IdU and IdS in the envelope and post-OPRF AKE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/7",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Endpoints MUST agree on these identities (and use the right values!) for security. ",
      "createdAt": "2020-05-18T14:27:09Z",
      "updatedAt": "2020-12-17T01:58:59Z",
      "closedAt": "2020-12-17T01:58:59Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is pretty much covered now. Closing.",
          "createdAt": "2020-12-17T01:58:59Z",
          "updatedAt": "2020-12-17T01:58:59Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU2MjA1ODA5MTM=",
      "title": "Typo in 3DH key derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/8",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The key K3dh needs to computed by the server as\r\n K3dh = ePubU^ePrivS | ePubU^PrivS | PubU^ePrivS\r\nThe current draft inverts the order between the last two elements making it inconsistent with the way the client computes the key.\r\n(Reported by Kevin Lewi)",
      "createdAt": "2020-05-19T00:09:37Z",
      "updatedAt": "2020-05-19T22:17:38Z",
      "closedAt": "2020-05-19T16:43:28Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "As you see my github skills improved significantly, but the truth I did\nthese postings guided by someone else :-)\n\nCan I  address pull requests directly? DO you need to define me as\ncontributor? Or is it better that I let you push changes?\n\n\n-- Hugo\n\nHelp build a *worldwide repository* of COVID-19 data\n<https://iReport.algorand.org>, open to all, everywhere.\n\n\nOn Tue, May 19, 2020 at 12:43 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> Closed #8 <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/8> via\n> #10 <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/10>.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/8#event-3352769127>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXXKFQIYX44QTCJJHK3RSKZL7ANCNFSM4NEQVXEQ>\n> .\n>\n",
          "createdAt": "2020-05-19T19:50:30Z",
          "updatedAt": "2020-05-19T19:50:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I forgot to add you as a contributor! Oops. Let me do that now.",
          "createdAt": "2020-05-19T19:58:52Z",
          "updatedAt": "2020-05-19T19:58:52Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. Also, add yourself as an author.\n\n-- Hugo\n\nHelp build a *worldwide repository* of COVID-19 data\n<https://iReport.algorand.org>, open to all, everywhere.\n\n\nOn Tue, May 19, 2020 at 3:59 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> Ah, I forgot to add you as a contributor! Oops. Let me do that now.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/8#issuecomment-631049168>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXTP7PCTIP7DRVPILW3RSLQIVANCNFSM4NEQVXEQ>\n> .\n>\n",
          "createdAt": "2020-05-19T22:17:37Z",
          "updatedAt": "2020-05-19T22:17:37Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU2MjA1OTMzNjk=",
      "title": "typos/comments from Eric Crockett",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/9",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Page 4, second paragraph: \u201cOKI-free\u201d -> \u201cPKI-free\u201d\r\n\r\nIn that same paragraph \"it works for RSA\" should be replaced with a better explanation. The point is that  SRP requires a ring: it mixes additions and multiplications. It does not work over plain elliptic curves.\r\n\r\nPage 8, section 2.1. DH-OPEF -> DH-OPRF",
      "createdAt": "2020-05-19T00:47:29Z",
      "updatedAt": "2020-05-21T21:27:52Z",
      "closedAt": "2020-05-21T21:27:52Z",
      "comments": []
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU2MjI2ODU4NDg=",
      "title": "Add OPRF domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/15",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The DST might include the \"RFCXXXX\" identifier, similar to what we did for HPKE.",
      "createdAt": "2020-05-21T18:16:49Z",
      "updatedAt": "2020-12-21T20:55:28Z",
      "closedAt": "2020-12-21T20:55:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We now include \"OPAQUEXX\" in `Finalize`. Closing.",
          "createdAt": "2020-12-21T20:55:27Z",
          "updatedAt": "2020-12-21T20:55:27Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU2MjI4NDM5NjI=",
      "title": "Specify profiles or configurations for servers",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/16",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This might include, for example, what sort of OPRF ciphersuite(s) are used. Or we might just say that this is decided out of band.",
      "createdAt": "2020-05-21T23:10:15Z",
      "updatedAt": "2020-05-28T16:17:15Z",
      "closedAt": "2020-05-28T16:17:15Z",
      "comments": []
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU2MjQ1Njk4MjM=",
      "title": "HMQV key derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/18",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The following changes the HMQV key derivation to include the session identifier (essentially what the value info is) under the key calculation (the changes are in the last 4 lines below)\r\n\r\nValues IKM and info are defined for each protocol:\r\n\r\nFor HMQV:\r\n\r\n - info = \"HMQV keys\" \\| nonceU \\| nonceS \\| IdU \\| IdS\r\n\r\n - IKM = Khmqv\r\n\r\n   where Khmqv is computed:\r\n\r\n   - by the client:  Khmqv = (ePubS \\* PubS^s)^{ePrivU + u\\*PrivU}\r\n\r\n   - by the server:  Khmqv = (ePubU \\* PubU^u)^{ePrivS + s\\*PrivS}\r\n\r\n   and u = H(ePubU | \"user\" | info) and s = H(ePubS | \"srvr\" | info).\r\n\r\n<!--     (u and s are often denoted d and e, respectively, in HMQV)   -->\r\n\r\nAlso, in subsection \"Instantiation of OPAQUE with HMQV and 3DH\", before the KEY DERIVATION heading, add the following note:\r\n\r\n   [[TODO: Specify that in the login phase, ephemeral DH values need to be\r\n   verified to belong to the correct group (via membership tests or cofactor\r\n   exponentiation). Same for public keys during the registration phase.\r\n   Details of verification depend on the particular group/curve. (What's done in\r\n   TLS 1.3?)]]\r\n\r\n",
      "createdAt": "2020-05-26T03:02:31Z",
      "updatedAt": "2020-05-29T15:08:35Z",
      "closedAt": "2020-05-29T15:08:35Z",
      "comments": []
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU2MjY0NjQyNDM=",
      "title": "Add common configurations for OPAQUE ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/19",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This basically specifies different configurations, where each configuration identifies the OPRF, RKR-AEAD, and MHF algorithm. For example, one configuration might be DH-OPRF with OPRF-curve448-HKDF-SHA512-ELL2-RO, CTR+HMAC with AES-256 and HMAC-SHA256, and scrypt (with reasonable parameters).",
      "createdAt": "2020-05-28T12:19:47Z",
      "updatedAt": "2020-08-30T16:20:39Z",
      "closedAt": "2020-08-30T16:20:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "These configurations should also specify values for the nonce, authentication key, and exporter key lengths.",
          "createdAt": "2020-06-17T17:14:12Z",
          "updatedAt": "2020-06-17T17:14:12Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU2MjY0NjUxNzI=",
      "title": "Should all Credential fields be encrypted?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/20",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some fields, like the user public key, might only require authentication.",
      "createdAt": "2020-05-28T12:21:21Z",
      "updatedAt": "2020-06-18T23:36:20Z",
      "closedAt": "2020-06-18T23:36:20Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Authenticating-only the server's public key can be beneficial in a setting where the server uses the same public key with multiple clients. Encrypting the key means a larger envelope stored as *each*  user's record while authenticating-only makes both the envelope and per-user shorter shorter. There is some savings in not having to decrypt the server's public key but this seems negligible (especially if the authentication operation that cannot be avoided is more expensive than decryption).",
          "createdAt": "2020-06-02T16:31:07Z",
          "updatedAt": "2020-06-02T16:31:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was resolved in #36.",
          "createdAt": "2020-06-18T23:36:20Z",
          "updatedAt": "2020-06-18T23:36:20Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU2MjY0NjcwODU=",
      "title": "Move KdKey derivation to the Seal/Open calling code",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/21",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This key is used for applications that choose to process user information beyond the OPAQUE functionality (e.g., additional secrets or credentials).",
      "createdAt": "2020-05-28T12:24:30Z",
      "updatedAt": "2020-06-17T17:13:39Z",
      "closedAt": "2020-06-17T17:13:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is now done.",
          "createdAt": "2020-06-17T17:13:39Z",
          "updatedAt": "2020-06-17T17:13:39Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU2MjY0NzAwNjk=",
      "title": "Lift user enumeration text to the OPAQUE AKE stage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/22",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "We might consider standardizing the mechanism by which servers prevent user enumeration attacks. ",
      "createdAt": "2020-05-28T12:29:17Z",
      "updatedAt": "2021-02-06T00:00:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "I support standardizing a method to prevent user enumeration attacks as part of the OPAQUE specification.",
          "createdAt": "2021-01-11T22:53:21Z",
          "updatedAt": "2021-01-11T22:53:21Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU2MjY3MjY4Nzc=",
      "title": "Derive fresh nonces at envelope creation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/23",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The nonce used in envelope encryption should not be derived from RwdU but rather chosen freshly at random at the time of encryption (envelope creation) and be stored (and sent) as part of the envelope. This avoids reusing the same encryption stream for encrypting two different plaintexts.",
      "createdAt": "2020-05-28T18:38:50Z",
      "updatedAt": "2020-05-29T12:45:59Z",
      "closedAt": "2020-05-29T12:45:58Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #24.",
          "createdAt": "2020-05-29T12:45:58Z",
          "updatedAt": "2020-05-29T12:45:58Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU2MjY3Nzk1OTk=",
      "title": "Investigate OPRF generality",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/25",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We currently rely on a GenerateScalar function from the OPRF, which might not be a thing for OPRFs that are not based on Diffie-Hellman. We should consider how we might generalize this here, or perhaps in the OPRF document itself.",
      "createdAt": "2020-05-28T20:05:40Z",
      "updatedAt": "2020-09-19T12:04:44Z",
      "closedAt": "2020-09-19T12:04:44Z",
      "comments": []
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU2MjcyNDk1NDI=",
      "title": "Private key encodings",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/26",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We might use PKCS#8 as an encoding for credential private keys, or we might use language that suggests this is specific to each instantiation. ",
      "createdAt": "2020-05-29T12:56:46Z",
      "updatedAt": "2020-06-17T17:13:28Z",
      "closedAt": "2020-06-17T17:13:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as an application/instantiation-specific concern.",
          "createdAt": "2020-06-17T17:13:27Z",
          "updatedAt": "2020-06-17T17:13:27Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU2MjcyNTE5Mzk=",
      "title": "Validate ephemeral key shares",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/27",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Specify that in the login phase, ephemeral DH values need to be verified to belong to the correct group (via membership tests or cofactor exponentiation). Same holds for public keys during the registration phase. Details of verification depend on the particular group/curve.",
      "createdAt": "2020-05-29T13:00:47Z",
      "updatedAt": "2020-08-30T16:26:04Z",
      "closedAt": "2020-08-30T16:26:04Z",
      "comments": []
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU2MjkzNTcyMzI=",
      "title": "Using HKDF-Expand in deriving KEYS",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/29",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Instead of  KEYS = HKDF(salt=0, IKM=k, info=\"EnvU\", Length=L1+L2+L3) one could do \r\nKEYS = HKDF-Expand(key=k, info=\"EnvU\", Length=L1+L2+L3)\r\nwhich makes more sense since k is already a pseudo random key, we would only need to specify that k is the length of an HMAC key.",
      "createdAt": "2020-06-02T16:50:34Z",
      "updatedAt": "2020-06-18T23:36:09Z",
      "closedAt": "2020-06-18T23:36:09Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is done in #36.",
          "createdAt": "2020-06-17T17:13:07Z",
          "updatedAt": "2020-06-17T17:13:07Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU2MjkzNjM5MTU=",
      "title": "KdKey rationale ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/30",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need to add the rationale for KdKey somewhere. Can use the following as a basis:\r\n\r\nThe main use case I have in mind is retrieving a non-OPAQUE encrypted credential. Namely, expanding the use of OPAQUE with a credential-retrieval functionality. You could always put additional stuff in the envelope but I would prefer to restrict the envelope with its OPAQUE-specific functionality. In addition, having a separate encrypted credential can achieve several properties: allowing the server to send it only after the user authenticated; send it under the session key with forward secrecy; allowing the addition of a credential to the user's record after registration; allowing the use of non-RKR encryption for credential encryption; and just giving better extensibility, flexibility and separation from the core OPAQUE protocol.",
      "createdAt": "2020-06-02T17:01:06Z",
      "updatedAt": "2020-08-31T14:25:21Z",
      "closedAt": "2020-08-31T14:25:21Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is sort of like the TLS exporter secret. I'll see if I can write it as such!",
          "createdAt": "2020-06-04T20:58:08Z",
          "updatedAt": "2020-06-04T20:58:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw do you think the current rationale is sufficient? If not, would you mind proposing text to improve (expand) it?",
          "createdAt": "2020-07-21T16:44:26Z",
          "updatedAt": "2020-07-21T16:44:26Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I assume you mean the text under {export-usage}.\r\nI think it is ok.\r\nIt may be a good idea to add the following (which I have in my draft):\r\nThere is no restriction for the type of encryption scheme\r\n   used in this case.  However, ExportKey MUST NOT be used in any way\r\n   before the HMAC value in EnvU is validated. ",
          "createdAt": "2020-07-21T19:53:00Z",
          "updatedAt": "2020-07-21T19:53:00Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU2Mjk0MjQ1OTg=",
      "title": "On including pkU in the envelope",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/31",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add a note: pkU is often not needed by the client to run the key exchange stage in which case it can be omitted from the envelope and not sent from server to client in the online stage. In particular, this is the case for the three instantiations here: 3DH, HMQV and SIGMA.",
      "createdAt": "2020-06-02T18:34:04Z",
      "updatedAt": "2020-06-18T23:36:02Z",
      "closedAt": "2020-06-18T23:36:02Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed in #36.",
          "createdAt": "2020-06-18T23:36:02Z",
          "updatedAt": "2020-06-18T23:36:02Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU2NDA4Njc5NzA=",
      "title": "Clarify KDF(Expand) and MAC requirements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/37",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Future implementers may wish to replace HKDF-Expand and HMAC with their own (read:faster?) variants, so we should make clear the rationale for using these. Per the analysis, we require random-key robustness from HMAC, which is not something all MACs provide. (GMAC and poly1305 don't, for example.) HKDF-Expand could possibly be replaced by a different variable-length output PRF.",
      "createdAt": "2020-06-18T02:56:35Z",
      "updatedAt": "2020-08-30T16:20:23Z",
      "closedAt": "2020-08-30T16:20:23Z",
      "comments": []
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU2NjAyMjQyMjU=",
      "title": "Typo: nonce appears twice",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/42",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In line\r\nexport_key = HKDF-Expand(RwdU, concat(nonce, \"ExportKey\", nonce), Nk)\r\nnonce appears twice",
      "createdAt": "2020-07-18T15:53:08Z",
      "updatedAt": "2020-07-21T16:43:49Z",
      "closedAt": "2020-07-21T16:43:49Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice catch! I fixed this directly on master.",
          "createdAt": "2020-07-21T16:43:38Z",
          "updatedAt": "2020-07-21T16:43:38Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU2NjAyMzUxMTg=",
      "title": "lengths of elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/43",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Who, when and how determines  the length of elements to be generated or received. For example, how does the client know what the value of Nk should be. More significant how does the client know Nk or len(pt) when receiving the envelope?\r\n\r\nOn a related note, for a derivation like\r\nSK, Km2, Km3, Ke2, Ke3 = HKDF(salt=0, IKM, info, L)\r\nwe need to assume that the client knows how to parse the key stream correctly and uniquely hence it needs to know the lengths of each key.  This is also needed even if we compute a separate HKDF-Expand for each value (since Expand requires to define a length value). How does the client know these values, are these determined by the specific algorithms or ciphersuite ? Should this information be part of the information authenticated by the envelope or some other mechanism?\r\nHow does TLS 1.3 deals with this, namely, how it communicates and authenticates the ciphersuite/algorithms/version?",
      "createdAt": "2020-07-18T16:13:01Z",
      "updatedAt": "2020-08-30T16:22:47Z",
      "closedAt": "2020-08-30T16:22:47Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Who, when and how determines the length of elements to be generated or received. For example, how does the client know what the value of Nk should be. \r\n\r\nThis is part of the configuration. We should define this!\r\n\r\n> More significant how does the client know Nk or len(pt) when receiving the envelope?\r\n\r\nThe length of the envelope's ciphertext is equal to len(pt), so the client uses that to determine the length of the pad.\r\n\r\nOn the length of keys, they're all `Nk` bytes long, which is part of the configuration. I'll throw up a PR that defines this. Unlike TLS, I don't think we want to negotiate the ciphersuite in-band (in the core protocol spec -- we might do something differently for the instantiations).",
          "createdAt": "2020-07-21T16:48:55Z",
          "updatedAt": "2020-07-21T17:10:39Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The ciphersuite needs to be set and fixed at registration time and it needs to be learned by the client during login.  If this information is wired into the client implementation/configuration then no need to worry about it. But otherwise, we need care (e.g., if the client is a browser contacting a server for which the client does not have configuration information).\r\nThe OPRF needs to be known or guessed before getting the envelope (similar to key_share algorithms in TLS 1.3). Do we need to have a mechanism for the server to say, please use this other OPRF if the guess was incorrect? Should we worry about downgrade attacks?\r\nFor the envelope the client needs to know what hash to use (how does it learn that?). If the OPRF and hash used by the client are correct, then we can trust the MAC computed on the envelope to detect any manipulation of the envelope. \r\nAnd then there is the AKE ciphersuite that needs to include the AKE protocol type itself (SIGMA, 3DH, etc)  and the specific algorithms/curves used by the AKE implementation. But the latter can be encoded into the envelope itself and verified by the MAC.",
          "createdAt": "2020-07-21T21:20:10Z",
          "updatedAt": "2020-07-21T21:20:10Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "How does the client parse/differentiate ciphertext and auth_data? I assume this is defined by the Envelope struct, but I don't know how these things are implemented. DO they have special separators, length values, etc.? I am worried about possible attacks that play with the boundaries of these elements.",
          "createdAt": "2020-07-22T16:14:13Z",
          "updatedAt": "2020-07-22T16:14:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> How does the client parse/differentiate ciphertext and auth_data? I assume this is defined by the Envelope struct, but I don't know how these things are implemented. DO they have special separators, length values, etc.? I am worried about possible attacks that play with the boundaries of these elements.\r\n\r\nIndeed! Clients know to parse the ciphertext and auth_data in sequence (by the struct's definition), and know how to parse the type and length of each element in these lists. Everything should be unambiguous.",
          "createdAt": "2020-08-30T16:22:45Z",
          "updatedAt": "2020-08-30T16:22:45Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWU2OTA0ODk5NzQ=",
      "title": "parsing of envelope when ct/pt are variable length",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/51",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "At the end of the `#protocol-messages` section is a description of the envelope structure as seen here:\r\n\r\n```\r\nOPAQUE uses an `Envelope` structure to encapsulate an encrypted `Credentials` structure.\r\nIt is encoded as follows.\r\n\r\n~~~\r\nstruct {\r\n  opaque nonce[32];\r\n  opaque ct<1..2^16-1>;\r\n  opaque auth_data<0..2^16-1>;\r\n  opaque auth_tag<1..2^16-1>;\r\n} Envelope;\r\n~~~\r\n\r\nnonce\r\n: A unique 32-byte nonce used to protect this Envelope.\r\n\r\nct\r\n: Encoding of encrypted and authenticated credential extensions list.\r\n\r\nauth_data\r\n: Encoding of an authenticated credential extensions list.\r\n\r\nauth_tag\r\n: Authentication tag protecting the contents of the envelope.\r\n```\r\n\r\nas an implementer of opaque (see here https://github.com/stef/libsphinx/blob/master/src/opaque.c) i wonder how to parse this structure when both fields might be of variable length. In such a case it is useful to have the lengths included in the auth_data section at known offsets of the envelope. hence i propose to move the auth_data section infront of the ct section, either at the very beginning before the nonce, or between the nonce and the ct, in both cases an instantiation of the protocol can decide to include the lengths at known offsets and will be able to parse the envelope, even if this means that these lengths are used before they are authenticated.",
      "createdAt": "2020-09-01T22:25:34Z",
      "updatedAt": "2021-01-08T04:03:06Z",
      "closedAt": "2021-01-08T04:03:06Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "on another note the line `opaque auth_tag<1..2^16-1>; is confusing the rest of the document suggest that the `<>` enclosed parameter is length, however hmacs provide quite specific length tags.",
          "createdAt": "2020-09-02T00:21:05Z",
          "updatedAt": "2020-09-02T00:21:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> as an implementer of opaque (see here https://github.com/stef/libsphinx/blob/master/src/opaque.c) i wonder how to parse this structure when both fields might be of variable length. \r\n\r\nParsing these fields should be pretty straightforward. For example, consider `ct`, which is `opaque ct<1..2^16-1>`. To parse this, first parse a 2-byte length field, and then parse the remaining bytes (of that length) as the `ct` data. (This MUST be of length at least 1, which is what the `<1..2^16-1>` denotes.)\r\n\r\n> on another note the line opaque auth_tag<1..2^16-1>; is confusing the rest of the document suggest that the <>` enclosed parameter is length, however hmacs provide quite specific length tags.\r\n\r\nIt's true that the output of HMAC is fixed depending on the underlying hash function, but we chose to make this variable length in case clients wanted to truncate the tag to save space. (We can mark this as an open issue, because, as you hint, applications making such decisions isn't great.)",
          "createdAt": "2020-09-03T00:57:07Z",
          "updatedAt": "2020-09-03T00:57:07Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "> > as an implementer of opaque (see here https://github.com/stef/libsphinx/blob/master/src/opaque.c) i wonder how to parse this structure when both fields might be of variable length.\r\n> \r\n> Parsing these fields should be pretty straightforward. \r\n\r\nindeed it should ;)\r\n\r\n> For example, consider `ct`, which is `opaque ct<1..2^16-1>`. To parse this, first parse a 2-byte length field,\r\n\r\nmaybe i missed this, but where is this 2-byte length field defined for ct? if it is plaintext, shouldn't it be explicitly protected by they authentication of the envelope and thus belongs in the auth_data section? does that imply there are more cleartext parts in the envelope besides the explicitly listed auth_data section? is there also a length field somewhere defined for the auth_data section?\r\n\r\n> and then parse the remaining bytes (of that length) as the `ct` data. (This MUST be of length at least 1, which is what the `<1..2^16-1>` denotes.)\r\n> \r\n> > on another note the line opaque auth_tag<1..2^16-1>; is confusing the rest of the document suggest that the <>` enclosed parameter is length, however hmacs provide quite specific length tags.\r\n> \r\n> It's true that the output of HMAC is fixed depending on the underlying hash function, but we chose to make this variable length in case clients wanted to truncate the tag to save space. (We can mark this as an open issue, because, as you hint, applications making such decisions isn't great.)\r\n\r\ni think it makes sense to just write `<Nh>` and refer to #cryptographic-protocol-and-algorithm-dependencies",
          "createdAt": "2020-09-03T18:15:26Z",
          "updatedAt": "2020-09-03T18:15:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> maybe i missed this, but where is this 2-byte length field defined for ct? if it is plaintext, shouldn't it be explicitly protected by they authentication of the envelope and thus belongs in the auth_data section? does that imply there are more cleartext parts in the envelope besides the explicitly listed auth_data section? is there also a length field somewhere defined for the auth_data section?\r\n\r\nI think perhaps you're confused by the terminology. These variable-length fields are using standard TLS notation (https://tools.ietf.org/html/rfc8446#section-3.4). Quoting that document:\r\n\r\n> Variable-length vectors are defined by specifying a subrange of legal\r\n> lengths, inclusively, using the notation <floor..ceiling>.  When\r\n> these are encoded, the actual length precedes the vector's contents\r\n> in the byte stream.",
          "createdAt": "2020-09-03T20:01:29Z",
          "updatedAt": "2020-09-03T20:01:29Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "oh. maybe it makes sense to state this explicitly, it helps understanding this much easier for people that do not speak tls natively.",
          "createdAt": "2020-09-03T20:08:54Z",
          "updatedAt": "2020-09-03T20:08:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's stated here:\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#protocol-messages-protocol-messages\r\n\r\nWould an example section be more helpful? (I agree it's not obvious without that prior context!)",
          "createdAt": "2020-09-03T20:32:58Z",
          "updatedAt": "2020-09-03T20:32:58Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "yeah i noticed that, but i have not anticipated the implicit consequences of that. the notation that is below as examples looks kinda self-explaining - except for the parts that are not explicitly spelled out...\r\nmaybe  an example section would be more helpful, or alternatively an explicit spelled out part that explains what is not obvious from the defintions below.",
          "createdAt": "2020-09-03T20:35:40Z",
          "updatedAt": "2020-09-03T20:35:40Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "sorry , clicked on the wrong button.",
          "createdAt": "2020-09-03T20:35:55Z",
          "updatedAt": "2020-09-03T20:35:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "To help craft that section, could you please list the notation that you do find confusing? I can then try to clarify. ",
          "createdAt": "2020-09-03T20:37:34Z",
          "updatedAt": "2020-09-03T20:37:34Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "after reading section 3 of RFC8446, i'd say the length of the field being implicit in that notation should be definitely \r\nnoted, and what i also learned, that in the struct `opaque` is the \"type\" of the value and in no way related to the protocol being specified, that is also kinda confusing in retrospect. otherwise i think enums and structs do not have hidden semantics, and as far as i see variants are not used. so i guess that's then these two things lengths of arrays and the type `opaque` as a special mention that this is a type and a name collision only.",
          "createdAt": "2020-09-03T21:51:38Z",
          "updatedAt": "2020-09-03T21:51:38Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "uh, i see that variants are used in the ProtocolMessage struct.",
          "createdAt": "2020-09-04T13:11:31Z",
          "updatedAt": "2020-09-04T13:11:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> after reading section 3 of RFC8446, i'd say the length of the field being implicit in that notation should be definitely\r\nnoted, and what i also learned, that in the struct opaque is the \"type\" of the value and in no way related to the protocol being specified, that is also kinda confusing in retrospect. otherwise i think enums and structs do not have hidden semantics, and as far as i see variants are not used. so i guess that's then these two things lengths of arrays and the type opaque as a special mention that this is a type and a name collision only.\r\n\r\nOkay, thanks! I'll try to clarify these things.\r\n\r\n> uh, i see that variants are used in the ProtocolMessage struct.\r\n\r\nIs there a question hidden in here?\r\n",
          "createdAt": "2020-09-04T18:22:51Z",
          "updatedAt": "2020-09-04T18:22:51Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "> > uh, i see that variants are used in the ProtocolMessage struct.\r\n> \r\n> Is there a question hidden in here?\r\n\r\nwell yes, i first thought that variants are not used in the OPAQUE draft, only later i saw it, so the semantics of variants are quite understandable, but might also deserve mention in the clarifying section.\r\n",
          "createdAt": "2020-09-04T20:02:15Z",
          "updatedAt": "2020-09-04T20:02:15Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe we can close this out now, given the recent changes to the envelope structure which ensure that there is only one variable-length field:\r\n\r\n```\r\nstruct {\r\n  InnerEnvelopeMode mode;\r\n  opaque nonce[32];\r\n  opaque encrypted_creds<1..2^16-1>;\r\n} InnerEnvelope;\r\n\r\nstruct {\r\n  InnerEnvelope contents;\r\n  opaque auth_tag[Nh];\r\n} Envelope;\r\n```",
          "createdAt": "2021-01-08T04:02:56Z",
          "updatedAt": "2021-01-08T04:02:56Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU2OTMxMzg0NDk=",
      "title": "rename Evaluate() to Contribute()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/53",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "since github does not support reviewing markdown documents i'm submitting this as an issue:\r\n\r\nThe OPRF primitive defines a \r\n```\r\nEvaluate(k, M): Evaluate input M using private key k.\r\n```\r\nfunction, semantically i think it makes more sense to call this function Contribute as this conveys better what is happening, Evaluate() is less specific to the purpose of what is happening here.",
      "createdAt": "2020-09-04T12:54:48Z",
      "updatedAt": "2020-09-19T12:03:52Z",
      "closedAt": "2020-09-19T12:03:51Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you elaborate on why `Contribute` is more clear? As written, I don't agree.",
          "createdAt": "2020-09-06T13:52:52Z",
          "updatedAt": "2020-09-06T13:52:52Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "because in an OPRF two parties collaborate to calculate a value `c^s`. The client (c) blinds his value `c` using the blinding factor `r`, then sends over this blinded value to the server, who contributes his value `s` to the computation and returns it to the client. the client then unblinds the value from the server getting as a result `c^s`. ",
          "createdAt": "2020-09-06T14:07:00Z",
          "updatedAt": "2020-09-06T14:07:00Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "on another note i would also rephrase \"using private key k\" to \"using secret key k\" as the usage of \"private\" suggest that there is also a public key associated with this, while there isn't. and as far as i can judge for this kind of usage it is more common to refer as secret and not private keys.",
          "createdAt": "2020-09-06T15:02:06Z",
          "updatedAt": "2020-09-06T15:02:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Use of \u201cprivate key\u201d matches terminology in the OPRF dependent document. Use of Evaluate is also a result of that document. I suggest filing an issue against that repository to consider Contribute.",
          "createdAt": "2020-09-06T20:20:10Z",
          "updatedAt": "2020-09-06T20:20:10Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "thanks will. do.",
          "createdAt": "2020-09-06T20:38:18Z",
          "updatedAt": "2020-09-06T20:38:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing based on the outcome of https://github.com/cfrg/draft-irtf-cfrg-voprf/issues/140.",
          "createdAt": "2020-09-19T12:03:51Z",
          "updatedAt": "2020-09-19T12:03:51Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWU2OTMxNDA0MjU=",
      "title": "What is an OPRF keypair?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/54",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in the Cryptographic primitives section there is this sentence:\r\n```\r\nWe also assume the existence of a function KeyGen, which generates an OPRF private and public key.\r\n```\r\ni'm sorry, but what does that mean? The notion of a keypair in the OPRF context makes no sense to me.",
      "createdAt": "2020-09-04T12:56:53Z",
      "updatedAt": "2020-09-16T13:34:41Z",
      "closedAt": "2020-09-16T13:34:41Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "i just realized this might be a typo and should say OPAQUE instead of OPRF?",
          "createdAt": "2020-09-04T13:06:00Z",
          "updatedAt": "2020-09-04T13:06:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not a typo. The OPRF dependency in this document has a private and public key component to it. (Is your point that it should only be a secret key?) ",
          "createdAt": "2020-09-06T13:54:17Z",
          "updatedAt": "2020-09-06T13:54:17Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "OPRF as such does not use any public/private keypair. An OPRF blinds the value of the initiator, the responder contributes its own value, and the initiator then unblinds the responders value. there is no use for a (sk=x, pk=g^x) keypair in this computation.",
          "createdAt": "2020-09-06T14:10:42Z",
          "updatedAt": "2020-09-06T14:10:42Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "however OPAQUE itself makes use of public private keypairs (and thus of keygen) for the values pkU, skU, pkS, skS, and their ephemeral counterparts. thus my assumption this being a typo.",
          "createdAt": "2020-09-06T14:12:30Z",
          "updatedAt": "2020-09-06T14:12:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Please review the dependent OPRF document. This OPRF has a public and private key pair. The public key is only used for verification, which is why OPAQUE discards it. ",
          "createdAt": "2020-09-06T20:18:17Z",
          "updatedAt": "2020-09-06T20:18:17Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "sorry, i only read the paper by Jarecki et al., i wasn't aware that there is also an IETF (V)OPRF rfc draft. looking at that it makes kind of sense to call this keygen(), as for nist curves it must be guaranteed that the scalar is member of the field. and for voprfs actually to verify it. thanks for pointing that out, maybe this could be explained where the keygen() is mentioned in the opaque draft",
          "createdAt": "2020-09-06T20:37:20Z",
          "updatedAt": "2020-09-06T20:48:12Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "i just reread the paper, and i apologize for the noise. ",
          "createdAt": "2020-09-16T13:34:41Z",
          "updatedAt": "2020-09-16T13:34:41Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWU2OTQzODU1MDg=",
      "title": "uint24 in ProtocolMessage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/55",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "`ProtocolMessage` defines the `length` field to be of type `uint24`, i understand this is to handle messages that are composed of a few max 2^16 long parts, and possibly to conserve bandwidth? is it possible to make this 32bit which is a native and widely used size instead of 24bits.",
      "createdAt": "2020-09-06T13:40:50Z",
      "updatedAt": "2020-09-06T14:15:08Z",
      "closedAt": "2020-09-06T14:15:08Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The full ProtocolMessage struct is as follows:\r\n\r\n~~~\r\nstruct {\r\n    ProtocolMessageType msg_type;    /* protocol message type */\r\n    uint24 length;                   /* remaining bytes in message */\r\n    select (ProtocolMessage.msg_type) {\r\n        case registration_request: RegistrationRequest;\r\n        case registration_response: RegistrationResponse;\r\n        case registration_upload: RegistrationUpload;\r\n        case credential_request: CredentialRequest;\r\n        case credential_response: CredentialResponse;\r\n    };\r\n} ProtocolMessage;\r\n~~~\r\n\r\nNote that `msg_type` is one byte, so one can skip over the type/length by 4 bytes if desired. `uint32` is fairly large for one of these messages, and `uint16` may be too small, so we went with `uint24` for alignment purposes.",
          "createdAt": "2020-09-06T13:52:17Z",
          "updatedAt": "2020-09-06T13:52:17Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "uint16 is definitely too small (since some parts of these messages can be more than 2*2^16-2 in size). using msg_type and length in one 32bit word makes sense though.",
          "createdAt": "2020-09-06T14:14:32Z",
          "updatedAt": "2020-09-06T14:14:32Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWU3MDQ4NzA5ODM=",
      "title": "Should the nonce length be a parameter?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/58",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's currently set 32 bytes, which may be too much (?) in some circumstances. However, adding yet another parameter that applications must choose is not great. ",
      "createdAt": "2020-09-19T12:10:05Z",
      "updatedAt": "2020-10-28T13:05:35Z",
      "closedAt": "2020-10-28T13:05:34Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it should be fine to keep this as 32 bytes, erroring on the side of safety without too much of a drawback.",
          "createdAt": "2020-10-21T22:42:38Z",
          "updatedAt": "2020-10-21T22:42:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I applied this directly on main. Closing.",
          "createdAt": "2020-10-28T13:05:34Z",
          "updatedAt": "2020-10-28T13:05:34Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWU3MDkyMTA3OTE=",
      "title": "SHA-256 for Curve25519-based OPRF ciphersuites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/59",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, SHA-512 is used for all OPRF suites, which is quite excessive. (This is more an issue against the OPRF draft, I'm but filing it here to track the change in our doc.)",
      "createdAt": "2020-09-25T18:56:57Z",
      "updatedAt": "2020-11-02T23:54:06Z",
      "closedAt": "2020-11-02T23:54:06Z",
      "comments": []
    },
    {
      "number": 60,
      "id": "MDU6SXNzdWU3MDkyMTEyOTc=",
      "title": "Consider adding a registry",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/60",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The configurations are rather loosely defined. A registry that allows one to encode an entire configuration (AKE, OPRF, MHF, etc) could be useful. ",
      "createdAt": "2020-09-25T18:57:48Z",
      "updatedAt": "2020-10-28T13:05:48Z",
      "closedAt": "2020-10-28T13:05:48Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Nevermind! Closing.",
          "createdAt": "2020-10-28T13:05:48Z",
          "updatedAt": "2020-10-28T13:05:48Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWU3MTQ0MTcyNjc=",
      "title": "Envelope format in registration versus login",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/62",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Should this line (https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L583) be similar to this line (https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L787)?\r\n\r\nEither both should read `Envelope envelope;`, or both should read `opaque envelope<1..2^16-1>`, right?",
      "createdAt": "2020-10-04T22:37:27Z",
      "updatedAt": "2020-10-20T00:47:44Z",
      "closedAt": "2020-10-20T00:47:44Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Doh, yes, that's an error. Let's make them both the former (`Envelope envelope`). Can you please submit a PR to correct this?",
          "createdAt": "2020-10-19T18:32:21Z",
          "updatedAt": "2020-10-19T18:32:21Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWU3MTQ0NTQ0NjY=",
      "title": "Extraneous parameter pkS in CredentialResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/63",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Why is it necessary to [put pkS in the CredentialResponse struct](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L788)?\r\n\r\nAccording to [this](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L460-L464), pkS must be included within the envelope already. So, when the client parses the CredentialResponse struct, shouldn't it be able to obtain pkS from the envelope already?",
      "createdAt": "2020-10-05T01:47:20Z",
      "updatedAt": "2020-12-30T04:20:11Z",
      "closedAt": "2020-10-26T21:45:05Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good question! I *think* it can probably be removed, but let's see what @hugokraw thinks?",
          "createdAt": "2020-10-19T18:31:10Z",
          "updatedAt": "2020-10-19T18:31:10Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I did not notice pkS is sent outside the envelope. Not only it would be redundant but pkS is the most important element to be authenticated as part of the envelope. Sending it outside may lead people to accept it without authentication.",
          "createdAt": "2020-10-19T22:23:30Z",
          "updatedAt": "2020-10-19T22:23:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's drop it. @kevinlewi, can you please prep a PR to do this?",
          "createdAt": "2020-10-21T22:35:57Z",
          "updatedAt": "2020-10-21T22:35:57Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "In light of the changes made in #102, this will need to be re-introduced again.",
          "createdAt": "2020-12-30T04:20:11Z",
          "updatedAt": "2020-12-30T04:20:11Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU3MjQ0MDY5ODk=",
      "title": "Omitting idU parameter in RegistrationRequest and CredentialRequest messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/65",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The idU parameter is not used by the server when receiving the `RegistrationRequest` and `CredentialRequest` messages from the client. Can this parameter be omitted from the specification of these messages?\r\n\r\nIn theory, the server does need some \"username\" equivalent in order to look up the client's record, so this information does need to be sent, but I don't think it should be included in the OPAQUE messages, since it has no function within OPAQUE other than to set/retrieve the appropriate password file.\r\n\r\nPresumably, any wrapper protocol which uses OPAQUE will not want to look into the bytes of the OPAQUE messages in order to figure out what the username is.",
      "createdAt": "2020-10-19T08:43:53Z",
      "updatedAt": "2020-10-28T18:59:13Z",
      "closedAt": "2020-10-28T18:59:13Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, it needs to be included in the transcript for the AKEs, I think, so that's why it's part of the `CredentialRequest` message. ",
          "createdAt": "2020-10-19T18:30:37Z",
          "updatedAt": "2020-10-19T18:30:37Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The presence of idU is dependent on the AKE protocol used, and so even though it may get sent over as the first message of the AKE, shouldn't this be controlled by the specification of the AKE, and not the OPRF component?\r\n\r\nAlso, this is only for `CredentialRequest`, since `RegistrationRequest` does not use idU. I would be happy with delegating the specifying of idU to the AKE component.",
          "createdAt": "2020-10-19T23:35:56Z",
          "updatedAt": "2020-10-19T23:35:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The presence of idU is dependent on the AKE protocol used, and so even though it may get sent over as the first message of the AKE, shouldn't this be controlled by the specification of the AKE, and not the OPRF component?\r\n\r\nThat's true. One thing I have in my implementation notes is whether we ought to include *both* `idU` and `pwdU` in the OPRF input, rather than just `pwdU`. Given that `kU` is unique per `idU`, this probably doesn't make a meaningful change in security, though I wonder if it's just cleaner aesthetically?\r\n\r\nI could go either way, I guess. I'm curious to hear what @hugokraw thinks.",
          "createdAt": "2020-10-20T00:04:25Z",
          "updatedAt": "2020-10-20T00:04:25Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  One thing I have in my implementation notes is whether we ought to include both idU and pwdU in the OPRF input, rather than just pwdU.\r\n\r\nThat is certainly a valid consideration, but regardless of whether or not this is changed, I believe we can still omit idU from the `RegistrationRequest` and `CredentialRequest` messages, since the server doesn't use them (except for in the AKE component potentially).",
          "createdAt": "2020-10-20T00:09:22Z",
          "updatedAt": "2020-10-20T00:09:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "True, though I wonder if that just complicates things. (I don't disagree with the proposal. I just need to think about it more.)",
          "createdAt": "2020-10-20T00:14:18Z",
          "updatedAt": "2020-10-20T00:14:18Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Kevin, as you say correctly some form of user identity needs to be sent to the server for fetching the user's record. I would actually think that this transmission of identity is very much a role of the password authentication protocol, namely, OPAQUE. I can also see that this information may be transmitted in some other way (e.g., a wrapper) but I would not want to rely 100% on that possibility. Can we make the idU in the CredentialRequest message optional? Would that address your concern? \r\nThe setting in which the RegistrationRequest message acts is more complex as there are many issues involved in this case, particularly ways for the server to validate it is talking to the claimed user. In that case there may be a more complex wrapper. But even then, it feels that a support for a minimal implementation that  communicated idU from client to server could be supported. But in issues of implementation and deployment I  let you guys have the last word.\r\n\r\nAs for including idU under the OPRF input, I am ok with it. I am in favor of analyzing minimalistic protocols to understand what's the minimum elements the protocol's security requires. But I am happy to add elements that add robustness to the protocol (against misuse, etc.). I had examples in the past that I thought adding idU would be useful but I do not remember. It seems that if servers choose per-user kU (which they should) then adding idU does not add much value. Otoh, it makes idU more static as you cannot decide to change idU after registration (some websites would let you change userid)",
          "createdAt": "2020-10-20T06:29:51Z",
          "updatedAt": "2020-10-20T06:29:51Z"
        },
        {
          "author": "huitseeker",
          "authorAssociation": "NONE",
          "body": "> some form of user identity needs to be sent to the server for fetching the user's record.\r\n\r\nI think this hinges on whether the protocol is described as a component of a session (L5+). It seems to me that this is one natural way of interpreting (or implementing) the Registration flow, on the one hand, and the Credential flow, on the other hand. During each of those, the idU parameter remains a constant.\r\n\r\nOnce the session parameters are determined \u2014 including of course the user's claim to identity (idU) \u2014 there is no need for the application to receive them again in further messages. The repetition would in fact no only consume bandwidth, but complicate implementation, by requiring a check that the idU value has indeed been kept constant on every message of a session, and demanding that the server emits a new error case if that session invariant is broken.\r\n\r\nHowever, such a re-transmission may be useful for auxiliary stateless tooling that does not have an understanding of a session, such as firewalls implementing packet filtering based on the idU field.\r\n\r\nWe've worked on implementation with a L7 in mind, but it's perfectly understandable that you could think of OPAQUE + KE as a lower-level initial session establishment protocol, in which case the stateless interpretation would make sense. \r\n\r\nAre there two recommendations to make to implementers here, depending on their use case?  \r\n\r\n",
          "createdAt": "2020-10-20T18:23:51Z",
          "updatedAt": "2020-10-20T18:24:26Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to be extra clear -- the inefficiency I am highlighting is the fact that the idU parameter included by RegistrationRequest is never used by the OPAQUE server implementation. Leaving it out would have no impact on anything within OPAQUE. One could argue the use for it by a wrapper protocol, but then the wrapper protocol would need to inspect the bytes of the OPAQUE protocol in order to extract idU, which could change depending on the OPAQUE version, and in general does not seem like a good abstraction.\r\n\r\nFor CredentialRequest, the same is true, except that the AKE component may use idU. However, I believe we should include the idU in the \"first message of the key exchange\" if the specification for that key exchange so requires, rather than placing it next to the OPRF component where it may or may not be consumed by the AKE.\r\n\r\nBTW @hugokraw, I believe the idU parameter is already optional (since it can be specified as 0 bytes as per \"`opaque id<0..2^16-1>;`\"). The question I am asking is if we should remove the already-optional parameter from the message being sent from client to server.",
          "createdAt": "2020-10-20T18:49:55Z",
          "updatedAt": "2020-10-20T18:49:55Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not completely sure I understand the issue here. I can see that there are cases where sending IdU inside OPAQUE can be redundant or even complicate things. But I think that giving the option to send it as part of the OPAQUE messages is necessary for ensuring one standard way for signaling the userid information to the server when the wrapper/application around it is not doing so. If you take the ability to send userid completely out of OPAQUE, what would be the answer to people's question \"how is the client supposed to communicate the identity of the user to the server\"?. Would the answer be:  \"it is not OPAQUE's responsibility but rather the application/wrapper around it\"? \r\n\r\nA related issue is privacy of the user id/account information. If you send it as part of OPAQUE and you run OPAQUE inside a confidential channel, such as server-authenticated TLS, then you get that protection. If you send it by other means, you need to trust that this other means take care of privacy. \r\n\r\nOnce thing that is **for sure** is that the AKE needs to have a notion of identities agreed by both parties (agreement needs to be at the level of bit representation as these are input into the KDF) as verifying such agreement is a fundamental part of the AKE functionality. Since these identities will be known in most cases to the parties before the AKE starts (the server needs it to fetch the user's record and the user will typically have an identity of the server in order to contacting it), sending it in the AKE may be redundant in some/many cases. But I am ok with any decision here as long as we make sure this agreement on identities is established before running the authentication steps in the AKE.",
          "createdAt": "2020-10-21T15:41:26Z",
          "updatedAt": "2020-10-21T15:41:26Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I am not completely sure I understand the issue here. I can see that there are cases where sending IdU inside OPAQUE can be redundant or even complicate things. But I think that giving the option to send it as part of the OPAQUE messages is necessary for ensuring one standard way for signaling the userid information to the server when the wrapper/application around it is not doing so. If you take the ability to send userid completely out of OPAQUE, what would be the answer to people's question \"how is the client supposed to communicate the identity of the user to the server\"?. Would the answer be: \"it is not OPAQUE's responsibility but rather the application/wrapper around it\"?\r\n\r\nThat's correct, I am of the opinion that \"it is not OPAQUE's responsibility but rather the application/wrapper around it\"\r\n\r\n> A related issue is privacy of the user id/account information. If you send it as part of OPAQUE and you run OPAQUE inside a confidential channel, such as server-authenticated TLS, then you get that protection. If you send it by other means, you need to trust that this other means take care of privacy.\r\n> \r\n> Once thing that is **for sure** is that the AKE needs to have a notion of identities agreed by both parties (agreement needs to be at the level of bit representation as these are input into the KDF) as verifying such agreement is a fundamental part of the AKE functionality. Since these identities will be known in most cases to the parties before the AKE starts (the server needs it to fetch the user's record and the user will typically have an identity of the server in order to contacting it), sending it in the AKE may be redundant in some/many cases. But I am ok with any decision here as long as we make sure this agreement on identities is established before running the authentication steps in the AKE.\r\n\r\nAgreed on the AKE point. I am also ok with leaving it as an optional parameter in RegistrationRequest and CredentialRequest, but I do want to point out that this idU parameter is the only remaining parameter in the OPAQUE protocol which is sent over the wire, but the receiving party does not do anything with it (within the specification).\r\n\r\nTo me, the rule I'd like to follow is: the only code which should be interpreting / deserializing any bytes sent as part of the OPAQUE protocol is the OPAQUE code itself -- having a wrapper protocol attempt to do the deserialization may end up causing versioning / upgrading nightmares for these wrapper implementations. As such, I'd like to avoid the possibility of a wrapper call understanding the organization of bytes in the OPAQUE messages, and hence would lean towards completely omitting this idU in OPAQUE's RegistrationRequest and the core part (not the AKE part) of CredentialRequest.",
          "createdAt": "2020-10-21T21:50:16Z",
          "updatedAt": "2020-10-21T21:50:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi can you please prep a PR with this suggested change?",
          "createdAt": "2020-10-21T22:35:24Z",
          "updatedAt": "2020-10-21T22:35:24Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I said in a previous post in this thread:\r\n> I had examples in the past that I thought adding idU [in the OPRF input, in addition to the password] would be useful but I do not remember\r\n\r\nSo now I remembered: It helps against an online attack where the attacker poses as the server with its own chosen value k*. If only pwd is included then, the attacker can build a universal dictionary of values H(pwd)^k* for all pwd in a dictionary and use it against any user to check the client response. On the other hand, if idU is included under H then the attacker needs to build a dictionary per idU.  This would mean that at login and before talking to the server, the client knows a value of idU that was set at registration. If this is considered too problematic, one can live with the above issue as online attacks, particularly from the server side are not so damaging (I think). One can also include the server identity under H as may always be needed by the client in order to contact the server.",
          "createdAt": "2020-10-22T15:08:19Z",
          "updatedAt": "2020-10-22T15:08:19Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWU3MjY4NjkzNTc=",
      "title": "Allow OPRF context creation with external key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/67",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is more of an issue with the OPRF draft, but noting it here for now. The OPRF context constructor does not allow creation of a server with an existing key, which makes the OPRF credential response generation function somewhat annoying to implement. ",
      "createdAt": "2020-10-21T21:16:22Z",
      "updatedAt": "2020-11-02T23:54:06Z",
      "closedAt": "2020-11-02T23:54:06Z",
      "comments": []
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWU3MjY4Njk4NTE=",
      "title": "OPRF evaluation output",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/68",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The output of `Evaluate` in the OPRF draft is an `Evaluation` object, which has both a blinded and signed element, as well as a proof. We should either adopt that type here, or make it clear in our notation that the output of `Evaluate` is just the blinded and signed element.\r\n\r\nNote that this affects what's carried in a `RequestMetadata` struct. ",
      "createdAt": "2020-10-21T21:17:15Z",
      "updatedAt": "2020-12-21T17:00:15Z",
      "closedAt": "2020-12-21T17:00:15Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Aside from the specification issues, I would explicitly note (if not done yet) that we use the OPRF without proof/verifiability. Doing so would require the user to carry the g^kU value with him/her contradicting the password-only property of OPAQUE.",
          "createdAt": "2020-10-22T14:41:01Z",
          "updatedAt": "2020-10-22T14:41:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I clarified this with a text change right on master. Closing.",
          "createdAt": "2020-12-21T17:00:15Z",
          "updatedAt": "2020-12-21T17:00:15Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWU3MjY4NzEwNjQ=",
      "title": "Specify harden parameters",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/69",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "next-version"
      ],
      "body": "Clients need a way to recover credential information during registration. So we should either (a) fix some Harden parameters, or (b) have servers send these during the registration and authentication flows. \r\n\r\n@kevinlewi, what do you think?",
      "createdAt": "2020-10-21T21:19:22Z",
      "updatedAt": "2021-02-07T22:10:09Z",
      "closedAt": "2021-02-05T23:54:48Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you clarify what you mean by (a)? If you mean to provide concrete settings, I think we may want to avoid that since these numbers can become out of date, and are application-dependent. For (b), I think we should avoid this as well, unless we start also deciding to send information about group representation / hash functions during these flows. Also, there is no way for the server to enforce that the client follows the harden parameters, and so these are at best recommendations.\r\n\r\nMy approach would be to allow for parameterizing the protocol based on harden parameters. So in the same way that we can have OPAQUE with Ristretto points versus Edwards, or OPAQUE with SHA3 versus Blake3, the choice of a hardened hash function should just be another parameter.",
          "createdAt": "2020-10-21T22:12:30Z",
          "updatedAt": "2020-10-21T22:12:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ">  If you mean to provide concrete settings, I think we may want to avoid that since these numbers can become out of date, and are application-dependent. \r\n\r\nYeah, that's what I mean, and that's the risk. \r\n\r\n> My approach would be to allow for parameterizing the protocol based on harden parameters. So in the same way that we can have OPAQUE with Ristretto points versus Edwards, or OPAQUE with SHA3 versus Blake3, the choice of a hardened hash function should just be another parameter.\r\n\r\nI think there's generally too much flexibility in what's currently in the document. We have ciphersuites, configurations, optional parameters, etc. All of this runs the risk of making implementations challenging to get right. I would be in favor of something a bit more rigid. Could you please draft a PR to take care of this with your proposal? (This would also ideally address #58.)",
          "createdAt": "2020-10-21T22:35:00Z",
          "updatedAt": "2020-10-21T22:36:27Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I might have misinterpreted, but I was not suggesting to modify the current proposal in any way, except to suggest that when producing test vectors, we have a set which instantiates Harden with a specific function.\r\n\r\nSo my proposal is to keep everything in the draft the same, and when presenting test vectors, we provide annotated options such as:\r\n- OPAQUE-X25519-3DH-SHA256-Scrypt10k,\r\n- OPAQUE-Ristretto255-SigmaI-Blake3-Argon2i100k,\r\n- etc.\r\n\r\nThis means that we will be supporting the increased flexibility that you may be against.\r\n\r\nBtw, while we are on the topic, the flexible parameters I am currently tracking are:\r\n- Group representation\r\n- Keypair format\r\n- AKE protocol\r\n- Hash function\r\n- Harden function\r\n\r\n(Also represented in code [here](https://github.com/novifinancial/opaque-ke/blob/master/src/ciphersuite.rs#L15-L23))\r\n\r\nLet me know if you think I am missing any others...",
          "createdAt": "2020-10-21T22:48:43Z",
          "updatedAt": "2020-10-21T22:48:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Those match my understanding, yeah. Do we really *need* this sort of flexibility? I'm not sure! \r\n\r\nThough, hmm... on reflection, why are the parameters of Harden something the configuration (server?) ought to specify at all?",
          "createdAt": "2020-10-22T00:01:18Z",
          "updatedAt": "2020-10-22T00:01:18Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, I don't think the specification needs to specify the parameters of Harden, but an implementation may want to provide options for configuring them.",
          "createdAt": "2020-10-22T01:15:24Z",
          "updatedAt": "2020-10-22T01:15:24Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "After some offline discussion, we have settled on the following as the main point of discussion:\r\n\r\nLet's suppose a client registers their password using a particular hardening function. How should the client on login know what parameters for the hardening function to use? Two potential options:\r\n1) This shouldn't be part of the OPAQUE protocol, and it should be the responsibility of the wrapping protocol to ensure that the login surface's hardening parameters match those of registration, or to optionally store an annotation at registration time to help inform what parameters to use for login.\r\n2) This should be incorporated into OPAQUE, potentially through an extra client-specified field that can be stored alongside the password file.\r\n\r\nIf we go with Option 2, there are more follow-up questions, such as whether or not this field should be free-form, if it should be authenticated, etc.\r\n\r\ncc: @chris-wood",
          "createdAt": "2020-10-22T02:42:14Z",
          "updatedAt": "2020-10-22T02:42:14Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If the hardening parameters are transmitted from server to client, it would be better to authenticate them, or otherwise a cheating server can either apply a DoS attack on the client by sending extremely large parameters or help in a dictionary attack with small parameters (the latter would only apply to an online attack posing as the server).",
          "createdAt": "2020-10-22T14:58:20Z",
          "updatedAt": "2020-10-22T14:58:20Z"
        },
        {
          "author": "huitseeker",
          "authorAssociation": "NONE",
          "body": "I vote for option 1: This shouldn't be part of the OPAQUE protocol. While it's one of the strengths of the abstract protocol to be generic, in practice deployments will be content with one particular suite of sub-protocols (for each of the available choices). \r\n\r\nAllowing the server to fix a set of choices without any further variability in messages avoids the headache of downgrade attacks.",
          "createdAt": "2020-10-22T17:17:09Z",
          "updatedAt": "2020-10-22T17:17:09Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitseeker Accepting unauthenticated parameters from the server can allow some form of downgrade attack as I mentioned before in this thread (sending low hardening parameters helps in an online dictionary attack where the attacker spoofs the server).",
          "createdAt": "2021-02-04T19:23:38Z",
          "updatedAt": "2021-02-04T19:23:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was resolved by pinning configuration parameters as part of the configuration. In-band negotiation is (we believe) too complex to justify the cost. Closing as resolved.",
          "createdAt": "2021-02-05T23:54:48Z",
          "updatedAt": "2021-02-05T23:54:48Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "How does the client learn the configuration? If the client is an application like Facebook I can see that the app on the user side has these parameters wired in. What about browser-based login with clients that were not pre-configured? Are you intentionally not supporting this case?  One could transmit ciphersuite (and even parameters) in the envelope (which come authenticated). Even just a hash of the configuration in the envelope would defend against rogue/downgraded configurations.",
          "createdAt": "2021-02-06T04:23:50Z",
          "updatedAt": "2021-02-06T04:23:50Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "The general philosophy that I think would be helpful to maintain in terms of \"what should go in the envelope\" is that: only the minimum necessary in order for the OPAQUE protocol to function -- therefore, the skU parameter belongs there. I'm hoping that if an application wishes to transmit ciphersuite information and harden parameters in the envelope, they can instead make use of the `export_key` parameter as a key for authenticated encryption.\r\n\r\n> What about browser-based login with clients that were not pre-configured? Are you intentionally not supporting this case?\r\n\r\nI think that this describes a less popular potential application of OPAQUE, which is why I would be hesitant to incorporate parameters that specifically support this into the envelope. At the same time, there is still the flexibility from the application layer to use `export_key` for this purpose.\r\n\r\n@hugokraw let me know what you think! Also cc: @chris-wood  since we had a discussion about this in the past as well.\r\n",
          "createdAt": "2021-02-07T00:22:03Z",
          "updatedAt": "2021-02-07T00:22:03Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Configuration information that may impact the derivation of RwdU cannot be protected by export_key. It is too late for that (e.g., in setting the hardening parameters or the algorithms with which export_key is derived and/or used.  \r\n\r\nThe point of using the envelope to transmit parameters is that it is the only information the client gets in an authenticated way. Actually, in the case of OPAQUE over TLS, the server will first authenticate using a TLS certificate. In this case, the server can transmit  hardening and other parameters to the client  authenticated under the certificate. We should not do anything now that will make it difficult to accommodate such configuration information in the over-TLS case.  \r\nWhat do you think @chris-wood ?",
          "createdAt": "2021-02-07T22:04:15Z",
          "updatedAt": "2021-02-07T22:04:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think what we have now is suitable for the TLS case. The future TLS spec can define how harden parameters are encoded and transmitted. And the client, if it supports those parameters, can use them. (In other words, the parameters part of the configuration, and the future TLS spec would just define how to express and choose the configuration.)\n\nI don't think anything else needs to be done with respect to harden parameters in this particular spec.",
          "createdAt": "2021-02-07T22:10:09Z",
          "updatedAt": "2021-02-07T22:10:09Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "MDU6SXNzdWU3MjY5OTM2MDk=",
      "title": "Why does FinalizeRequest take in idU as a parameter?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/72",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "According to [this](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L651), idU is used to construct FinalizeRequest, despite it only being applicable if the application decides to include it in the Credentials struct: > \"Applications may optionally include\r\n> `pkU`, `idU`, or `idS` in the `Credentials.cleartext_credentials` structure, or in\r\n> `Credentials.secret_credentials` if secrecy of these values is desired.\"\r\n\r\nBut if this is the case, then why not also make idS and pkU parameters to FinalizeRequest as well?\r\n\r\nSame goes for RecoverCredentials. Either they should take in all of these optional parameters as inputs, or they should not include any of them.",
      "createdAt": "2020-10-22T02:32:52Z",
      "updatedAt": "2020-10-28T18:59:00Z",
      "closedAt": "2020-10-28T18:59:00Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposal: remove application-specific credential information from the parameter list, and call out to the application to build `Credentials` based on the server's `secret` and `cleartext` list.",
          "createdAt": "2020-10-23T21:09:43Z",
          "updatedAt": "2020-10-23T21:09:43Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWU3MzAwNzYyODg=",
      "title": "Clarifying optional versus required parameters in the AKE section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/74",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In this [section on AKE](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1008-L1014), we should clear up exactly which parameters are required and which are optional. Then we can also work towards defining a wire format for these AKEs if necessary.\r\n\r\nA couple of concrete questions:\r\n1) Can we simply set idU = static pkU and idS = static pkS?\r\n2) Can we remove mention of all of the following: info1*, info2*, Einfo2*, info3*, Einfo3*?\r\n",
      "createdAt": "2020-10-27T03:42:24Z",
      "updatedAt": "2020-11-12T23:41:22Z",
      "closedAt": "2020-11-12T23:41:22Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> 1. Can we simply set idU = static pkU and idS = static pkS?\r\n\r\nThis had been discussed in the past, and I think it depends on whether or not there exists a secure binding between the public key(s) and corresponding identity. (And that seems mostly external to the protocol.) I need to think about this more. @hugokraw probably also has opinions. :-)\r\n\r\n> 2. Can we remove mention of all of the following: info1*, info2*, Einfo2*, info3*, Einfo3*?\r\n\r\nThese fields exist to make the AKE instantiation more generic, e.g., maybe `info1` contains the client's set of application protocols run on top of the AKE. I think we should remove them, since applications that need this flexibility should be using TLS. I view the 3DH and SIGMA-I variants as minimalist OPAQUE instantiations. ",
          "createdAt": "2020-10-28T13:01:30Z",
          "updatedAt": "2020-10-28T13:01:30Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding point 1: In general, identities refer to logical entities on the basis of which policy decisions by the receiving party are made (do I want to talk to this identity, under what security level, which access rights, etc.) A public key may be used as an identity but most of the time it is not (e.g. , it is the subject in a certificate rather than the public key). In the case of OPAQUE,  using public keys may be more acceptable since those are fixed after registration and the client authenticates the server's public key via the password. I am not sure if this means that the client will never need to make decisions based on the server's logical identity but I do not see an obvious setting where this is the case. However, note that in the three protocols in the draft, the client does not use the user's public key. So if we are going to use it then we either send it as part of the authenticated information in the envelope or require the client to re-compute it from the user's private key at the cost of an exponentiation.",
          "createdAt": "2020-10-28T16:28:57Z",
          "updatedAt": "2020-10-28T16:28:57Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding point 2: We want these AKEs to be minimalistic but not useless. I do not see the case of any key exchange protocol that does not require sending some additional setting-specific information in its flows. Instead of having these fields named specifically, you may define some extensibility mechanism to transport additional information, but some mechanism for that must exist.",
          "createdAt": "2020-10-28T16:31:11Z",
          "updatedAt": "2020-10-28T16:31:11Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for the comments!\r\n\r\nFor point 1: I would be in favor of requiring the client to re-compute the user's public key from its private key at the cost of an exponentiation, if it means that we do not need to send idU over the wire for the KE1 message. Similarly, for idS, since the server's public key is already required to be a part of the authenticated envelope, I would be in favor of omitting idS from the KE2 message as well (it is not currently there but just in case that comes up).\r\n\r\nFor point 2: Fair enough, we can keep them as optional parameters, but just to double-check, for the sake of minimalism: do you think we need both the plaintext variants (info1*, info2*, info3*) in addition to the encrypted variants (Einfo2*, Einfo3*), or would one set of these suffice?",
          "createdAt": "2020-10-28T18:56:53Z",
          "updatedAt": "2020-10-28T18:56:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding point 2, why can't applications send info *after* the AKE completes? (I understand that it burns a round trip, but that seems preferable to additional complexity in the AKE protocol itself.) In other words, an AKE without application slots is *not* useless. It's minimal, and allows applications to build whatever it is they need on top. \r\n\r\nSimply put, absent a specific use case for extensions, I'm not convinced they need to exist. ",
          "createdAt": "2020-10-28T19:15:02Z",
          "updatedAt": "2020-10-28T19:16:19Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The plaintext info field may be needed to transport information needed to select the algorithms and type of protection applied by the AKE and cannot be postponed to after the end of the AKE. The encrypted info field may be needed to transport information that requires privacy. I am all for simplifying wherever possible but I also want a usable specification. Eliminating all information beyond the core crypt operations does not seem to lead to such usable specification.  \r\n\r\nI am ok with letting pkU and pkS act as identities but I can also see implementations that would prefer to use something like a uid@site.dom as idU and save the computation of pkU. Would you be ok with having the id's be optional elements in the envelope (but omitted from the AKE messages)? \r\n ",
          "createdAt": "2020-10-28T22:10:20Z",
          "updatedAt": "2020-10-28T22:10:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The plaintext info field may be needed to transport information needed to select the algorithms and type of protection applied by the AKE and cannot be postponed to after the end of the AKE. \r\n\r\nI'm not sure I agree with this. If cryptographic algorithm negotiation is needed for the AKE, then we should specify the mechanics to do that. We shouldn't just provide a generic slot for application info and punt the problem downstream. (Or, put differently, leaving just `info` and assuming it'll be used for cryptographic algorithm negotiation is an underspecified AKE, and not something applications can implement safely or correctly on their own.)\r\n\r\n> The encrypted info field may be needed to transport information that requires privacy. \r\n\r\nIf privacy is required, this information can be sent after the AKE completes. Why does it need to be done in-band?\r\n\r\n> I am all for simplifying wherever possible but I also want a usable specification. Eliminating all information beyond the core crypt operations does not seem to lead to such usable specification.\r\n\r\nI think it's the opposite. If we keep the specification as minimal as I'm advocating for, then applications are free to use the AKE's output however they want. ",
          "createdAt": "2020-10-28T22:22:40Z",
          "updatedAt": "2020-10-28T22:24:12Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Would you be ok with having the id's be optional elements in the envelope (but omitted from the AKE messages)?\r\n\r\nI believe idU and idS can already be specified as optional elements in the envelope (see [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L438-L439)), and so I would be happy to go with omitting them from the AKE messages.",
          "createdAt": "2020-10-28T22:29:19Z",
          "updatedAt": "2020-10-28T22:29:19Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Would you be ok with having the id's be optional elements in the envelope (but omitted from the AKE messages)?\r\n> \r\n> I believe idU and idS can already be specified as optional elements in the envelope (see [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L438-L439)), and so I would be happy to go with omitting them from the AKE messages.\r\n\r\nOk. So we can eliminate them from the AKE messages but have an explicit specification that the values idU and idS in the KDF are those specified in the envelope or, if omitted there, then pkU and pkS  (with a note that pkU will need to be computed by the client if not transmitted in the envelope).\r\n\r\n\r\n",
          "createdAt": "2020-10-28T22:32:38Z",
          "updatedAt": "2020-10-28T22:32:38Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think it's the opposite. If we keep the specification as minimal as I'm advocating for, then applications are free to use the AKE's output however they want.\r\n\r\nThe are always free to use the AKE output however they want. The question is whether they will have enough information to run and complete the AKE if they cannot send more than the bare cryptographic elements during the AKE. \r\n",
          "createdAt": "2020-10-28T22:37:09Z",
          "updatedAt": "2020-10-28T22:37:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The are always free to use the AKE output however they want. The question is whether they will have enough information to run and complete the AKE if they cannot send more than the bare cryptographic elements during the AKE.\r\n\r\nAs specified currently, and ignoring the `info` fields, is this the case? If so, shouldn't we specify everything that's needed to complete the AKE in this spec? I don't see how we can punt on that!",
          "createdAt": "2020-10-28T22:38:55Z",
          "updatedAt": "2020-10-28T22:38:55Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> As specified currently, and ignoring the `info` fields, is this the case? If so, shouldn't we specify everything that's needed to complete the AKE in this spec? I don't see how we can punt on that!\r\n\r\nI am thinking of these AKEs as something people will need to customize to their application/setting. The usage by Facebook and the ones by AWS are very different and they will need to fill in the details according to their needs.",
          "createdAt": "2020-10-28T22:44:40Z",
          "updatedAt": "2020-10-28T22:44:40Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If it helps (I am not fully convinced), I am ok with removing info and einfo in the current description, and instead adding language saying that what is shown is the minimal cryptographic skeleton and that applications may need to transport additional information as part of the AKE. In such a case, any information transmitted as part of the AKE messages must be included in the transcript fields (that are mac-ed in 3DH/HMQV and signed in SIGMA).  In addition, we specify the derivation of authenticated encryption keys (denote Ke2, Ke3) to be used for confidentiality protection of elements in the transcript that require such protection.",
          "createdAt": "2020-10-28T23:07:17Z",
          "updatedAt": "2020-10-28T23:07:17Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since the discussion on point #2 seems to be around either: leaving in the optional parameters info and einfo, or omitting them entirely, it seems like the tradeoffs are the following:\r\n\r\nPros for leaving in the optional parameters info* and einfo*:\r\n- A potential application that wants to use these fields can do so without having to wait the extra round trip for AKE to finish\r\n\r\nCons for leaving in the optional parameters info* and einfo*:\r\n- Increased spec / API complexity for implementers\r\n- Increased bandwidth due to bytes spent on length-prefixing the optional parameters in AKE even if they are not used\r\n\r\nIs this an accurate summary? If so, I am leaning slightly towards keeping in the optional parameters, but not with a strong preference :) ",
          "createdAt": "2020-10-28T23:22:52Z",
          "updatedAt": "2020-10-28T23:22:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is this an accurate summary? If so, I am leaning slightly towards keeping in the optional parameters, but not with a strong preference :)\r\n\r\nYeah, I think that's mostly accurate. Can you elaborate on why you're leaning that way? (If you used them in your implementation, what were the values of the fields?)",
          "createdAt": "2020-10-28T23:33:51Z",
          "updatedAt": "2020-10-28T23:33:51Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "My feeling is that we serve better the potential implementers of OPAQUE that need to embed the protocol in their specific application by guiding them toward they way of adding application specific elements to the protocol, in particular telling them that they should add these elements to the authenticated transcript and use Ke to protect confidentiality if needed. As I wrote elsewhere, I am ok if we remove info, einfo from the spec but then we must have English text about the need to include such elements under the authenticated transcript. Also noting the potential need for Ke (which we would include in the key derivation even if we do not show einfo* explicitly).  My bottom line: We would be serving implementers of OPAQUE in specific applications better with the info fields than without. (But who am I to tell what implementers really need? :-)\r\n ",
          "createdAt": "2020-10-28T23:36:24Z",
          "updatedAt": "2020-10-28T23:36:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> My bottom line: We would be serving implementers of OPAQUE in specific applications better with the info fields than without.\r\n\r\nYeah, I think if the goal is to allow applications to build a one-off AKE specific to their use case, then I think this is the right call. If, on the other hand, we're specifying a feature-complete AKE in this spec, I lean the other way. ",
          "createdAt": "2020-10-28T23:38:54Z",
          "updatedAt": "2020-10-28T23:38:54Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Is this an accurate summary? If so, I am leaning slightly towards keeping in the optional parameters, but not with a strong preference :)\r\n> \r\n> Yeah, I think that's mostly accurate. Can you elaborate on why you're leaning that way? (If you used them in your implementation, what were the values of the fields?)\r\n\r\nOne example that comes to mind is the following: Suppose a client is using a password to log in to a server, and on the KE2 message, the server wants to send to the client auxiliary information about the last time the client successfully logged in (IP address, # of incorrect login attempts since last login, etc.). These are of course things that can wait 1 more round trip for, but in certain applications it may be more convenient to not have to wait.\r\n\r\nAnyway, the main reason why I am leaning towards including the optional parameters is because I feel like we are more likely to regret excluding them than the other way around. I believe the added API complexity only affects those who have to implement a spec-compliant OPAQUE (hopefully a small population) and the benefits of having the flexiblity to use these optional parameters would affect those who use the spec-compliant OPAQUE implementations (hopefully a larger population).\r\n\r\n@huitseeker in case he has any additional thoughts on this",
          "createdAt": "2020-10-29T00:06:49Z",
          "updatedAt": "2020-10-29T00:06:49Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> I feel like we are more likely to regret excluding them than the other way around\r\n\r\nI would have not dared to show my feelings like Kevin's but I strongly feel like him :-)\r\n\r\n",
          "createdAt": "2020-10-29T02:22:07Z",
          "updatedAt": "2020-10-29T02:22:07Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yeah, I think if the goal is to allow applications to build a one-off AKE specific to their use case, then I think this is the right call. If, on the other hand, we're specifying a feature-complete AKE in this spec, I lean the other way.\r\n\r\nThis is indeed the point in which our view diverge. I hear of several people with various interests, including Kevin/Facebook, Crockett/AWS and people from some banks. They were all talking of specific applications they have rather than using a general Web/TLS-based protocol. I think that the document we are writing needs to serve these people. It can also serve those integrating OPAQUE in other protocols IKEv2, SSH, ...",
          "createdAt": "2020-10-29T02:26:22Z",
          "updatedAt": "2020-10-29T02:26:22Z"
        },
        {
          "author": "huitseeker",
          "authorAssociation": "NONE",
          "body": "Optional information parameters can be useful, and if the past is prologue, they'll eventually be useful to shave off round-trips on auxiliary data in what's after all a latency-sensitive initial setup.\r\n\r\nSo, in that regard, if we keep those useful parameters in:\r\n- might it make sense to be very clear on what guarantees (as to authentication, compromise resistance, resistance to key compromise ...) the server can expect at the time it sends these optional parameters?\r\n- would it make sense to make an opt-in to those parameters a strong signal, maybe by committing to it in a ciphersuite string?",
          "createdAt": "2020-11-02T20:56:00Z",
          "updatedAt": "2020-11-02T20:56:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, on reflection, I think keeping the parameters is probably the best path forward. @kevinlewi, how do you want to deal with point (1)?",
          "createdAt": "2020-11-02T23:53:49Z",
          "updatedAt": "2020-11-02T23:53:49Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For #1, recapping the summary from @hugokraw :\r\n\r\n> Ok. So we can eliminate them from the AKE messages but have an explicit specification that the values idU and idS in the KDF are those specified in the envelope or, if omitted there, then pkU and pkS (with a note that pkU will need to be computed by the client if not transmitted in the envelope).\r\n\r\nSo, let's remove their presence from the AKE messages, and I would vote for setting idU = pkU and idS = pkS when computing the AKE components (instead of reusing idU and idS that were optionally specified in the envelope).",
          "createdAt": "2020-11-03T00:42:23Z",
          "updatedAt": "2020-11-03T00:42:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems reasonable to me. Can you please draft a PR?",
          "createdAt": "2020-11-03T03:01:58Z",
          "updatedAt": "2020-11-03T03:01:58Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> So, let's remove their presence from the AKE messages, and I would vote for setting idU = pkU and idS = pkS when computing the AKE components (instead of reusing idU and idS that were optionally specified in the envelope).\r\n\r\nDo you mean removing idU and idS from the envelope, even as optional, and always using pkU and pkS as the identities in the AKE? I am responding to that interpretation. If that's not what you were saying, ignore this.\r\n\r\n Identities are central to authorization, access control, etc. and password protocols are central to these services so I think we need to leave flexibility there. Having the optional idU, idS in the envelope and pkU, pkS as default seems like a good balance between flexibility and ease of implementation.",
          "createdAt": "2020-11-03T06:14:31Z",
          "updatedAt": "2020-11-03T06:14:31Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@hugokraw That is not quite what I mean; I am all for keeping idU and idS as optional parameters in the envelope. However, the **AKE portion** also refers to idU and idS: in particular, the values referenced [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1138-L1139). The question is -- should these simply be set to idU = pkU and idS = pkS, or should they be the same idU and idS that were optionally specified in the envelope?\r\n\r\nI am advocating for idU = pkU and idS = pkS just for the **AKE portion**, the values [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1138-L1139). It would be great to get your thoughts on this!",
          "createdAt": "2020-11-04T21:12:56Z",
          "updatedAt": "2020-11-04T21:12:56Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "There is no use for idU and idS transported in the envelope other than to serve as identities in the AKE in lieu of any other identity that the parties may use to initially identify each other (for the client to know which server to contact and for the client to let the server know what user record to fetch). For example, I use hugokraw as my moniker in github but github may actually use my email address as my official identity (I don't know if this is the case, it is an imaginary example as far as I can tell).  I find it too limiting to dictate applications what's the identity they want to bind the AKE to.",
          "createdAt": "2020-11-05T06:23:34Z",
          "updatedAt": "2020-11-05T06:23:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Summary of discussion from the call: If there is no identity in the envelope, the AKE ID matches the public key. Conversely, if there is an identity in the envelope, that is the used in AKE.\r\n\r\n@hugokraw, @kevinlewi: does this match your understanding? \r\n\r\nIf so, we should elaborate on [this section](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#name-ake-execution-and-party-ide) to explain the differences between these identities and their respective use cases. In the process, we should recommend one implementation strategy for applications, e.g., by recommending that the AKE ID be the public key, and if a separate identity is desired, it's put in the envelope. In doing so, we should add text to deal with the case where application identities are long -- perhaps too long to store in the envelope. In such cases, a hash of the identity might be stored in the envelope and threaded into the AKE, and the server needs to check the hash against the long-form identity. ",
          "createdAt": "2020-11-06T22:58:29Z",
          "updatedAt": "2020-11-06T23:04:51Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Excellent -- yes, thank you, this matches my understanding!\r\n\r\nJust to double-check, the same logic applies for idS, of course, right? (Default to pkS, unless idS is specified in the envelope, in which case use that)",
          "createdAt": "2020-11-06T23:10:41Z",
          "updatedAt": "2020-11-06T23:10:41Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Good (and yes, same logic for idS).\r\n\r\nNote: Currently, [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#finalizerequest) we say \"Applications may optionally include pkU, idU, or idS....\" in the envelope. We may want to clarify that if pkU is to be used as idU, this value needs to be sent in the envelope or the client would need to compute pkU from skU.\r\n",
          "createdAt": "2020-11-07T05:12:23Z",
          "updatedAt": "2020-11-07T05:12:23Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood @hugokraw Thanks! There is one more edge case to discuss:\r\n\r\nSuppose idU and idS are part of the envelope, but they are stored as a secret_credential (encrypted under `rwdU`) as opposed to something that the server can read in plaintext? The server will not be able to perform the AKE key derivation since it cannot read these values in place of idU and idS.\r\n\r\nAlso, what if they are stored authenticated in the envelope under cleartext_credentials? Do we expect the server to read the values without trying to check the MAC on them (since that would also require `rwdU`)?\r\n\r\nOf course, one way to simplify all of this is to simply default idU = pkU and idS = pkS and not try to have the server read the envelope's contents.",
          "createdAt": "2020-11-09T05:13:59Z",
          "updatedAt": "2020-11-09T05:15:04Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If idU and/or idS are stored under secret_credential, the server needs some other form of access to these values. The server cannot decrypt or authenticate the envelope; only the client in possession of the password (and after computing rwdU) can. Typically, the server will store these values separately or can derive them from other information it has, e.g., it knows its own identity idS or it derives idU from the identity it uses to identify the user's record. If the values are stored in the envelope in cleartext, the server can choose to read them from there; it is an implementation issue.",
          "createdAt": "2020-11-09T15:48:19Z",
          "updatedAt": "2020-11-09T15:48:19Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Makes sense. In that case, I propose that we set the default behavior to use idU = pkU and idS = pkS. And then, if the wrapper protocol wishes to use a custom idU and idS, then the OPAQUE protocol can accept these custom parameters from the wrapper protocol and use them in the AKE instead. Thus, the envelope would be completely ignored when doing this calculation.",
          "createdAt": "2020-11-09T19:05:13Z",
          "updatedAt": "2020-11-09T19:05:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If the envelope's identities are (effectively) ignored, would we keep idU and idS as valid credential types?",
          "createdAt": "2020-11-09T20:17:20Z",
          "updatedAt": "2020-11-09T20:17:20Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood That's a fair question -- perhaps we can create a separate issue to discuss the inclusion of idU and idS in the envelope, once we land the changes prescribed here?",
          "createdAt": "2020-11-09T20:21:53Z",
          "updatedAt": "2020-11-09T20:21:53Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The question is whether the client needs to accept the identities provided by the wrapper as the client cannot authenticate those. If authentication is needed then one must either use the default pkS identity for S or otherwise idS needs to be authenticated by the envelope. To illustrate the need for authentication, consider a setting where the application running on the client side has an access control policy with some permission rules for accessing a resource R.  Both idS and idS* are known server names to which the user may connect so both names have defined permissions for resource R. Note that the policy is defined in terms of names, not public keys (as with subject names in certificates vs.  public keys), and the names are received from the AKE layer once authentication succeeds (the AkE may pass several elements to the higher layers, including the peer's identity).\r\n\r\nNow suppose the client connects to idS who runs a rogue wrapper that provides the client with the correct envelope for idS but gives idS* as the identity.  The client will end the AKE successfully but with identity idS*. Indeed, the server (whose real name is idS) will authenticate using his own private key (corresponding to the public key in the envelope) but will enter the name idS* to the AKE which the client will do too (as it is using the identity provided by the wrapper). So the AKE level will pass to the access control policy the identity idS* and idS (not idS*) will be granted access to resource R.\r\n",
          "createdAt": "2020-11-09T22:36:22Z",
          "updatedAt": "2020-11-09T22:36:22Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@hugokraw I am not entirely sure if you are proposing that we deviate from my [above comment](https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/74#issuecomment-724214162) (it seems like you are still in agreement), but I think to address the concern that you mentioned, the OPAQUE implementation should simply surface both idS (found in the envelope) and idS* (as output by the AKE) to the client, and allow the wrapper protocol on the client side decide whether or not it is valid for idS != idS*. Similarly for idU / idU* on the server-side.\r\n\r\n\r\n",
          "createdAt": "2020-11-09T23:34:54Z",
          "updatedAt": "2020-11-09T23:34:54Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If I understand correctly your proposal, it says: \"Either use the default identities pkU, pkS, or let the wrapper decide on these identities.\" This presumes the wrapper application to be trusted and a final decision maker on what identities are acceptable.\r\nIn this case, I do not see the need to ever transport identities in the envelope. Or do you still think there is a point in allowing identities in the envelope in this case? How would they be used? \r\n\r\nI don't have an opinion on the trust one should put on the wrapper (I don't have enough use cases in mind to reason about it), but I'd hesitate to specify OPAQUE with such a universal trust assumption. It feels safer  (but maybe too limiting?) to make all decisions based on what OPAQUE can validate. Namely, follow the strict policy by which AKE identities are defined in the envelope and if they are missing from it then they default to pkU and pkS.",
          "createdAt": "2020-11-10T06:18:55Z",
          "updatedAt": "2020-11-10T06:18:55Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, I think this makes sense, and we can first check for the existence of the identities in the envelope, and if they are missing, default to pkU and pkS (as we agreed to in [this comment](https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/74#issuecomment-723337010)).\r\n\r\nBut just as an FYI, since we must distinguish between the OPAQUE protocol run on the server versus the wrapper protocol that calls OPAQUE on the server, this means that the OPAQUE server protocol will have to **ask the wrapper protocol for the idU and idS it should use for the AKE**, since it cannot decrypt/authenticate the contents of the envelope. Just want to make sure we are clear on that.\r\n\r\nIf so, I believe we are good to go.",
          "createdAt": "2020-11-10T22:07:12Z",
          "updatedAt": "2020-11-10T22:07:12Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "There are many ways in which the server can decide on the values of idS and idU. It can indeed ask the wrapper for those values but it could also  set idS and idU at registration (or later) and store them in the user's record, or it can read these values from the envelope if stored unencrypted there.  All these options are legit. \r\nNote that the setting here is very different for the user and server.  The user has no way of authenticating anything other than with his password (hence it can only authenticate information in the envelope) but the server has local storage with information (e.g., idS and idU) that it can trust.",
          "createdAt": "2020-11-11T04:01:54Z",
          "updatedAt": "2020-11-11T04:01:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi I think we can close this as resolved now. Do you want to do the honors?",
          "createdAt": "2020-11-12T23:32:38Z",
          "updatedAt": "2020-11-12T23:32:38Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks everyone for engaging in the discussions!",
          "createdAt": "2020-11-12T23:41:21Z",
          "updatedAt": "2020-11-12T23:41:21Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWU3MzA5ODIzNDM=",
      "title": "Swap 3DH label strings around",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/75",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the 3DH key schedule computes two MAC and two encryption keys, as follows:\r\n\r\n```\r\nKm2 = HKDF-Expand-Label(handshake_secret, \"client mac\", \"\", Hash.length)\r\nKm3 = HKDF-Expand-Label(handshake_secret, \"server mac\", \"\", Hash.length)\r\nKe2 = HKDF-Expand-Label(handshake_secret, \"client enc\", \"\", key_length)\r\nKe3 = HKDF-Expand-Label(handshake_secret, \"server enc\", \"\", key_length)\r\n```\r\n\r\n`Km2` is the key used to compute the server's MAC in `KE2`:\r\n\r\n```\r\nKE2 = credential_response, nonceS, info2, epkS, Einfo2, MAC(Km2; transcript2),\r\n```\r\n\r\nUsing the label `\"client mac\"` to derive `Km2` seems backwards. Let's swap them around, like so:\r\n\r\n```\r\nKm2 = HKDF-Expand-Label(handshake_secret, \"server mac\", \"\", Hash.length)\r\nKm3 = HKDF-Expand-Label(handshake_secret, \"client mac\", \"\", Hash.length)\r\nKe2 = HKDF-Expand-Label(handshake_secret, \"server enc\", \"\", key_length)\r\nKe3 = HKDF-Expand-Label(handshake_secret, \"client enc\", \"\", key_length)\r\n```\r\n\r\ncc @hugokraw, @kevinlewi ",
      "createdAt": "2020-10-28T00:47:29Z",
      "updatedAt": "2020-11-02T23:54:07Z",
      "closedAt": "2020-11-02T23:54:06Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Definitely a typo. Good catch.",
          "createdAt": "2020-10-28T15:23:11Z",
          "updatedAt": "2020-10-28T15:23:11Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "MDU6SXNzdWU3MzE0MzgzMjk=",
      "title": "Nail down AKE instantiations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/77",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "TLS 1.3 *is* the SIGMA-I instantiation, so I think we should drop this from the OPAQUE document. It's redundant, and will likely cause confusion between people who want to choose between one or the other. \r\n\r\ncc @kevinlewi ",
      "createdAt": "2020-10-28T13:24:01Z",
      "updatedAt": "2021-02-03T00:38:54Z",
      "closedAt": "2021-02-03T00:38:54Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't agree with this one. It is important to show that OPAQUE can use any AKE protocol and 3DH/HMQV are of a very special type. In particular, signature-based protocols are always KCI-secure while KEM-based (and \"implicitly authenticated\") are not always. Moreover, if you go by efficiency and you do not want to use HMQV because of the patent, then SIGMA-I is more efficient than 3DH. These are illustrations of the protocol if you want to build it as standalone, not necessarily with TLS. Those building upon TLS are more likely to use the version based on exported authenticators than a 3-flow handshake. \r\nYou can always choose 3DH as the must-to-implement protocol and leave SIGMA-I as optional.",
          "createdAt": "2020-10-28T15:33:17Z",
          "updatedAt": "2020-10-28T15:33:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see any variant in the document as mandatory to implement. I see them as different flavors of AKEs that applications can choose to implement based on their needs. And I think that decision tree should look like the following:\r\n\r\n- If we don't need signatures for authentication, use 3DH (or HMQV)\r\n- If we do need signatures for authentication, use TLS 1.3 with OPAQUE\r\n\r\nCurrently, the decision tree is something like the following:\r\n\r\n- If we don't need signatures for authentication, use 3DH\r\n- If we do need signatures for authentication, use SIGMA-I or TLS 1.3 with OPAQUE. (How do we decide to use TLS 1.3 or SIGMA-I?)\r\n\r\nThe core of this issue is that I don't think it's best to introduce *yet another* AKE with the same shape as TLS 1.3. ",
          "createdAt": "2020-10-28T16:21:09Z",
          "updatedAt": "2020-10-28T16:21:09Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that there is no need to have a must-to-implement version other than for interoperability tests. But I am not sure that someone using a standalone implementation of OPAQUE will necessarily need all the complexities of TLS 1.3 to implement a simple OPAQUE-SIGMA version. An example of a protocol that would favor a signature-based instantiation that is not TLS 1.3 is IKEv2, although they would use SIGMA-R. Yet illustrating SIGMA-I in the document would help that case too.",
          "createdAt": "2020-10-28T16:38:24Z",
          "updatedAt": "2020-10-28T16:38:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "So, as I see it, the delta between OPAQUE-SIGMA-I and TLS 1.3+OPAQUE is the wire format, not much more. If, however, we drop the \"info\" and additional fields (extensions) from OPAQUE-SIGMA-I, then there is a substantial difference. I would be in favor of keeping OPAQUE-SIGMA-I if it dropped extensions, because otherwise it's essentially TLS 1.3 but with a different wire format, and I don't think that rises to the level needed to specify yet another AKE.",
          "createdAt": "2020-10-28T19:11:54Z",
          "updatedAt": "2020-10-28T19:11:54Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not convinced that the complexity of implementing SIGMA-I with the info fields is same as implementing TLS 1.3. It may be the case if you understand the cryptography and system issues of TLS 1.3 well enough to just use the minimal skeleton that serves you in SIGMA-I. But how many such (real) experts are out there? Once we already define the flows for 3DH and HKDF, having them for SIGMA is no big deal. I am not sure that eliminating the SIGMA specific elements makes a huge difference.\r\nAnd I am not sure that we will end defining a flavor of OPAQUE with TLS 1.3 that will use just the three handshake flows (as opposed to defining it with EA and 5 flows).",
          "createdAt": "2020-10-28T22:26:41Z",
          "updatedAt": "2020-10-28T22:26:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It may be the case if you understand the cryptography and system issues of TLS 1.3 well enough to just use the minimal skeleton that serves you in SIGMA-I. But how many such (real) experts are out there? \r\n\r\nThis is my key point: there are probably very few. I don't think it's wise for us to standardize something that the majority of folks may not understand when or how to use when the TLS 1.3 instantiation exists. Moreover, folks who think they can make an informed decision between the two and get it wrong will likely have a bad day. \r\n\r\n> It may be the case if you understand the cryptography and system issues of TLS 1.3 well enough to just use the minimal skeleton that serves you in SIGMA-I. But how many such (real) experts are out there? \r\n\r\nThat's a fair point! If the TLS WG decided to forgo all but the EA flow, then certainly there's a larger difference between SIGMA-I and TLS 1.3+OPAQUE. But if not, I think the delta between these two is small enough that it's not in the CFRG's (or IETF's) best interest to specify.",
          "createdAt": "2020-10-28T22:31:53Z",
          "updatedAt": "2020-10-28T22:33:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(Meta comment: perhaps we should also ask the list and see what they think?)",
          "createdAt": "2020-10-28T22:36:14Z",
          "updatedAt": "2020-10-28T22:36:28Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "It has to be understood that these AKEs are \"informational\"/illustrative, not intended as full specifications. Having the unspecified/optional info fields makes it very clear that we are not providing a full specification. \r\n\r\nI am ok with raising this in the list. ",
          "createdAt": "2020-10-28T22:42:08Z",
          "updatedAt": "2020-10-28T22:42:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It has to be understood that these AKEs are \"informational\"/illustrative, not intended as full specifications. Having the unspecified/optional info fields makes it very clear that we are not providing a full specification.\r\n\r\nAha, well, that's the source of this disagreement! I was approaching this as a complete specification, as that allows us to provide test vectors. If it's incomplete, I'm not sure how we provide test vectors. This definitely seems like something that list should weigh in on. I'll craft a message!",
          "createdAt": "2020-10-28T22:45:41Z",
          "updatedAt": "2020-10-28T22:45:41Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "You can produce test vectors that omit all optional fields. Or you can omit these optional fields from the specification as I just wrote in another thread and say in English that such elements may need to be transmitted by applications but we do not specify them as they will be application specific (we do say that they need to be included in the transcript).",
          "createdAt": "2020-10-28T23:10:12Z",
          "updatedAt": "2020-10-28T23:10:12Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "I saw the message on the list. I don't subscribe, so I'll comment here: a complete OPAQUE-3DH instantiation would be very helpful to me. BTW, the document is getting much easier for me to understand.",
          "createdAt": "2020-12-11T19:36:20Z",
          "updatedAt": "2020-12-11T19:36:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved, given #128 and #133. (SIGMA-I and HMQV will move to an appendix. We won't specify wire format specifics or provide test vectors, but we'll sketch how that could be done in future documents.)",
          "createdAt": "2021-02-03T00:38:54Z",
          "updatedAt": "2021-02-03T00:38:54Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWU3Mzc0NDI1MjI=",
      "title": "Use of VOPRF should mention which mode is used",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/79",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Presumably we want to use the VOPRF with modeBase set (as opposed to modeVerifiable). But I could not find this mentioned anywhere in the spec in its current state",
      "createdAt": "2020-11-06T04:12:30Z",
      "updatedAt": "2020-11-09T16:39:34Z",
      "closedAt": "2020-11-09T16:39:34Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, it's the base mode. Do you want to take this and send a PR?",
          "createdAt": "2020-11-06T20:31:46Z",
          "updatedAt": "2020-11-06T20:31:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #80. Closing.",
          "createdAt": "2020-11-09T16:39:34Z",
          "updatedAt": "2020-11-09T16:39:34Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWU3NDAzNjA3NDQ=",
      "title": "Add core OPAQUE protocol test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/82",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "These would omit the AKE integration pieces, since the wire format for that's still unclear.",
      "createdAt": "2020-11-11T00:49:17Z",
      "updatedAt": "2021-02-03T00:37:33Z",
      "closedAt": "2021-02-03T00:37:33Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, as we no longer distinguish the \"core\" from the actual AKE.",
          "createdAt": "2021-02-03T00:37:33Z",
          "updatedAt": "2021-02-03T00:37:33Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWU3NDMyNTE5NzE=",
      "title": "XOR-based encryption for Ke2 and Ke3 encryption keys in AKE?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/83",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From [the definition of Ke2 and Ke3](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1071-L1075), the encryption keys used to encrypt the optional Einfo parameters in the AKE section, it seems like the application would need to pick an encryption algorithm for OPAQUE to use here.\r\n\r\nCan we avoid this selection and simply use an XOR-based one-time pad for encryption here (is this secure)? Thus, instead of setting key_length to be a fixed constant, it would simply be the length of Einfo2 and Einfo3.",
      "createdAt": "2020-11-15T13:00:20Z",
      "updatedAt": "2020-12-21T16:46:59Z",
      "closedAt": "2020-12-21T16:46:58Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw ^",
          "createdAt": "2020-11-15T21:51:22Z",
          "updatedAt": "2020-11-15T21:51:22Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The encryption needs to be authenticated-encryption. One could make the point that because the transcript is mac-ed anyway (currently specified only for 3DH/HMQV), then IND-CPA encryption could be enough, hence also xor.  However, I am always wary of such indirect assurances, i.e., using one element in the protocol (the MAC in this case) for two different reasons. The concern is that in the future, one of the reasons may not be relevant any more (because of some other change in the protocol or its requirements) and people will forget it was needed for another reason. A  good example is SIGMA. We could define that the whole transcript not only is signed but also MACed. Then you could use xor for encryption. But since SIGMA does not really need MACing the transcript then eventually the protocol could be simplified by only MACing the identity forgetting that the MAC also server to implement authenticated encryption. And given that GCM is so widespread now, it would be simpler to specify the encryption as GCM.\r\nImportant: Do you want to have a full specification for one of these protocols, say 3DH, at the level of allowing interoperable implementations? In that case we really need to make some choices for instantiating these functions.",
          "createdAt": "2020-11-16T20:30:26Z",
          "updatedAt": "2020-11-16T20:30:26Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the points. I think the only worry I have with specifying the encryption in this manner is that it brings additional complexity into the protocol, despite not being required for the core OPAQUE functionality. But overall I am supportive of it.\r\n\r\nI'm interested to hear what @chris-wood has to say on doing a full spec for one of the AKE protocols.",
          "createdAt": "2020-11-16T20:59:20Z",
          "updatedAt": "2020-11-16T20:59:20Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I was thinking about this and we do need to have a **simple**, full instantiation of OPAQUE to be used for interoperability testing but also for whoever wants a simple aPAKE with the benefits of OPAQUE. I assume that the modularity of design and specification has some important benefits (e.g., making it easier to integrate with existing AKE protocols such as TLS or IKE) but it may also obscure the simplicity of OPAQUE (e.g, when implemented with 3DH).  We should not let people conclude, erroneously,  that OPAQUE is too complex.",
          "createdAt": "2020-11-18T22:16:17Z",
          "updatedAt": "2020-11-18T22:16:17Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Is your conclusion that we could still opt for a simple XOR-based encryption scheme here (since the transcript is already mac-ed), and that we could leave a clear note in the specification stating why XOR-based encryption is OK and what would need to change if the transcript were no longer to be mac-ed?",
          "createdAt": "2020-11-18T23:14:15Z",
          "updatedAt": "2020-11-18T23:14:15Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. That works. I am not sure what would be considered simpler by implementers: encryption implemented by XOR-ing with a bit stream output by HKDF or a call to GCM with a key output by HKDF. Your call, guys.",
          "createdAt": "2020-11-19T02:59:47Z",
          "updatedAt": "2020-11-19T02:59:47Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ^",
          "createdAt": "2020-11-23T03:03:26Z",
          "updatedAt": "2020-11-23T03:03:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's probably easiest to stick with normal AEADs for AKE encryption, though note that this really depends on #77 (or more generally AKE specificity). For example, if we go with the \"this document just specifies templates for *actual* AKEs,\" then any future document describing a *specific* AKE with its wire format would deal with this encryption. But if we decide to specify a *specific* AKE in this document, then we'd have to deal with it.\r\n\r\nI lean towards being specific in this document, rather than punting to implementers and future document authors. (It seems wrong to deliver a partially baked protocol in the standard.)",
          "createdAt": "2020-11-24T01:48:39Z",
          "updatedAt": "2020-11-24T01:48:39Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we are in agreement to have one full specification that includes the AKE part. Now we \"just\" need to agree on the details and choices, including which of the three AKEs in the document - HMQV is the most efficient but it is out for IP reasons :-(",
          "createdAt": "2020-11-24T18:52:21Z",
          "updatedAt": "2020-11-24T18:52:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "My vote would be 3DH. This would allow us to then sketch HMQV and SIGMA-I variants (sort of as we do now). ",
          "createdAt": "2020-11-25T14:34:59Z",
          "updatedAt": "2020-11-25T14:34:59Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me.",
          "createdAt": "2020-11-25T20:24:29Z",
          "updatedAt": "2020-11-25T20:24:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing to track a complete 3DH instantiation in #77.",
          "createdAt": "2020-12-21T16:46:58Z",
          "updatedAt": "2020-12-21T16:46:58Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWU3NDM5MjA4NzQ=",
      "title": "note regarding omitting skU from envelope and deriving it from rwd instead",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/84",
      "state": "OPEN",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in the source there's a commented out part `## Envelope considerations` which mentions that not even `skU` needs to be included in the credentials wrapped in the envelope, instead skU can be derived from `rwd`. there's a note that this part should be \"brought back after updating\". if this is indeed the case, do not forget to change \r\n> Applications MUST include skU in secret_credentials\r\nin the {#protocol-messages} section.",
      "createdAt": "2020-11-16T15:18:02Z",
      "updatedAt": "2021-02-07T23:18:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, we need to remove that commented out text. I'll file a PR for that.",
          "createdAt": "2020-11-16T20:22:20Z",
          "updatedAt": "2020-11-16T20:22:20Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "why do you want to remove it instead of bringing it back? i think this part makes sense.",
          "createdAt": "2020-11-16T21:27:23Z",
          "updatedAt": "2020-11-16T21:27:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> i think this part makes sense.\r\n\r\nI need to think about this more, though my sense is that the bandwidth saved is not worth the additional complexity. The original I-D had this to say about the issue:\r\n\r\n```\r\n   Note (storage/communication efficient EnvU): It is possible to\r\n   shorten EnvU by including PubS in ClrEnv and omitting SecEnv and any\r\n   other value from EnvU.  In this case, the user's key PrivU is derived\r\n   from RwdU; e.g., the value PAD in KEYS is used as a seed for a key\r\n   generation procedure that outputs PrivU (the length of PAD will\r\n   depend on the specific key generation procedure).  Such EnvU consists\r\n   of Nonce, PubS and the HMAC value, resulting in less storage at the\r\n   server and less communication from server to client.  The server can\r\n   further minimize storage space by deriving per-user OPRF keys kU from\r\n   a single global secret key using a PRF, and it can use the same pair\r\n   (PrivS,PubS) for all its users.  In this case, the per-user OPAQUE\r\n   storage consists of Nonce, PubU and HMAC(Khmac; PubS).  While it may\r\n   be \"tempting\" to omit Nonce for space savings, this can lead to\r\n   vulnerabilities (see below).\r\n```\r\n\r\n@hugokraw, what do you think?",
          "createdAt": "2020-12-02T02:22:22Z",
          "updatedAt": "2020-12-03T05:07:14Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am sure that there are cases where such a savings will be meaningful and I am sure it will not be the typical case; I can't say much more than that. Frankly, the main reason I wanted to \"document\" this option is that in Bjorn Hasse's AuCPace paper, the amount of storage and/or communication was the only aspect on which AuCPace had some performance advantage. That paper compared against a very wasteful interpretation of what OPAQUE needed and I wanted to document the fact that one can actually be very minimal in envelope's size. I would prefer to make progress with the specification without entering this level of optimization but if there are potential users of OPAQUE for which these savings are important we could at least leave it as a remark. ",
          "createdAt": "2020-12-03T04:47:30Z",
          "updatedAt": "2020-12-03T04:47:30Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there a systematic / standardized way to generate a private key from a sequence of random bytes (RwdU), for all of the keypair types that we want to support?\r\n\r\nIf so, then I think it would be great to incorporate this optimization into our specification, especially since this will affect how test vectors are generated.\r\n\r\nIf not, then I think we are better off not addressing this optimization, unless there are compelling reasons for practictioners to minimize the extra 32 bytes that are being used for encoding skU.",
          "createdAt": "2020-12-04T01:09:01Z",
          "updatedAt": "2020-12-04T01:09:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is there a systematic / standardized way to generate a private key from a sequence of random bytes (RwdU), for all of the keypair types that we want to support?\r\n\r\nIt depends on the key pair. HPKE [defines specifies a couple derivation functions](https://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#name-derivekeypair) for popular groups. But this isn't exhaustive. Right now, I'm leaning towards not including this optimization, but perhaps this is also something we should bring up to the list. ",
          "createdAt": "2020-12-04T01:15:21Z",
          "updatedAt": "2020-12-04T01:15:21Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is there a systematic / standardized way to generate a private key from a sequence of random bytes (RwdU), for all of the keypair types that we want to support?\r\n\r\nThe universal way is to assume that the key generation procedure works on a string of random bits as input and therefore you can always produce that number of bits out of the RO applied to rwdU. This is simple for the case of EC keys but would not be so simple for an RSA private key (which requires sampling prime numbers).",
          "createdAt": "2020-12-05T18:07:22Z",
          "updatedAt": "2020-12-05T18:07:22Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Hello,\r\n\r\ncan't rwdu be used as input to h2c's HashToScalar and serve as a private key? (This is how I understood OPAQUE the first time I read about it - as an alternative to a secret key used for the envelope)",
          "createdAt": "2020-12-06T01:26:05Z",
          "updatedAt": "2020-12-06T12:45:21Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "With the latest advancements here, I'd like to bring this back up.\r\n\r\nConsideration to support RSA in the Sigma setup (or anything other that hasn't defined a secure deterministic key pair generation) made this a blocker.\r\n\r\nSince the 'main' AKE now is 3DH and that the group used for 3DH[ is set to be the same as the one used in the OPRF](https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/104#issuecomment-772114793), we can leverage hashing _rwdu_ to the field for the secret key (e.g. hash-to-scalar() in hash-to-curve terminology). This would nicely lower the complexity and size of the envelope construction.\r\n\r\nI'm thinking about something like this:\r\nRegistration:\r\n```\r\nClient:\r\n1. N = Unblind(blind, response.data)\r\n2. y = Finalize(pwdU, N, \"OPAQUEXX\")\r\n3. nonce = random(32)\r\n4. rwdU = HKDF-Extract(nonce, Harden(y, params))\r\n5. sku, pku = DeriveKeysFromSeed( rwdu )\r\r\n6. authKey = HKDF-Expand( rwdu, \"AuthKey\")\r\n7. authTag = Hmac ( authkey, nonce || pku || pks )\r\n8. envU = envelope(nonce, authTag)\r\n\r\nC -> S : pku, envU\r\n```\r\n\r\nThe envelope does not contain encrypted secret material anymore.\r\n\r\nThen during authentication:\r\n```\r\nC -> S : oprf request, AKE request\r\nS -> C : oprf response, AKE response, pks, envU\r\n```\r\n\r\nThe client then does the same steps as during registration and checks the tag. Upon successful verification, uses sku, pku, and pks to proceed with the AKE.\n\nThis works for AKEs accepting a `DeriveKeysFromSeed` function, which derives a key pair from a seed.\nIn the case of 3DH over the groups supported in OPRF, this would be the hash-to-curve `HashToScalar()` function (+ a DST).\n\nThe envelope would be reduced to this\n```\nenvelope {\n    nonce\n    authTag\n}\n```",
          "createdAt": "2021-02-03T19:45:24Z",
          "updatedAt": "2021-02-07T23:18:01Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "i understand that this would be a 3rd kind of envelope config, besides base and custom-identifier. but i'm still very much in favor of this.",
          "createdAt": "2021-02-03T22:03:24Z",
          "updatedAt": "2021-02-03T22:03:24Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "MDU6SXNzdWU3NDM5MjY0NzY=",
      "title": "protocol messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/85",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in the specification there is a part which defines `{#protocol-messages}`:\r\n```\r\nenum {\r\n    registration_request(1),\r\n    registration_response(2),\r\n    registration_upload(3),\r\n    credential_request(4),\r\n    credential_response(5),\r\n    (255)\r\n} ProtocolMessageType;\r\n\r\nstruct {\r\n    ProtocolMessageType msg_type;    /* protocol message type */\r\n    uint24 length;                   /* remaining bytes in message */\r\n    select (ProtocolMessage.msg_type) {\r\n        case registration_request: RegistrationRequest;\r\n        case registration_response: RegistrationResponse;\r\n        case registration_upload: RegistrationUpload;\r\n        case credential_request: CredentialRequest;\r\n        case credential_response: CredentialResponse;\r\n    };\r\n} ProtocolMessage;\r\n```\r\nin our implementation at https://github.com/stef/libopaque we omitted implementing this, for the following reasons:\r\n  * this is depending on how an application is using this protocol,  it might not be necessary to wrap protocol messages in such frames, for example because the app already has it's own framing, or different ways to communicate this.\r\n  * parsing any kind of input from possible adversaries should be done higher up the stack, where possibilities are richer to do so in memory safe ways or by implementing language security mechanisms to do so.\r\n\r\nlibopaque does however implement the credential and envelope structures.",
      "createdAt": "2020-11-16T15:24:55Z",
      "updatedAt": "2020-11-16T20:31:55Z",
      "closedAt": "2020-11-16T20:31:55Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, as you point out, this isn't strictly necessary to implement OPAQUE, so we ought to remove it from the spec. @kevinlewi, objections?",
          "createdAt": "2020-11-16T20:16:39Z",
          "updatedAt": "2020-11-16T20:16:52Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am all for removing this!",
          "createdAt": "2020-11-16T20:17:29Z",
          "updatedAt": "2020-11-16T20:17:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Great! See #86 for the change.",
          "createdAt": "2020-11-16T20:26:35Z",
          "updatedAt": "2020-11-16T20:26:35Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWU3NDgwNDc4ODI=",
      "title": "credential_lists in CreateRegistrationResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/87",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in this section https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#registration-messages\r\n\r\n```\r\nstruct {\r\n    opaque data<0..2^16-1>;\r\n    opaque pkS<0..2^16-1>;\r\n    CredentialType secret_types<1..255>;\r\n    CredentialType cleartext_types<0..255>;\r\n} RegistrationResponse;\r\n```\r\nSpecifies\r\n\r\n> - secret_credentials_list, a list of CredentialType values clients should include in the secret_credentials list of their Credentials structure\r\n> - cleartext_credentials_list, a list of CredentialType values clients should include in the cleartext_credentials list of their Credentials structure\r\n\r\nwhat if a CredentialType is in both of these lists? Why not pack this information in 10 bits, where each CredentialType has 2 bits for signalling:\r\n```c\r\n  NotPackaged = 0,  // field is not packaged in envelope\r\n  InSecEnv = 1,        // field is encrypted\r\n  InClrEnv = 2          // field is plaintext, but authenticated\r\n```",
      "createdAt": "2020-11-21T16:07:33Z",
      "updatedAt": "2021-01-08T00:43:17Z",
      "closedAt": "2021-01-08T00:43:17Z",
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "depending on #84 being removed or reinstated, its also interesting what happens if `skU` is included in clearttext_types. especially if #84 removes the commented out section it also means that the whole information with 2bits per CredentialType would even fit into only one byte, assuming that `skU` is mandatory to be included in secret_types\r\n  ",
          "createdAt": "2020-11-21T16:29:41Z",
          "updatedAt": "2020-11-21T16:29:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> what if a CredentialType is in both of these lists\r\n\r\nA credential should only be in one or the other. (We should add text saying that doing otherwise is a protocol violation. I certainly don't see a reason for it, at least.) We can address #84 separately.",
          "createdAt": "2020-11-24T01:43:29Z",
          "updatedAt": "2020-11-24T01:43:29Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "No longer relevant (and so this issue can be closed) since credentials list is not a thing anymore (after #102)",
          "createdAt": "2021-01-08T00:43:17Z",
          "updatedAt": "2021-01-08T00:43:17Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU3NDgwNDk5NTc=",
      "title": "id missing in CredentialRequest",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/88",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in the section https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#authenticated-key-exchange-messages CredentialRequest is defined as:\r\n\r\n```\r\nstruct {\r\n    opaque data<1..2^16-1>;\r\n} CredentialRequest;\r\n```\r\nand right below that is this line:\r\n> data : An encoded element in the OPRF group. See {{I-D.irtf-cfrg-voprf}} for a description of this encoding.\r\nand in the https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#createcredentialresponserequest section it is even referred to as:\r\n```\r\n1. (kU, envU, pkU) = LookupUserRecord(request.id)\r\n```\r\n\r\neven though trivial, it might make sense to include id in the CredentialRequest structure definition.",
      "createdAt": "2020-11-21T16:17:43Z",
      "updatedAt": "2020-12-02T03:15:07Z",
      "closedAt": "2020-12-02T03:15:07Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See #65 for the prior discussion on the removal of the id parameter from CredentialRequest.\r\n\r\nMy interpretation of the `LookupUserRecord(request.id)` portion is that it is meant for the wrapper protocol to perform the lookup, so that those details are not kept as part of the OPAQUE protocol.\r\n\r\n@chris-wood Thoughts on this / perhaps editing the text to make it more clear that OPAQUE doesn't handle lookup and doesn't manage the id in its CredentialRequest message?",
          "createdAt": "2020-11-23T03:06:33Z",
          "updatedAt": "2020-11-23T03:06:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That referenced line in the text is a bug (it should have been removed). I'm definitely supportive of clarifying the text to make it clear that identity selection and transfer between client and server is not part of OPAQUE's job. @kevinlewi, will you have time to make a PR for this?",
          "createdAt": "2020-11-24T01:41:25Z",
          "updatedAt": "2020-11-24T01:41:25Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "MDU6SXNzdWU3NDgxMDk1Mzg=",
      "title": "rename StoreUserRecord to indicating the finalization instead of optional persistence",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/89",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Just as we dropped the ProtocolMessages part, for the protocol it might be not necessary to call the function StoreUserRecord. For instance my implementation does not care about any kind of persistence or transport of the outcome of the protocol. It might be that the use-case does not need the storage of the user record, for example by just keeping it in memory, or the record might be further processed before storage. Thus i propose to rename the function to `FinalizeUserRecord` instead.",
      "createdAt": "2020-11-21T21:50:54Z",
      "updatedAt": "2021-01-14T01:57:47Z",
      "closedAt": "2021-01-13T22:39:41Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good suggestion! Like the wrapping protocol message frames, this also isn't strictly necessary. I'll take a stab at removing this text.",
          "createdAt": "2020-11-24T01:44:08Z",
          "updatedAt": "2020-11-24T01:44:08Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "well actually the function itself is kind of necessary. it adds at least the OPRF key to the record, but possibly also a per-user skS. the result is a record to be stored or persisted or whatever. the point is, that it is not really about storage of the record, but about adding the server secrets to it, that are user-specific.",
          "createdAt": "2020-11-24T02:11:51Z",
          "updatedAt": "2020-11-24T02:11:51Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Somewhat unrelated question, but:\r\n\r\nShould this specification define a format for the serialized version of the \"finalized object\" containing (envU, pkS, skS, pkU, kU)? Something like:\r\n```\r\nCredentialRecord {\r\n  opaque envU<1..2^16-1>;\r\n  opaque kU<1..2^16-1>;\r\n  opaque pkU<1..2^16-1>;\r\n}\r\n```\r\n\r\nAnd actually pkS does not need to be stored here, because it is already a part of the credentials object, via:\r\n\r\n\"Applications MUST include skU in secret_credentials and pkS in either cleartext_credentials or secret_credentials.\"\r\n\r\nAnd we likely do not want to advocate for storing skS somewhere like this, so we can retain/amend the comment:\r\n\r\n\"If skS and pkS are used for multiple users, the server can store these values separately and omit them from the user's record.\"",
          "createdAt": "2020-12-02T02:23:10Z",
          "updatedAt": "2020-12-02T02:23:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Great question, @kevinlewi. Over in HPKE we chose to not specify storage wire formats, since they were primarily an implementation detail. That came back to haunt us when we needed to send serialized HPKE contexts between processes. So my sense is that this might be useful if we anticipate a use case where we would need to move these records around between different OPAQUE implementations. Otherwise, I think we ought to leave it to the wrapper protocol and application. ",
          "createdAt": "2020-12-02T03:14:32Z",
          "updatedAt": "2020-12-02T03:14:32Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it would be something that OPAQUE implementations would have to implement, and not leave to their wrapper protocols, since: what is a wrapper protocol expected to do with envU, kU, pkU other than treat them as raw bytestrings that should be serialized in some format?\r\n\r\nSo, if it's likely the case that OPAQUE protocols will be implementing the serialization in their own manner, I think it would be nice if we define a standard way to organize envU, kU, pkU. But this does raise other questions... should we include a version byte in this serialization?",
          "createdAt": "2020-12-03T03:52:57Z",
          "updatedAt": "2020-12-03T03:53:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> what is a wrapper protocol expected to do with envU, kU, pkU other than treat them as raw bytestrings that should be serialized in some format?\r\n\r\nIf these were serialized and minted by implementation A, then implementation A would presumably know how to parse them. I think this is useful only if, for example, implementation A mints the records and implementation B consumes them. I could see that happening in practice if, e.g., the registration and login phases were two separate processes running different implementations, wherein the registration process minted CredentialRecords and then the login process consumed them. If you think arrangements like this are likely, I see no harm in adding something like CredentialRecord.\r\n\r\nAs for serialization: yes, we should definitely version them. I'd just stick in the same version used for the protocol version, e.g.:\r\n\r\n~~~\r\nstruct {\r\n   uint16 version;\r\n   uint16 length;\r\n   select (0xff00) { // version 00 for the draft, or whatever\r\n      // information about the configuration, e.g., OPRF suite and so on, since that determines kU's encoding \r\n      Envelope envU;\r\n      Scalar kU;\r\n      opaque pkU<0..2^16-1>;\r\n   }\r\n} CredentialRecord;\r\n~~~",
          "createdAt": "2020-12-03T04:05:17Z",
          "updatedAt": "2020-12-03T04:05:28Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Good points, I see. Yes, I think this scenario could be likely, since registration and login may need to be in different languages (for example).\r\n\r\nThe struct looks good, except -- why do we need a `uint16 length;` field? Seemingly that could be omitted.",
          "createdAt": "2020-12-03T04:18:13Z",
          "updatedAt": "2020-12-03T04:18:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The struct looks good, except -- why do we need a uint16 length; field? Seemingly that could be omitted.\r\n\r\nImagine one added support for two versions of OPAQUE at the same time, yet the login only knows how to process one specific version. Since the contents of the record depend on the version, there needs to be a way for implementations that don't support a given version to skip over records they cannot parse, and the length field does just that. So for example, an implementation would read the version field and, if it's unsupported, skip `length` bytes to the next record in a list, and repeat. ",
          "createdAt": "2020-12-03T04:21:27Z",
          "updatedAt": "2020-12-03T04:21:27Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "This would only be a problem if the wrapper protocol stores these records in a contiguous sequence of bytes with no delimiters for the beginnings of each record, though, right?\r\n\r\nI don't imagine that this would ever occur... but perhaps I'm missing something. At the very least, these records would be stored as values of a map, or elements of an array.",
          "createdAt": "2020-12-03T04:46:12Z",
          "updatedAt": "2020-12-03T04:46:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, that's true! If a wrapper chose to store these in a map from idU -> [records], then perhaps this would be relevant. If it has some other (simpler) way to delineate different records, we can certainly omit the length. \r\n\r\n@kevinlewi, would you mind proposing a PR for the record format?",
          "createdAt": "2020-12-03T05:09:19Z",
          "updatedAt": "2020-12-03T05:09:19Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "i don't know how the hpke storage formats came to haunt you guys, but i would say that since we do not specify protocol message formats, storage formats also do not need to be specified, or if they do, they might be specified in a different rfc, together with wire formats. the question for me, is is this about the cryptographic protocol or the communication/application protocol, and for me, i prefer to stick to the cryptographic protocol only. since the communication/application protocol brings along a lot of stuff as an low level implementer would not like to implement.\r\n\r\ni am also worried about \"variable length\" records, that means complexity, i believe the implementation should know exactly how big a record or any protocol message is, without encoding it in the message. implementing parsing of these things means added complexity, and added complexity means attack surface. it is already worrying that `idU` and `idS` might be free-form strings with random lengths - i would really prefer allowing only uuids/hashes or similar fixed-width strings, that would eliminate variable lengths parsing from fixed configuration setups of opaque.",
          "createdAt": "2020-12-08T17:17:16Z",
          "updatedAt": "2020-12-08T17:17:44Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @stef, thanks for the comments on this, I think you bring up good points.\r\n\r\nI agree that we should stick to only specifying the cryptographic protocol. But, to clarify, aren't we already specifying message / wire formats (e.g. the bytes that consist of a RegistrationRequest) in this RFC? I see this as still being part of the cryptographic protocol. The reason being that we want a wrapper protocol to be able to not have to worry about the internals of the OPAQUE implementation, and if we did not specify the message / wire formats, then it must mean that the wrapper protocol would have to be exposed to the specifics behind kU, rwdU, etc. (which in my opinion is undesirable).\r\n\r\nA similar argument I think can be made for why we may want to specify storage formats for the password file. If we do not, then doesn't this mean that the OPAQUE protocol must expose to the wrapper protocol the individual components that make up the password file (pkU, envU, kU), and we would leave it up to the wrapper protocol to decide what to do with these objects? In my opinion, it would feel cleaner to have the OPAQUE protocol dictate how these objects would be serialized together, so that the wrapper protocol need not have to interpret what each of pkU, envU, and kU mean.\r\n\r\n> i am also worried about \"variable length\" records, that means complexity, i believe the implementation should know exactly how big a record or any protocol message is, without encoding it in the message. implementing parsing of these things means added complexity, and added complexity means attack surface.\r\n\r\nI agree with this -- I think one way in which we might hope to simplify things would be to consider the suggestions I made in #99 regarding the simplification of the envelope construction. However, this would still mean that we have a \"custom identifier\" mode, which does not solve the problem of the variable-length `idU` and `idS`. Perhaps we can draft a separate issue to talk specifically about whether or not would be a good idea to enforce fixed-width strings for `idU` and `idS`.",
          "createdAt": "2020-12-10T10:54:11Z",
          "updatedAt": "2020-12-10T10:54:11Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "xposting this here what i commented on the merged change:\r\n\r\n> i'm not sure this is a good idea, different use-cases might not need all the bells and whistles. i think i asked in an issue if this is about the standardization of the protocol or it goes beyond that and standardizes also serialization of all kind of wire and storage elements. in implementations using only one instantiation of the protocol the parameters are fixed, and don't need to be stored. if an implementation does not follow the spec and does not store this redundant info in that case, will it still be standards compliant? also some implementations might want to go beyond the currently specified two envelope setups and may want to make all credential extensions configurable, i can see reasons for all configurations. i think there should be a limit of what is part of the standard, and what is free for implementations to decide themselves, and again depending on different configurations of how credential extensions are created this can lead to very different storage formats. my take is to not specify neither the storage format of the record, nor actually the configuration of the envelope. test vectors can still be provided for the protocol, especially if serialization is not fixed, in that case the test vectors can be provided as results of the various steps of the protocol, there is no combinatoric explosion.",
          "createdAt": "2021-01-14T01:57:46Z",
          "updatedAt": "2021-01-14T01:57:46Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWU3NDkyOTgxMDU=",
      "title": "Proposal: Completely remove all mention of idU and idS for the sake of simplicity",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/90",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'd like to open a discussion on the following proposal: to **completely remove all mention of idU and idS** from the OPAQUE spec (aside from places where we can refer to it as guidance for an implementor of a wrapper protocol that calls OPAQUE). To be clear, this change would mean that we set idU = pkU and idS = pkS in all locations where idU and idS appear in the current draft (not to completely remove their inclusion from the draft).\r\n\r\n(Note: Past discussion on this issue occurred in #74, spawned from the question of \"Can we simply set idU = static pkU and idS = static pkS?\". This will be a continuation of some of the discussion in that issue.)\r\n\r\nThe current state of the draft suggests that we involve idU and idS in the following places:\r\n1) [As potential parameters which can be supplied to the envelope](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L414-L415) as either secret or cleartext credentials\r\n2) If they are specified in the envelope, then [they must be input as parameters to the AKE login](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1064-L1066) (by at least the server). If they were not specified in the envelope, then pkU and pkS are used in their place. They are then used to affect the [AKE key derivation](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1113-L1114).\r\n3) In the past there have also been discussions around potentially incorporating idU as part of the initial input to the OPRF: namely, instead of doing OPRF(key, password), do something like OPRF(key, HKDF(password, idU)).\r\n\r\n## Proposal\r\n\r\nDefer all mention of idU and idS to the wrapper protocol that calls OPAQUE, do not allow them to be specified in the envelope, and use pkU and pkS in their place within the AKE section.\r\n\r\nFor wrapper protocols that wish to supply an idU and idS which should be protected by the security guarantees of the OPRF, **we should instead recommend these wrapper protocols to take advantage of the [export_key parameter](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L651)** to do custom encryption/authentication for the bindings between idU/pkU and idS/pkS.\r\n\r\n### Pros\r\n\r\n- When we ultimately provide test vectors for OPAQUE, it will of course be simpler to not have to include idU and idS as parameters to the test vector generation.\r\n- Also, the above logic where the server must remember how the envelope was constructed in order to figure out how to set idU and idS is something that I suspect will trip up implementors. At the very least, we would need to produce test vectors which specifically test for these kinds of edge cases (what happens if idU and idS are specified in the envelope, and the server mis-specifies them in AKE, or what if they were not specified in the envelope, but the server tries to specify them, etc.).\r\n\r\nThe advantage to this proposal is that we can remove all of this complexity and potential for errors from the implementation side. The result is that OPAQUE no longer references any application-specific idU and idS parameters, which to me feels much cleaner than our current state where there are many conditionals and optional parameters to check (a nightmare for generating test vectors and verifying that an implementation can support all possible settings bug-free).\r\n\r\n### Cons\r\n\r\nThe main worry for removing idU and idS is the potential for a loss of generality (what if a wrapper protocol wants to tie idU and idS into the OPRF/AKE security guarantees?). I propose that we recommend wrapper protocols to use export_key for this purpose, so the details of idU and idS can remain outside of the OPAQUE protocol. There is still a cost here, because previously we used HKDF(RwdU, ...) to encrypt idU and idS, whereas now they would be using export_key, which would amount to an extra HKDF computation or two. But I think this price is totally worth the simplicity that it brings the OPAQUE protocol, especially since this is a client-side operation, and we are already recommending clients to compute a memory-hard hash function which will be way more expensive.\r\n\r\nAnd finally, to address (3), we should recommend wrapper protocols to pre-hash idU and the password before starting the OPAQUE protocol, again so that we can avoid incorporating the idU parameter within the OPAQUE protocol.\r\n\r\ncc: @hugokraw , @chris-wood ",
      "createdAt": "2020-11-24T02:59:07Z",
      "updatedAt": "2020-11-30T20:51:52Z",
      "closedAt": "2020-11-30T20:51:51Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I strongly oppose this for several reasons. Here are some:  \r\n\r\n> The result is that OPAQUE no longer references any application-specific idU and idS parameters\r\n\r\nOPAQUE is an authenticated key exchange protocol and there is no meaning to authentication without identities. Who you are exchanging a key with is not less important than the secrecy and randomness of the key. As such, OPAQUE must have idU and idS as essential elements, and indeed you cannot derive a key without them. So the only question is who determines these identities and how they are communicated in the protocol. We simplified the treatment by setting defaults (pkU and pkS) and providing a native mechanism to change this in an *authenticated* way if so desired.  If you eliminate the use of the envelope for this transmission of identities you need to either say \"sorry, you can only use pkU and pkS as identities\" (which is too restrictive) or create yet another mechanism for this authenticated transmission. I find this more complex and prone to error than including the id's in the envelope. In particular, the export key is intended for extensions to OPAQUE, not to serve a prime functionality as authenticating identities.  \r\n\r\n> the server must remember how the envelope was constructed\r\n\r\nThe server is the one to set these mechanisms at registration and there is no reason it forgets them. Moreover, the server stores the identities and it never needs to look at the envelope (except as a space optimization in case the identities contained in the envelope are not encrypted).  \r\n\r\n> we should recommend wrapper protocols to pre-hash idU and the password before starting the OPAQUE protocol, again so that we can avoid incorporating the idU parameter within the OPAQUE protocol.\r\n\r\nI would not remove idU from the AKE key derivation even if you included it under the OPRF. It is important to keep the modular composition of OPRF and AKE where each part delivers what is expected from such component. Also, one has to be careful (actually we may want to have a note on this) to avoid any replacement or instantiation of a user's identity with something like H(uid, password). If someone thinks of this as an identity then it is likely to think it does not require secrecy. Of course, if you publish H(id, password) you broke aPAKE completely as you can do an offline attack on the password just given idU.",
          "createdAt": "2020-11-25T21:18:05Z",
          "updatedAt": "2020-11-25T21:18:05Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Hugo, in reading your response, I realize that my original proposal might have been slightly unclear -- I am not advocating for removing idU and idS, but instead advocating for fixing idU = pkU, idS = pkS, and **not allowing** for the wrapper protocol to set idU and idS to anything else. (I will edit the original text to clarify this.) In other words, I am proposing to say:\r\n\r\n>  \"sorry, you can only use pkU and pkS as identities\" (which is too restrictive)\r\n\r\nCan you elaborate a bit more on why this is too restrictive, and why export_key cannot be used in the manner I suggested?\r\n\r\n> In particular, the export key is intended for extensions to OPAQUE, not to serve a prime functionality as authenticating identities.\r\n\r\nI see the use of export_key in my proposal not as authenticating identities, but simply allowing for a binding between the wrapper protocol's understanding of idU, and pkU.\r\n\r\n---\r\n\r\nBy the way, I want to place emphasis on the **simplicity** that I am aiming for with this proposal. I agree that by not allowing for custom idU and idS, we are making it more difficult for a wrapper protocol to get the security benefits of using custom idU and idS. I just want us to be cognizant of the costs that come with the increased complexity of supporting a custom idU and idS. If we come to an agreement that this increased complexity is worth the support for the feature, then we should definitely support it.\r\n\r\nOne way that I see the complexity being increased by supporting custom idU and idS here is the following. Let's say we come across an OPAQUE implementation in the wild. How difficult is it to check whether or not it complies with this specification? How many edge cases does one need to verify with the OPAQUE implementation (adding custom idU, putting idU in the envelope but not reusing it in the AKE section, etc.) in order for the community to be able to confidently say that it is in compliance? At the very least, we would need to provide a set of test vectors which test each edge case. I'd like for us to keep in mind that we do not want the complexity of correctness verification to be too large. Otherwise, we may end up in a situation where we produce a complete specification, but implementations frequently have bugs.",
          "createdAt": "2020-11-25T21:38:39Z",
          "updatedAt": "2020-11-25T22:01:01Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I appreciate any simplification but not enough in this case to \"outsource\" the management of identities outside the protocol. The identities need to be communicated in an authenticated way and I prefer not to trust wrappers or random implementers to take good care of it. Is the complexity we are talking about coming from letting wrappers choose identities that are neither pkU, pkS or those included in the envelope?  Would it be ok if we limit implementations to reduce flexibility of choosing identities to the following line:\r\nIf Envelope.Ids != null  set  IdU=envelope.idU, idS=envelope.idS else set  idU=pkU, idS=pkS\r\nand everywhere else use idU and idS as set in this line?\r\nWould that still leave corner cases?\r\n",
          "createdAt": "2020-11-25T22:54:01Z",
          "updatedAt": "2020-11-25T22:54:01Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is the complexity we are talking about coming from letting wrappers choose identities that are neither pkU, pkS or those included in the envelope?\r\n\r\nNo, I believe that we are already disallowing for this to occur. The identities must be set in the envelope, or if not set, then default to pkU and pkS. So, this is not where the extra complexity would be coming from.\r\n\r\nAfter some more thought on this + your suggestions, @hugokraw, I think I can reduce my concerns down to the following:\r\n1) There is a lot of flexibility in how the envelope is configured. What if the server says that the envelope contains an idU but no idS, or vice versa? We would need to produce test vectors for each possible setting and check that the appropriate behavior occurs in the AKE section, which is quite cumbersome.\r\n2) Setting idU and idS to be the empty string in the envelope is very different from not setting idU and idS in the envelope. I'm worried that implementations will get this wrong, since often the empty string is syntactically similar to \"not being set\", and so we may need to add test vectors to address this as well.\r\n\r\nEssentially both of these issues can be boiled down to reducing the complexity of setting the structure of the envelope. One solution I can think of for addressing this potential ambiguity is to take note from the VOPRF RFC and perhaps define \"modes\" for the envelope, either a \"base mode\" which does not set idU and idS, and a \"custom identifier mode\" which requires idU and idS to be set in the envelope.\r\n\r\nI have some other concerns about the customizability of the envelope, which I plan to create an issue about to address all at once. So I will close out this issue and instead defer further discussion of the above two points to a new issue about simplifying the complexity of the envelope itself.\r\n\r\nThanks for the fruitful discussions -- hope this makes sense!",
          "createdAt": "2020-11-30T20:51:51Z",
          "updatedAt": "2020-11-30T20:51:51Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWU3NTE4Mzg3MTE=",
      "title": "Update to the new VOPRF draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/91",
      "state": "CLOSED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-26T21:44:13Z",
      "updatedAt": "2020-12-01T22:21:45Z",
      "closedAt": "2020-12-01T22:21:45Z",
      "comments": []
    },
    {
      "number": 94,
      "id": "MDU6SXNzdWU3NTU3ODkzNjE=",
      "title": "Remove RequestMetadata type",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/94",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This struct stores the scalar across Request/Finalize calls, which both happen on the client. There's no need to serialize or send this value on the wire anywhere, so we should just defer its representation to the underlying implementation. Given that the OPRF API is already a dependency we expose, I suggest we replace RequestMetadata with the actual type `Scalar`. \r\n\r\nWhile we're in here, we might also consider removing superfluous wrappers around OPRF types (like `RegistrationRequest` and `CredentialRequest`). \r\n\r\n@kevinlewi, what do you think?",
      "createdAt": "2020-12-03T03:42:32Z",
      "updatedAt": "2020-12-03T04:14:20Z",
      "closedAt": "2020-12-03T04:14:20Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me. Just to be clear, none of the changes that you are referencing will actually affect the bytes being output by these functions, right? They are just syntactic changes to clean up the presentation if I am understanding correctly.",
          "createdAt": "2020-12-03T03:48:43Z",
          "updatedAt": "2020-12-03T03:48:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, partly. RequestMetadata contains a vector encoding of a scalar (so a serialized scalar prefixed by its length), but that's not really needed. What I'm suggesting is that we just output a scalar, e.g.:\r\n\r\n```\r\nCreateCredentialRequest(pwdU)\r\n\r\nInput:\r\n- pwdU, an opaque byte string containing the user's password\r\n\r\nOutput:\r\n- request, an CredentialRequest structure\r\n- r, an OPRF Scalar value\r\n\r\nSteps:\r\n1. (r, M) = Blind(pwdU)\r\n2. Create CredentialRequest request with M\r\n3. Output (request, r)\r\n```",
          "createdAt": "2020-12-03T03:52:03Z",
          "updatedAt": "2020-12-03T03:52:03Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, got it. Yes, this makes sense, I believe in my implementation I already omitted the length prefix anyway.",
          "createdAt": "2020-12-03T03:56:13Z",
          "updatedAt": "2020-12-03T03:56:13Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWU3NTY2MTMyNTY=",
      "title": "Envelope correctness",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/96",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The record sent from client to server during the registration phase is as follows:\r\n\r\n~~~\r\nstruct {\r\n    Envelope envelope;\r\n    opaque pkU<0..2^16-1>;\r\n} RegistrationUpload;\r\n~~~\r\n\r\nAs is, the server has no assurance that the private key corresponding to `pkU` is inside (or derived from) the envelope. This raises two questions:\r\n\r\n1) Does the client need to prove possession of `skU`?\r\n2) If so, how would this work (non-interactively) for DH-based public keys? If not, we should probably add text clarifying why this isn't needed.",
      "createdAt": "2020-12-03T21:41:04Z",
      "updatedAt": "2020-12-16T21:08:12Z",
      "closedAt": "2020-12-16T21:08:11Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Although it would be nice if the client could prove possession of `skU`, I don't think it merits the extra complexity / computation that would be required, since I cannot imagine a scenario in which the server would need the assurance that the private key corresponding to `pkU` is inside the envelope. Did you have an example scenario in mind?",
          "createdAt": "2020-12-04T00:44:10Z",
          "updatedAt": "2020-12-04T00:44:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Nothing comes to mind right now, though I haven't given it much thought. ",
          "createdAt": "2020-12-04T01:13:15Z",
          "updatedAt": "2020-12-04T01:13:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's close this for now. We can re-open if needed later on.",
          "createdAt": "2020-12-16T21:08:11Z",
          "updatedAt": "2020-12-16T21:08:11Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWU3NTY3MDY2MTc=",
      "title": "Defining SerializeExtensions and DeserializeExtensions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/97",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L444-L446): Don't these functions need to be defined somewhere? At least they should sort the extensions by their type, perhaps in increasing order. It seems defining these in the specification is a requirement to producing compatible test vectors.\r\n\r\ncc: @chris-wood ",
      "createdAt": "2020-12-04T00:53:48Z",
      "updatedAt": "2021-01-11T15:07:16Z",
      "closedAt": "2021-01-11T15:07:15Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> At least they should sort the extensions by their type, perhaps in increasing order.\r\n\r\nSorting isn't required, since each extension is identified by its type. That said, adding more detail so their implementation is clear wouldn't hurt.",
          "createdAt": "2020-12-04T01:18:04Z",
          "updatedAt": "2020-12-04T01:18:04Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "If one implementation decides to sort the credentials in increasing order, and another decides to sort the credentials in decreasing order, then they will end up with a different HMAC output. Our test vectors will pick some ordering in order to generate the HMAC, and so seemingly this ordering should be spelled out in the specification, right?",
          "createdAt": "2020-12-04T02:07:44Z",
          "updatedAt": "2020-12-04T02:07:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, yeah, good point about different implementations. I\u2019ll draft up a PR for this soon.",
          "createdAt": "2020-12-04T02:11:40Z",
          "updatedAt": "2020-12-04T02:11:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is addressed by #107, which removes these credential serialize functions. The structs are already in wire format and don't need further serialization.",
          "createdAt": "2021-01-06T22:18:35Z",
          "updatedAt": "2021-01-06T22:18:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved.",
          "createdAt": "2021-01-11T15:07:15Z",
          "updatedAt": "2021-01-11T15:07:15Z"
        }
      ]
    },
    {
      "number": 98,
      "id": "MDU6SXNzdWU3NTY3MDk3ODM=",
      "title": "Removing auth_data from the envelope",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/98",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think we should remove the [`auth_data` field](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L455) in the envelope, but still keep it as part of the [HMAC derivation process](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L639-L641). The only reason why this might be set is if it contains a credential that is marked as a member of cleartext_credentials. But in this case, why not just make it a secret_credentials instead?\r\n\r\nThe advantage of cleartext_credentials are only apparent when the credential itself is NOT included in auth_data (and hence does not affect the total size of the envelope).",
      "createdAt": "2020-12-04T01:02:09Z",
      "updatedAt": "2021-01-08T00:42:38Z",
      "closedAt": "2021-01-08T00:42:38Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is a fine idea, but we still need a way for the client to know what values to include in the HMAC computation. Would the server supply, in its CredentialResponse, the list of cleartext_credential types used?",
          "createdAt": "2020-12-10T22:20:19Z",
          "updatedAt": "2020-12-10T22:20:19Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Removed in #102 ",
          "createdAt": "2021-01-08T00:42:38Z",
          "updatedAt": "2021-01-08T00:42:38Z"
        }
      ]
    },
    {
      "number": 99,
      "id": "MDU6SXNzdWU3NTY3MTMzMjc=",
      "title": "Simplifying the options for the credentials list in the envelope",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/99",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This issue is related to #87 and #90, in which the complexities of the setting of the envelope have come up.\r\n\r\nOne problem I foresee happening with allowing the server to choose what parameters should be optional, [which go in secret_credentials, which go in cleartext_credentials, etc.](https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L438-L442) is that it becomes cumbersome to manage exhaustive test vectors that would test all of the edge cases (combinations of these settings). And if we choose to only provide test vectors for some default setting, we run the risk of an implementation in the wild incorrectly implementing support for a non-default setting that we did not provide test vectors for.\r\n\r\nTo remedy this, one approach we could take would be to allow for only a small (maybe 2?) set of options for organizing the credentials in the envelope. Perhaps a \"base mode\" and a \"custom identifier mode\", and we could spend a single byte to dictate the mode for the envelope (similar to the VOPRF RFC with the byte representing the base mode or verifiable mode). Base mode would be some default, and \"custom identifier mode\" would support a custom idU and idS being included as secret_credentials.\r\n\r\nIf this sounds good, then now we just need to decide what modes we will support, and what each mode will look like.\r\n",
      "createdAt": "2020-12-04T01:10:53Z",
      "updatedAt": "2021-01-08T23:27:36Z",
      "closedAt": "2021-01-08T00:42:22Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this idea. Given that the number of credential types is likely quite small, I'm in favor of simplifying things and offering two modes here. For the \"custom identifier mode,\" either idU or idS could be nil, if desired, right? Or would we require that they both non-nil?",
          "createdAt": "2020-12-10T22:17:59Z",
          "updatedAt": "2020-12-10T22:17:59Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should allow for nil idU and idS, because it is not easy to check/enforce that idU and idS, and even if it were easily checkable, it is still an additional check that the OPAQUE implementation would have to do, which increases complexity.",
          "createdAt": "2020-12-10T22:42:11Z",
          "updatedAt": "2020-12-10T22:42:11Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Both idu and ids are used in the \"info\" / \"transcript\" (naming is not consistent) parameter in HKDF. Having them _nillable_ means the HKDF only relies on the nonces. I don't know if that's a problem.\r\n\r\nMoreover, both idu and ids are used in Sigma.",
          "createdAt": "2020-12-23T10:23:23Z",
          "updatedAt": "2020-12-23T11:18:41Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "The default behavior (base mode) is for them to be set to pkU and pkS. Only in customIdentifier mode can they be set to arbitrary strings. We discussed this a bit -- and we decided to allow null values to be set, since it is up to the wrapper protocol to dictate what should represent valid identities for idU and idS. Even if we were to disallow null values, they could still be set to 1-byte values... so the best we can do is to advise for defaulting to base mode unless the implementer really wants to use the custom identifier mode in this manner.",
          "createdAt": "2021-01-08T00:42:02Z",
          "updatedAt": "2021-01-08T00:42:02Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved by #102 ",
          "createdAt": "2021-01-08T00:42:22Z",
          "updatedAt": "2021-01-08T00:42:22Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Thank you very much for the additional information :)",
          "createdAt": "2021-01-08T23:27:36Z",
          "updatedAt": "2021-01-08T23:27:36Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWU3NjEyNTY1MDI=",
      "title": "export_keys also need AE with RKR",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/100",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "since my implementation has been prominently featured in the \"partitioning oracles paper\" i was thinking that the export_key must also only be used with key-committing AE schemes. i think this should be emphasized where export_keys are mentioned in the draft.",
      "createdAt": "2020-12-10T13:48:07Z",
      "updatedAt": "2020-12-21T16:42:15Z",
      "closedAt": "2020-12-21T16:42:15Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, this is an interesting point. @hugokraw, are there key-committing restrictions for the export key in terms of how it can be used by applications?",
          "createdAt": "2020-12-16T21:24:14Z",
          "updatedAt": "2020-12-16T21:24:14Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a good question but the answer is no. The export key has no special restrictions except for the remark in the {#export-usage} section: _The exporter_key MUST NOT be used in any way before the HMAC value in the envelope is validated._",
          "createdAt": "2020-12-16T21:56:48Z",
          "updatedAt": "2020-12-16T21:56:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! I'll draft a PR that notes this in the Security Considerations.",
          "createdAt": "2020-12-17T01:59:43Z",
          "updatedAt": "2020-12-17T01:59:43Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "This needs to be merged with PR 101 - see comment there.",
          "createdAt": "2020-12-17T06:23:03Z",
          "updatedAt": "2020-12-17T06:23:03Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWU3NzMyOTUxNDE=",
      "title": "Sigma-I signature algorithm specification",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/103",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\n\r\nSigma uses signatures, for which no algorithm has been specified in the current draft.\r\n\r\nsku/pku can be generated and used independently from the ciphersuite used in the rest of the protocol and stored in the envelope. This would introduce one more parameter, and for Sigma only, if OPAQUE allows for that kind flexibility. From what I understand, the number of parameters is already a concern.\r\n\r\nHow should the Sigma signature algorithm be set or chosen ?",
      "createdAt": "2020-12-22T22:39:11Z",
      "updatedAt": "2021-02-03T20:29:00Z",
      "closedAt": "2021-02-03T20:29:00Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We're not specifying a wire format version of SIGMA-I, so this will need to be done in a future draft that specifies SIGMA-I. Thus, I'm closing this for now.",
          "createdAt": "2021-02-03T20:29:00Z",
          "updatedAt": "2021-02-03T20:29:00Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWU3NzM3MDYyMTU=",
      "title": "Specify group for AKE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/104",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The current draft does not specify what groups can or should be used for the AKE. I first thought it was the same as for the OPRF.\r\n\r\nShould the group for the AKE be the same as for the OPRF, or is an additional parameter necessary?",
      "createdAt": "2020-12-23T12:03:22Z",
      "updatedAt": "2021-02-03T00:35:30Z",
      "closedAt": "2021-02-03T00:35:30Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this has been addressed now (it must match the one used for the OPRF). Let's close this",
          "createdAt": "2021-02-03T00:35:30Z",
          "updatedAt": "2021-02-03T00:35:30Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWU3NzQ2MTE0ODI=",
      "title": "Update wrapper protocol APIs to pass in credentials to FinalizeRequest",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/105",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Following up on the comment above, we might simplify things by delegating the \"credential construction\" logic to the wrapper protocol, which (a) knows the mode and (b) has the relevant information (skU, idU, pkS, idS, etc). That would make the interface to `FinalizeRequest` something like so:\r\n\r\n```\r\nFinalizeRequest(pwdU, creds, blind, response)\r\n```\r\n\r\nWhere `creds` contains the `secret_credentials` and `cleartext_credentials`, already in wire format form, to use when creating the envelope.\r\n\r\n_Originally posted by @chris-wood in https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/102#issuecomment-749720379_",
      "createdAt": "2020-12-25T03:13:54Z",
      "updatedAt": "2021-01-06T21:48:01Z",
      "closedAt": "2021-01-06T21:48:01Z",
      "comments": []
    },
    {
      "number": 108,
      "id": "MDU6SXNzdWU3ODE4MTcwMjQ=",
      "title": "3DH transcript is incomplete",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/108",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The 3DH transcript used in the key schedule [currently includes only the nonces and identity](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#section-4.2.2.2). This means the contents of info1, info2, and the core OPAQUE messages are not mixed into encryption or MAC keys, which seems less than idea. They are included in the transcript that is covered by the MAC, but I don't see why wouldn't *also* include them in the key schedule. \r\n\r\n@hugokraw, can this be improved?",
      "createdAt": "2021-01-08T03:37:18Z",
      "updatedAt": "2021-02-06T00:00:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "The protocol is secure as defined. Adding more elements to the key derivation does not hurt, even if not strictly necessary, but omitting elements is insecure. In particular, including the transcript instead of the currently defined info, may not include identities as these may not be appear in the transcript (are idU and idS necessarily transmitted explicitly as part of the transcript?) and identities are needed in the derivation.\r\nYou could just add a transcript element to the key derivation in addition to \"info\". In this case, the derivation of SK could use transcript3 as currently defined, but the derivation of handshake_secret cannot use transcript2. It will need to define a new value transcript2' that stops before Einfo2. \r\nI am not sure the extra complexity is worth given that the simpler derivation suffices here.\r\n\r\nTypo: The elements marked with * in the protocol description to indicate that they are optional appear as _ in the published draft (e.g., info1_)",
          "createdAt": "2021-01-08T18:04:44Z",
          "updatedAt": "2021-01-08T18:04:44Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Can we close this issue? @chris-wood ",
          "createdAt": "2021-02-02T00:56:14Z",
          "updatedAt": "2021-02-02T00:56:14Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "MDU6SXNzdWU3ODE4MjA0NDQ=",
      "title": "Remove optional fields from 3DH",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/109",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The 3DH instantiation currently allows servers to send plaintext info in the second message, clients to send plaintext info in the third message, and clients to send encrypted info in the third message. This seems like too many options. In particular:\r\n\r\n1. Since there is no cryptographic algorithm negotiation as part of the protocol, the primary benefit of info2 is to avoid server encryption in the second flight. This means that applications need to make a determination about what data is sensitive or not. (Servers already have the encryption keys at this point, so they can send anything they need encrypted and avoid giving applications an option.)\r\n2. Clients have the encryption keys necessary to encrypt application info in the third message. Similar to (1), this means applications must make a choice about what data is sensitive. Removing that choice, by folding info3 into einfo3, simplifies things. \r\n3. Sending application info in the third flight does not make much sense to me in general. If clients need to send info in the third flight, it can be encrypted using keys derived from the output of OPAQUE, i.e., the main traffic secret `SK`, rather than keys derived from `handshake_secret`. I can't think of an example where a client would want to send data in the third flight that MUST be processed before the key confirmation message.\r\n\r\nBased on the above, I think we should do the following: remove `info2`, `info3`, and `einfo3` from the protocol. `info1` and `einfo2` are sufficient for clients and servers to safely exchange application info as a preamble to the traffic secret, and all other info can be sent, encrypted, under a key derived from SK. \r\n\r\n@hugokraw, @kevinlewi, what do you think?",
      "createdAt": "2021-01-08T03:48:00Z",
      "updatedAt": "2021-02-03T21:52:52Z",
      "closedAt": "2021-02-02T00:55:43Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I am all for this! Especially if there is no decrease in security.",
          "createdAt": "2021-01-08T04:04:46Z",
          "updatedAt": "2021-01-08T04:04:46Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am ok with removing info2 and info3. I would leave einfo3 as there is no security decision to make here. If you are in a setting that requires sending something in the third flow, you use it. If there is no need for it, you don't. So the decision is a purely functional one, not security related. I find it hard to say that no reasonable application will need to use einfo3, , in particular, given that it is the first place where the client can communicate encrypted information to the server. ",
          "createdAt": "2021-01-08T19:46:53Z",
          "updatedAt": "2021-01-08T19:46:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I find it hard to say that no reasonable application will need to use einfo3, , in particular, given that it is the first place where the client can communicate encrypted information to the server.\r\n\r\nMy claim is that an application which needs to send info in the third message can send it encrypted with a key derived from SK, not from a handshake secret. This means there's effectively two ways to send information in the third flight -- either in einfo3 or in application data -- and it seems simpler to just force applications to use application data. ",
          "createdAt": "2021-01-08T20:03:11Z",
          "updatedAt": "2021-01-08T20:03:11Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Kevin, didn't one of your applications used the key as a token rather than to encrypt data as soon as the handshake was done? That would be an example of an application that could use einfo3 (which may or may not be Kevin's case but still a reasonable one).",
          "createdAt": "2021-01-08T21:47:35Z",
          "updatedAt": "2021-01-08T21:47:35Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw, the application I had in mind relied on the *server encrypting data to the client*, using the shared secret established at the end of the key exchange. einfo3 is used for data being sent from client to server.\r\n\r\nBut, to clarify the original question: Right now, the draft says to compute:\r\n```\r\nKe3 = HKDF-Expand-Label(handshake_secret, \"client enc\", \"\", key_length)\r\n```\r\nand use Ke3 as the encryption key for encrypting einfo3. What I would like to understand is: why do we need to derive this encryption key in this manner; why not just rely on using the shared secret as the encryption key instead?\r\n\r\nIf there are no *security concerns* with doing so, then we would like to remove einfo3 from the specification and defer it to the wrapper protocol that calls OPAQUE, since the wrapper protocol will have access to the shared secret and can choose to encrypt whatever equivalent of einfo3 it wishes.\r\n",
          "createdAt": "2021-01-08T21:53:26Z",
          "updatedAt": "2021-01-08T21:53:26Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I assume that by shared secret you mean SK. In that case, anything encrypted under SK must be considered application data and nothing that upon which the server will decide to establish the key or authenticate the client. The encrypted information SHALL NOT be part of the key exchange, If it is part of the key exchange then it needs to be sent in the clear or encrypted under Ke3 (otherwise you break the essential indistinguishability property of the key exchange). \r\nI was thinking of an application where the shared key SK is not intended for use  immediately at the end of the key exchange but later as some form of token  (in which case you may not want SK to be used immediately after the key exchange).",
          "createdAt": "2021-01-08T22:22:48Z",
          "updatedAt": "2021-01-08T22:22:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I was thinking of an application where the shared key SK is not intended for use immediately at the end of the key exchange but later as some form of token (in which case you may not want SK to be used immediately after the key exchange).\r\n\r\nHmm, couldn't this application derive two keys from SK -- one for sending encrypted info immediately, and another for future usage as you suggest? I think what @kevinlewi is zeroing in on is the desire to remove application-specific knobs from the handshake, since it complicates the specification and implementation.",
          "createdAt": "2021-01-08T22:31:19Z",
          "updatedAt": "2021-01-08T22:31:19Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Hmm, couldn't this application derive two keys from SK\r\n\r\nYes, it could. In my eyes it is a less elegant solution and requires the application to understand how to derive these two keys and handle the secure information. \r\n\r\nI agree with reducing as much as possible the security decisions an implementation/application needs to make (such as \"should I  send this in the clear or encrypted\") but whether I need to send something or not as part of the 3rd message (w/o having to decide on encrypting it or not) is a simpler question for the implementation. \r\n\r\nHowever, since this is an issue that does not have immediate security consequences (except for applications that may handle insecurely information that could have been accommodated in einfo3) I will go with your preference.",
          "createdAt": "2021-01-08T22:55:05Z",
          "updatedAt": "2021-01-08T22:55:05Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Hello,\r\n\r\nif I may, my two cents.\r\n\r\nAs an [implementer](https://github.com/bytemare/opaque), I find this discussion very interesting and am very happy it takes place. I did not understand the necessity of `info2 `and `info3 ` within the messages as `einfo2` and `einfo3` were available (there would be a redundancy having the plaintext message and encrypted message), and agree that leaving `info2 `and `info3` out would be preferable.\r\n\r\nAs for encrypting data in the third message, it really is a specific need of some applications and their choice to send it at that moment, hence not the protocol's responsibility (so no `einfo3` either). The document could give indications to implementors and users on how to properly use the output shared secret key (e.g. derive per need - encryption, token, etc.), and cite immediate usage for encryption as an example.",
          "createdAt": "2021-01-09T00:29:12Z",
          "updatedAt": "2021-01-09T00:54:38Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> The document could give indications to implementors and users on how to properly use the output shared secret key (e.g. derive per need - encryption, token, etc.), and cite immediate usage for encryption as an example.\r\n\r\nThanks, I think this is a good suggestion -- perhaps it would be worth adding a short sentence/paragraph to explain this.",
          "createdAt": "2021-01-10T01:56:56Z",
          "updatedAt": "2021-01-10T01:56:56Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "i have not quite understood concrete applications of these fields. however i have a feeling that the `*info*` fields can be related to protocols building upon opaque and can be used to convey protocol specific info, while the application would always use shared secret SK.",
          "createdAt": "2021-01-24T20:17:11Z",
          "updatedAt": "2021-01-24T20:17:11Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@stef The purpose of these fields is to allow for the sending of information that can be authenticated (in the case of info1) and authenticated+encrypted (in the case of info2) **before** the shared secret SK is established.\r\n\r\nI believe this issue may also be closed now that the info fields have been clarified, but please reopen if there is more discussion to be had here.",
          "createdAt": "2021-02-02T00:55:43Z",
          "updatedAt": "2021-02-02T00:55:43Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "thanks @kevinlewi i do understand what security properties these fields come with. what i wonder is concrete examples/use-cases how/where these fields are used - specifically what they would contain. one might assume that e.g. the MHF parameters would be such, but iirc that is not a good example. what would be good examples?",
          "createdAt": "2021-02-03T21:52:52Z",
          "updatedAt": "2021-02-03T21:52:52Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "MDU6SXNzdWU3ODMyODI1NTA=",
      "title": "Encryption in the AKE section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/111",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "What encryption method should we use to encrypt the `einfo2` field of the AKE section?\r\n\r\nI propose that we go with a simple XOR + HKDF based approach. Namely, take the current `Ke2` encryption key, feed it as input to `HKDF-expand`, and xor it with the plaintext to be encrypted. We can obtain the length parameter for HKDF-expand by simply measuring the length of the plaintext (correspondingly, the length of the ciphertext when we need to decrypt).\r\n\r\nThis XOR-based encryption method does not provide integrity, and only works for a single use of the `Ke2` encryption key, but I believe this is OK because `Ke2` only gets used exactly once anyway, and integrity is already provided by the MAC that is computed using `Km2`.\r\n\r\nIn particular, I want to avoid using more heavyweight but traditional algorithms like AES-GCM-256 / ChaCha20-Poly1305 because this increases complexity of the specification.\r\n\r\nThoughts? @hugokraw @chris-wood ",
      "createdAt": "2021-01-11T11:15:35Z",
      "updatedAt": "2021-02-02T00:53:23Z",
      "closedAt": "2021-02-02T00:53:23Z",
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Several comments:\r\n- While using GCM seems heavyweight relative to simple xor, some implementations may prefer it to xor since they already have the code that uses GCM for handshake traffic protection, e.g., borrowed from TLS. But fixing the encryption method avoids negotiation which is a real simplification. If  @chris-wood is ok with this, then I am ok with it too.\r\n- One needs AEAD here. The fact that it is a one-time key does not replace that requirement. For example, if an application were to send some negotiation information under einfo2, an attacker could flip some bits to change the offered security parameters.\r\n- The question that remains is whether to add an HMAC on top of the xor-generated ciphertext for achieving authenticated encryption or to count instead on the 3DH MAC for that purpose. Doing the latter would be secure and would indeed eliminate the need for the additional HMAC (and the derivation of an additional HMAC key). I do dislike this idea on \"principle\" grounds. I always advocate the principle that one should not use the same component for two different purposes, see for example https://mailarchive.ietf.org/arch/msg/cfrg/5ithq2sRpf7QZZ_pk_jrdGJwy3k/\r\nIn the case at hand, I can think of a future variant of the protocol where the server sends the MAC on a 4th flow, thus removing the MAC protection of  einfo2 (this case is not completely hypothetical: Stas and I have a variant of OPAQUE with some interesting properties that just does that). However, if you guys think this consideration is too academic and a note on it would suffice then I can go with it. \r\n- One has to be careful about determining the length of the plaintext to be encrypted; ambiguity in determining length leads to some attacks in some cases.",
          "createdAt": "2021-01-11T15:58:43Z",
          "updatedAt": "2021-01-11T15:58:43Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments @hugokraw!\r\n\r\n> The question that remains is whether to add an HMAC on top of the xor-generated ciphertext for achieving authenticated encryption or to count instead on the 3DH MAC for that purpose.\r\n\r\nI agree with these points. However, I am leaning towards relying on the 3DH MAC and omitting the \"extra HMAC on top of the xor-generated ciphertext\", although I think we can (and should) definitely add a note in the description of the encryption of einfo2 that we critically rely on the 3DH MAC for integrity (and that future amendments should take this into account when modifying the protocol).\r\n\r\nThe main reason why I would like to avoid adding another HMAC is that it seems wasteful in terms of bandwidth. This will increase the message length by another 16 or 32 bytes, even if einfo2 is only 1 byte long -- and in the case where einfo2 is 0 bytes long, do we still generate the HMAC? If so, it seems wasteful, and if not, then implementations must take care to check for the length of einfo2 and case on whether or not it is empty. While doable, it means that when we generate test vectors for implementations to match against, we may need to generate an extra set of test vectors that ensure that implementations explicitly do this check.",
          "createdAt": "2021-01-11T16:39:52Z",
          "updatedAt": "2021-01-11T16:39:52Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "If einfo2 is omitted then no need for the HMAC. I am not sure how crucial the bandwidth issue is and if it is enough of a reason to  make this decision (I would prefer to have the HMAC in the spec and havea note saying that if bandwidth is critical enough then the HMAC can be skipped, assuming the 3DH MAC stays in that same flow. If we do decide to forgo the HMAC all together then there should be a note on the essential need for the 3DH MAC in the same flow AND that no action should be taken on the basis of information encrypted under einfo2 before that 3DH MAC is verified.",
          "createdAt": "2021-01-11T17:00:55Z",
          "updatedAt": "2021-01-11T17:00:55Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Does that mean that 3DH will be used exclusively as the AKE ?",
          "createdAt": "2021-01-21T23:23:14Z",
          "updatedAt": "2021-01-21T23:23:14Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Applications can choose to use any AKE they want with OPAQUE. For example TLS would use their handshake AKE (essentially SIGMA-I). IKE  and Signal could use it with variants of SIGMA-R and 3DH, respectively, and PQ AKEs could use it with some PQ KEM-based protocols. The 3DH protocol as specified here serves as one fully-specified AKE for applications that do not want to develop or adapt other AKEs and, very importantly, as a basis for interoperability testing. Probably also as a \"must implement\" for implementations that call themselves \"compliant\" with the standard (but this may not apply here as this is an informational RFC, I guess). @chris-wood can say more in this regard. \r\n",
          "createdAt": "2021-01-22T17:58:24Z",
          "updatedAt": "2021-01-22T17:58:24Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> but this may not apply here as this is an informational RFC, I guess\r\n\r\nMy understanding is that we are very much shooting for a concrete RFC for implementations to measure compliance against.\r\n\r\n> Does that mean that 3DH will be used exclusively as the AKE ?\r\n\r\nThat is the current direction that we are going in. @chris-wood posed this question to the mailing list (https://mailarchive.ietf.org/arch/msg/cfrg/N5AsUuSTEBcrfGCgxirPI0xFkps/), as we are also trying to figure out if we should be supporting AKEs other than 3DH here.",
          "createdAt": "2021-01-22T18:12:05Z",
          "updatedAt": "2021-01-22T18:12:05Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that we now implement the XOR + HKDF based approach here (https://github.com/cfrg/draft-irtf-cfrg-opaque/blame/master/draft-irtf-cfrg-opaque.md#L1023-L1024), I believe this issue can be closed.\r\n\r\nPlease reopen if this is still unresolved!",
          "createdAt": "2021-02-02T00:53:23Z",
          "updatedAt": "2021-02-02T00:53:23Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "MDU6SXNzdWU3ODM3NjcyMTA=",
      "title": "Suggested Changes 1/11/21",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/112",
      "state": "CLOSED",
      "author": "crockeea",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "next-version"
      ],
      "body": "I read through the draft (https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html on 1/11/21), and have a few comments.\r\n\r\n-\tAdd `pwdU` to section 1.2\r\n-\tAdd OPRF `KeyGen()` to section 2 (referenced in section 3.2.2.2)\r\n-\tThe type of `mode` in the `InnerEnvelope` struct should be `EnvelopeMode`\r\n-\tSection 3.1: The text above the definition of the `Envelope` and `InnerEnvelope` structs says, \u201cThese credentials are embedded into the following structure\u2026\u201d. I therefore expected to see a `SecretCredentials` struct and `CleartextCredentials` struct in either `Envelope` or `InnerEnvelope`. There is a field for \u201cencrypted_creds\u201d, which could correspond to the encryption of the `SecretCredentials`, but there still seems to be no place where `CleartextCredentials` can be embedded into these structs.\r\n-\tBe consistent about the use of parens for functions which output multiple values (see protocol diagrams at top of section 3.2 and at the top of 3.3)\r\n-\tNotation for kU: section 1.2 says \u201ckU refers to U's private OPRF key\u201d. Without any other context, I expect this to be something generated by the user, and known only to the user. But in reality, kU is a per-user key generated by the server, and not revealed to the client. Is there a different way to describe `kU` to avoid this potential confusion?\r\n-\tOPRF blind is referred to as both `blind` and `r`. Make this consistent for clarity.\r\n-\tNeed to define the `Credentials` structure mentioned at the end of section 3.1: fields of this struct are referenced in section 3.2.2.3, but never defined.\r\n-\tSection 3.2.2.3 step 7: uses `len(pt)`, but I\u2019m not sure what `pt` is supposed to be/refer to. Perhaps `secret_creds`?\r\n-\tSection 3.2.2.3 step 11: \u201cCreate InnerEnvelope contents\u201d. I read this as \u201cCreate [an unnamed] InnerEnvelope body\u2026.\u201d, but you apparently intended to name the struct `contents`, since you then refer to it in step 12. If you gave this a non-English-word name, this would be clearer, since there are no typesetting clues.\r\n-\tIs it really necessary to define a variant of `CleartextCredentials`? Why not always use the larger struct? This is only included as AAD; it is not actually transmitted or stored. It\u2019s adding a lot of extra complexity with no apparent benefit. Implementations can always used a short fixed value if they would otherwise want to use the truncated `CleartextCredentials`.\r\n-\tThe type of OPRF group elements isn\u2019t consistent: in section 3.2.1, it\u2019s an (undefined!) type `SerializedElement data`; in section 3.3.1, it\u2019s `opaque data<1..2^16-1>`\r\n-\tSection 3.3.2.3: The \u201cOutputs\u201d list a `SecretCredentials` and an export key, but the diagram shows that RecoverCredentials outputs (skU, pkS, export_key)\r\n-\tSuggestion: incorporate generic AKE messages into the protocol in section 3.3. It would be nice to have a complete diagram of the generic protocol. Currently, you have a partial diagram in section 3.3 and a textual description of the full protocol in the intro of section 4.\r\n-\tSection 4 intro: \u201cHowever, an instantiation where both AKE and data encryption are quantum safe\u2026\u201d Is this encryption referring to the EnvU encryption defined in section 3.2.2.3? If so, isn\u2019t the encryption already quantum safe? If that\u2019s the case, I\u2019d change this to \u201cHowever, an instantiation where AKE is quantum safe\u2026\u201d to avoid confusion.\r\n-\tSection 4.1: struct `HkdfLabel` contains the field opaque label<8..255> = \"OPAQUE \" + Label; Is `Label` required to be non-null, or is the string required to be null-terminated? The string \u201cOPAQUE \u201c has length 7, so I\u2019m wondering why the minimum field size is 8. (I see that this is consistent with TLS1.3, but I don\u2019t see an explanation there either.)\r\n-\tSection 4.2.1: This section defines, e.g., ` KE1 = credential_request, nonceU, info1*, epkU`, so that KE1 contains the credential_request. However, at the top of section 4, the high-level protocol shows credential_request being sent in addition to KE1. This is another reason it would be helpful to have a complete diagram of the generic protocol (with, e.g., a generic 3-message AKE). For this particular issue, I think KE1 should only include AKE message components; it should not include the credential_request. Similarly for KE2 and section 4.3.1.\r\n-\tSection 5: \u201cFuture specifications \u2026 MAY introduce other AKE instantiations.\u201d Also allow for/mention the possibility of defining alternate OPRFs. For example, https://eprint.iacr.org/2020/1532 gives a lattice-based (and hence PQ) OPRF.\r\n-\tSection 6.6: What does \u201cskipping the key exchange part\u201d mean? Does it mean somehow truncating the protocol/skipping the AKE entirely? Or does it mean not using the exchanged key after a successful authentication? In general, I\u2019m not sure what I would have to do to violate this section, which means I could easily violate it without knowing.\r\n",
      "createdAt": "2021-01-11T22:58:23Z",
      "updatedAt": "2021-02-06T00:00:17Z",
      "closedAt": "2021-02-06T00:00:17Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @crockeea, for the detailed review! I reviewed the comments and turned those applicable into action items below. (Some are already addressed, so I omitted those.) I responded to specific comments below that list. Please let me know if I misunderstood any of your feedback.\r\n\r\nTasks:\r\n- [x] Add pwdU to section 1.2 (notation)\r\n- [x] The type of mode in the InnerEnvelope struct should be EnvelopeMode\r\n- [x] Section 3.1: Clarify that not all credentials are embedded in the envelope\r\n- [x] Be consistent about the use of parens for functions which output multiple values (see protocol diagrams at top of section 3.2 and at the top of 3.3)\r\n- [x] Clarify kU ownership\r\n- [x] Section 3.2.2.3 step 7: s/len(pt)/len(secret_creds)\r\n- [x] Section 3.2.2.3 step 11: Rename InnerEnvelope from \"contents\" to something less confusing, perhaps \"inner_envelope\"?\r\n- [ ] Update Section 4 OPRF+AKE text description with a diagram like that in the registration and authentication steps.\r\n- [x] Clarify HkdfLabel \"Label\" properties (Is Label required to be non-null, or is the string required to be null-terminated?)\r\n- [x] Section 5: Allow future OPRFs to be chosen, possibly citing PQ OPRFs (https://eprint.iacr.org/2020/1532).\r\n\r\nComments:\r\n\r\n> Add OPRF KeyGen() to section 2 (referenced in section 3.2.2.2)\r\n\r\nThis is already in Section 2, where we say, \"We also assume the existence of a function KeyGen from [I-D.irtf-cfrg-voprf], which generates an OPRF private and public key.\"\r\n\r\n> Section 3.1: The text above the definition of the Envelope and InnerEnvelope structs says, \u201cThese credentials are embedded into the following structure\u2026\u201d. I therefore expected to see a SecretCredentials struct and CleartextCredentials struct in either Envelope or InnerEnvelope. There is a field for \u201cencrypted_creds\u201d, which could correspond to the encryption of the SecretCredentials, but there still seems to be no place where CleartextCredentials can be embedded into these structs.\r\n\r\nGood point! Only the secret credentials are actually included in the envelope. The cleartext credentials are omitted but ultimately folded into the MAC check. We can clarify the text to make this more clear.\r\n\r\n> Notation for kU: section 1.2 says \u201ckU refers to U's private OPRF key\u201d. Without any other context, I expect this to be something generated by the user, and known only to the user. But in reality, kU is a per-user key generated by the server, and not revealed to the client. Is there a different way to describe kU to avoid this potential confusion?\r\n\r\nGreat point. We can probably say something along the lines of, \"kU is a unique OPRF key for user U known only to the server.\"\r\n\r\n> Need to define the Credentials structure mentioned at the end of section 3.1: fields of this struct are referenced in section 3.2.2.3, but never defined.\r\n\r\nCredentials is meant to be an implementation-specific construct with fields listed in its description. We chose to not define this structure using standard notation since it's irrelevant for the description protocol. All that matters is that the core protocol can access the name fields from a Credentials object. (We do [something similar for HPKE] when generating encryption contexts.)\r\n\r\n> Is it really necessary to define a variant of CleartextCredentials? Why not always use the larger struct? This is only included as AAD; it is not actually transmitted or stored. It\u2019s adding a lot of extra complexity with no apparent benefit. Implementations can always used a short fixed value if they would otherwise want to use the truncated CleartextCredentials.\r\n\r\nHmm, I'm not sure I understand this comment. @crockeea, would you mind elaborating?\r\n\r\n> Suggestion: incorporate generic AKE messages into the protocol in section 3.3. It would be nice to have a complete diagram of the generic protocol. Currently, you have a partial diagram in section 3.3 and a textual description of the full protocol in the intro of section 4.\r\n\r\nI think it's more readable if the core protocol description is unencumbered by the AKE steps. How about a compromise: replace the textual description in Section 4 with a graphical description similar to that in Section 3?\r\n\r\n> Section 4 intro: \u201cHowever, an instantiation where both AKE and data encryption are quantum safe\u2026\u201d Is this encryption referring to the EnvU encryption defined in section 3.2.2.3? If so, isn\u2019t the encryption already quantum safe? If that\u2019s the case, I\u2019d change this to \u201cHowever, an instantiation where AKE is quantum safe\u2026\u201d to avoid confusion.\r\n\r\nI think this is referring to the encryption of data sent during and after the AKE, though I'm now not certain :) @hugokraw, can you double check this paragraph?\r\n\r\n> Section 4.1: struct HkdfLabel contains the field opaque label<8..255> = \"OPAQUE \" + Label; Is Label required to be non-null, or is the string required to be null-terminated? The string \u201cOPAQUE \u201c has length 7, so I\u2019m wondering why the minimum field size is 8. (I see that this is consistent with TLS1.3, but I don\u2019t see an explanation there either.)\r\n\r\nHmm, good question. I don't recall off hand. I filed [this issue](https://github.com/tlswg/tls13-spec/issues/1207) against the TLS 1.3 update to track this question.\r\n\r\n> Section 4.2.1: This section defines, e.g., KE1 = credential_request, nonceU, info1*, epkU, so that KE1 contains the credential_request. However, at the top of section 4, the high-level protocol shows credential_request being sent in addition to KE1. This is another reason it would be helpful to have a complete diagram of the generic protocol (with, e.g., a generic 3-message AKE). For this particular issue, I think KE1 should only include AKE message components; it should not include the credential_request. Similarly for KE2 and section 4.3.1.\r\n\r\nThis is an interesting point. Mixing them together was done to highlight that the OPAQUE messages MUST be included in the AKE transcript. I'll see if we can show this requirement differently without losing readability.\r\n\r\n> Section 6.6: What does \u201cskipping the key exchange part\u201d mean? Does it mean somehow truncating the protocol/skipping the AKE entirely? Or does it mean not using the exchanged key after a successful authentication? In general, I\u2019m not sure what I would have to do to violate this section, which means I could easily violate it without knowing.\r\n\r\nIt means, for example, just running the OPRF flow and then doing nothing with the recovered credentials. Do you think it would be useful or valuable to be more specific here?",
          "createdAt": "2021-01-14T22:40:14Z",
          "updatedAt": "2021-01-26T03:00:06Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "- For the OPRF `KeyGen`, my confusion stemmed from looking in the OPRF API list and not finding `KeyGen` there. I propose adding the following to the OPRF API list:\r\n   ```\r\n   KeyGen(): Generates an OPRF private and public key. OPAQUE only requires an OPRF private key. We write (kU, _) = KeyGen() to denote use of this function for generating secret key kU (and discarding the corresponding public key).\r\n   ```\r\n   and removing the corresponding text from the paragraph below the list.\r\n- For `Credentials`: I'm not very familiar with standard practices here, but should we perhaps point out that this struct is implementation-specific? Otherwise it just looks like it's missing/an error.\r\n- \"variant of CleartextCredentials\": Section 3.1 contains two definitions of the `CleartextCredentials` struct, and `EnvelopeMode` is an enum that indicates which struct type is contained in the envelope (as I write this it strikes me that this is really not right: `CleartextCredentials` are not part of the envelope (at least not the `Envelope` struct)!). Can we get away with using a single `CleartextCredentials` struct? This eliminates the need for the `EnvelopeMode` enum, which results in a simpler and easier-to-understand protocol. I'm not seeing what benefit we get from defining two different `CleartextCredentials` structs with an enum to switch between them.\r\n- On a related note: section 3.1 also defines `SecretCredentials` twice, but there are no differences between the two definitions. If you do end up keeping two structs for `CleartextCredentials` for some reason, then section 3.1 should define `SecretCredentials` only once. and view `EnvelopeMode` as switching between the two definitions of `CleartextCredentials`. (The current approach is to use the `EnvelopeMode` to switch between alternate definitions of both `*Credentials` types.)\r\n- \"Core Protocol diagram\": To me, the \"core\" protocol is the combination of the OPRF and the AKE, and section 3 purports to describe the \"Core Protocol\". However, if you're proposing replacing the textual description with a diagram similar to section 3.3 augmented with the AKE messages, I'd be okay with that. As long as the complete (generic) diagram is somewhere.\r\n- @hugokraw Regarding the paragraph about quantum safety: \"OPAQUE may be instantiated....[h]owever, an instantiation where both AKE and data encryption are quantum safe, but the OPRF is not, would still ensure...\" I read that as \"an instantiation [of OPAQUE]\", and when I think about the security of \"OPAQUE\", I think about the authentication/key exchange protocol itself, _not_ what happens after that (which seems to me to be beyond the scope of this specification). We should be clear which encryption scheme this is referring to.\r\n- \u201cskipping the key exchange part\u201d: Yes, it would be valuable to be more specific here. I see two possible interpretations of the current paragraph. It either addresses a situation where\r\n   - someone executes OPAQUE (by which I mean the OPRF+AKE), gets the key, and then throws the key away\r\n   - someone executes only an OPRF (or perhaps what you currently refer to as the \"core protocol\") without any sort of key exchange\r\n\r\nI think most of my confusion on several of these points arises because the document appears to define the \"core protocol\" as just the OPRF portion. I'm not sure why, since, as you point out, the AKE is _required_ for security. As written, the AKE comes off as a \"second-class citizen\". By including the AKE as part of the \"core protocol\", we make it clear that the AKE is a required part of OPAQUE. There is no longer the possibility of \"skipping the key exchange\", because it would be clear that a protocol that does an OPRF without an AKE is _not_ OPAQUE.\r\n\r\nWe should also more clearly define the scope of the specification. It refers only to the key exchange and authentication, and not to anything outside that (i.e., usage of OPAQUE in a larger protocol). This would, for example, clear up any confusion about which encryption scheme is referred to in the post-quantum security paragraph: it could only refer to the encryption scheme in the OPAQUE protocol itself.",
          "createdAt": "2021-01-15T00:56:38Z",
          "updatedAt": "2021-01-15T00:56:38Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Regarding the paragraph about quantum safety: \"OPAQUE may be instantiated....[h]owever, an instantiation where both AKE and data encryption are quantum safe, but the OPRF is not, would still ensure...\" I read that as \"an instantiation [of OPAQUE]\", and when I think about the security of \"OPAQUE\", I think about the authentication/key exchange protocol itself, not what happens after that (which seems to me to be beyond the scope of this specification). We should be clear which encryption scheme this is referring to.\r\n\r\nI suggest moving this text to the security considerations as subsection titled \"Quantum-safe instantiation\" with the following edited text:\r\n\r\nOPAQUE may be instantiated with any post-quantum (PQ) AKE protocol with the security properties (KCI resistance and forward secrecy) outlined in {{security-considerations}}. To obtain a quantum-safe OPAQUE instantiation, also the OPRF needs to be quantum safe. Recent progress towards defining such OPRF can be found in [cite https://eprint.iacr.org/2020/1532]. We do stress that an OPAQUE instantiation where the AKE protocol is quantum-safe but the OPRF is not, would still ensure data security against future quantum attacks since breaking the OPRF does not retroactively affect the security of data transferred over a quantum-safe secure channel.\r\n\r\n@crockeea @chris-wood Is that better? \"quantum-safe secure channel.\" is short for \"data transferred under a  quantum-safe encryption scheme with a key derived from a quantum-safe AKE\". You may want to be more explicit.\r\n",
          "createdAt": "2021-01-15T23:13:41Z",
          "updatedAt": "2021-01-15T23:13:41Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Section 6.6: What does \u201cskipping the key exchange part\u201d mean? Does it mean somehow truncating the protocol/skipping the AKE entirely? Or does it mean not using the exchanged key after a successful authentication? In general, I\u2019m not sure what I would have to do to violate this section, which means I could easily violate it without knowing.\r\n\r\nI suggest the following replacement text for that section:\r\n\r\nOPAQUE provides PAKE (password-based authenticated key exchange) functionality in the client-server setting. While for user identification focus is often on the authentication part, we stress that the key exchange element is essential for data protection.  Authenticating the user but not protecting the data in the ensuing session is analogous to carefully checking a visitor's \r\n credential at the door and then leaving the door open for others to enter freely.\r\n\r\n@crockeea @chris-wood Is this better? I am ok with removing this remark all together. I heard this question a couple of times (why we need key exchange) so I wanted to make this point. But if it is confusing we can do without it.",
          "createdAt": "2021-01-15T23:19:36Z",
          "updatedAt": "2021-01-15T23:19:36Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "From @crockeea \r\n> I think most of my confusion on several of these points arises because the document appears to define the \"core protocol\" as just the OPRF portion. I'm not sure why, since, as you point out, the AKE is required for security. As written, the AKE comes off as a \"second-class citizen\". By including the AKE as part of the \"core protocol\", we make it clear that the AKE is a required part of OPAQUE. \r\n\r\n@chris-wood @kevinlewi We must make sure that readers understand that there is no OPAQUE without AKE. So @crockeea suggestions in this regard are *very* important.",
          "createdAt": "2021-01-15T23:23:14Z",
          "updatedAt": "2021-01-15T23:23:14Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "+1\r\n\r\nAs an observer, I felt that the AKE part has been put aside, indeed. But I interpreted it as \"we first need to thoroughly define secret credential recovery, and then we'll do the AKE parts\".\r\n\r\nAs a reader and implementer, I have a lot of questions relative to the part post-secret-retrieval, as the draft doesn't go much into details, yet.",
          "createdAt": "2021-01-19T16:50:37Z",
          "updatedAt": "2021-01-19T16:50:37Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "> OPAQUE provides PAKE (password-based authenticated key exchange) functionality in the client-server setting. While for user identification focus is often on the authentication part, we stress that the key exchange element is essential for data protection. Authenticating the user but not protecting the data in the ensuing session is analogous to carefully checking a visitor's\r\ncredential at the door and then leaving the door open for others to enter freely.\r\n\r\nI'm still confused by this one. I think we need to be more clear about the model to which you are referring. In particular, what does \"data protection\"/\"protecting the data\" refer to? It sounds like protection of data in a larger protocol, but that's not explicit, and it should be.",
          "createdAt": "2021-01-19T19:15:05Z",
          "updatedAt": "2021-01-19T19:15:38Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I was referring to the fact that most of the time the exchange between server and client does not stop at the success/failure of the user authentication but it is followed by some activity between client and server which typically carries some data. The KE part of PAKE is needed to derive a key that will protect such data. Given that this comment seems to generate more confusion than good, I propose removing it all together. ",
          "createdAt": "2021-01-19T21:10:30Z",
          "updatedAt": "2021-01-19T21:10:30Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "\"Data protection\" may indeed be interpreted as regulatory compliance to \"Data Protection\" (e.g. GDPR and such).\r\n\r\nMaybe replace this with\r\n\r\n> OPAQUE provides PAKE (password-based authenticated key exchange) functionality in the client-server setting. While for user identification focus is often on the authentication part, we stress that the key exchange element is essential for providing means to encrypt subsequent the communication session. Authenticating the user but not providing confidentiality and integrity for the data in the ensuing session is analogous to carefully checking a visitor's credential at the door and then leaving the door open for others to enter freely.",
          "createdAt": "2021-01-20T14:58:09Z",
          "updatedAt": "2021-01-20T14:58:09Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this text. If others are happy with it, let's keep it. If it is still (potentially) confusing, I am ok with removing it all together.",
          "createdAt": "2021-01-20T15:02:05Z",
          "updatedAt": "2021-01-20T15:02:05Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "I'd like to keep something in the draft along these lines, but I am still confused. Specifically:\r\n> we stress that the key exchange element is essential for providing means to encrypt subsequent the communication session.\r\n\r\nDoes this mean I have to protect subsequent data _with the OPAQUE key_, or is it just pointing out that confidentiality and integrity are important cryptographic properties? Could I obtain confidentiality and integrity with an independent key? For example, what if I did OPAQUE inside a TLS channel (not as part of the handshake)? Is this comment saying that I (still) _must_ use the OPAQUE key to protect data inside the TLS channel to obtain any guarantees about authentication?",
          "createdAt": "2021-01-20T22:12:25Z",
          "updatedAt": "2021-01-21T02:17:08Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "I see what you mean. Another aspect of this has been discussed [here](https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/109#issuecomment-757061307).\n\nHow about this\n\n> OPAQUE provides PAKE (password-based authenticated key exchange) functionality in the client-server setting. While user identification often focuses on the authentication part, we stress that the key exchange element is essential for providing a shared secret. This shared secret is suitable for different use cases, e.g. session tokens or means to encrypt the subsequent communication session. Authenticating the user but not providing confidentiality and integrity for the data in the ensuing session is analogous to carefully checking a visitor's credential at the door and then leaving the door open for others to enter freely.\n\n(Another paragraph would need to explain how to derive different keys for different usaged using HKDF-Expand.)",
          "createdAt": "2021-01-21T00:43:59Z",
          "updatedAt": "2021-01-21T01:20:09Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Does this mean I have to protect subsequent data _with the OPAQUE key_, or is it just pointing out that confidentiality and integrity are important cryptographic properties? Could I obtain confidentiality and integrity with an independent key? For example, what if I did OPAQUE inside a TLS channel (not as part of the handshake)? Is this comment saying that I (still) _must_ use the OPAQUE key to protect data inside the TLS channel to obtain any guarantees about authentication?\r\n\r\nThis comment fully convinces me to drop this text. Eric is right about the possibility of running OPAQUE inside TLS without the need to generate a data-protection key by OPAQUE. Indeed, that is *exactly* how we plan to integrate OPAQUE with TLS. In this case, OPAQUE will serve as a \"post-handshake authentication\" of the TLS handshake without requiring to change the traffic keys established by the TLS handshake. It shows that in some cases it does make sense to run OPAQUE without deriving a data-protection key and therefore the text in question is, as Eric insisted, confusing.",
          "createdAt": "2021-01-21T06:21:39Z",
          "updatedAt": "2021-01-21T06:21:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@crockeea do you think a diagram in the authentication section is still needed? If not, I'll close this issue, since the remaining tasks were addressed.",
          "createdAt": "2021-02-04T17:48:47Z",
          "updatedAt": "2021-02-04T17:48:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to close this as resolved for now. @crockeea, if you think we still need to address points raised in this issue, can you please file separate issues for them? Thanks!",
          "createdAt": "2021-02-06T00:00:17Z",
          "updatedAt": "2021-02-06T00:00:17Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "MDU6SXNzdWU3OTA2MjA0MTM=",
      "title": "I'd like to keep something in the draft along these lines, but I am still confused. Specifically, med to be, or does the",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/118",
      "state": "CLOSED",
      "author": "crockeea",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'd like to keep something in the draft along these lines, but I am still confused. Specifically, about\r\n> we stress that the key exchange element is essential for providing means to encrypt subsequent the communication session.\r\n\r\nDoes this mean I have to protect subsequent data _with the OPAQUE key_, or is it just pointing out that confidentiality and integrity are important cryptographic properties? Could I obtain confidentiality and integrity with an independent key? For example, what if I did OPAQUE inside a TLS channel (not as part of the handshake)? Is this comment saying that I (still) _must_ use the OPAQUE key to protect data inside the TLS channel to obtain any guarantees about authentication?\r\n\r\n_Originally posted by @crockeea in https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/112#issuecomment-763983736_",
      "createdAt": "2021-01-21T02:14:26Z",
      "updatedAt": "2021-01-21T02:14:58Z",
      "closedAt": "2021-01-21T02:14:58Z",
      "comments": []
    },
    {
      "number": 119,
      "id": "MDU6SXNzdWU3OTEzNDUwNDQ=",
      "title": "Test vectors and naming",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/119",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'd like to reach an agreement on the names of variables we use for OPAQUE, which also impact the parameters to each of the test vectors we release. Here is what I have so far (open to feedback!):\r\n\r\nInputs:\r\n\r\n```\r\n    pk_u: Client's static public key\r\n    sk_u: Client's static private key\r\n    epk_u: Client's ephemeral public key\r\n    esk_u: Client's ephemeral private key\r\n    pk_s: Server's static public key\r\n    sk_s: Server's static private key\r\n    epk_s: Server's ephemeral public key\r\n    esk_s: Server's ephemeral private key\r\n    password: Client's password\r\n    id_u: idU\r\n    id_s: idS\r\n    blind_registration: Scalar used to blind client's password during registration\r\n    blind_login: Scalar used to blind client's password during login\r\n    oprf_key: kU, the server's secret key for the OPRF\r\n    envelope_nonce: nonce used for envelope\r\n    client_nonce: nonce from client used in AKE\r\n    server_nonce: nonce from server used in AKE\r\n    info1: Plaintext info field populated by client in first AKE message\r\n    info2: Encrypted info field populated by server in second AKE message\r\n```\r\n\r\nOutputs:\r\n\r\n```\r\n    registration_request: First message of registration\r\n    registration_response: Second message of registration\r\n    registration_upload: Third message of registration\r\n    credential_request: First message of login\r\n    credential_response: Second message of login\r\n    credential_finalization: Third message of login\r\n    credential_file: The object stored by the server after registration has completed\r\n    export_key: The export_key parameter output by registration and login's final step on the client\r\n    session_key: The output of the client and server after the AKE\r\n```\r\n\r\nThere is also an opportunity to publish \"intermediate values\" here, such as the envelope bytes, the \"rwdU\" value, etc. They are not included here at the moment, but we could add additional values to represent them as well, if desired.",
      "createdAt": "2021-01-21T17:16:39Z",
      "updatedAt": "2021-02-11T15:03:30Z",
      "closedAt": "2021-02-03T00:32:02Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Awesome! I like this set of input values, they are indeed the minimum core values necessary to run the engine.\r\n\r\nRegarding naming, we could maybe shorten some of the obvious names?\r\n\r\n- `client_identifier` -> `client_id ` or even `idu`\r\n- `server_identifier` -> `server_id` or even `ids`\r\n- `blinding_factor_registration` -> `blind_registration`\r\n- `blinding_factor_login` -> `blind_login` or `blind_auth`\r\n\r\nThis set of inputs does not cover the parameters necessary for the test. I understand that all decisions regarding these have not been taken, yet. But some are still necessary to test, even just a first set. These are the ones I use;\r\n\r\nParameters:\r\n\r\n```\r\noprf_suite_id : The OPRF ciphersuite identifier used\r\nenvelope_hash_alg : The name of the hash algorithm used for the keying in the envelope stage\r\nmhf_alg : The name of the memory hard function used for rwdu\r\nmhf_parameters : A vector of parameters proper to the MHF algorithm to be used\r\nenvelope_mode : The envelope mode\r\nake_id : The AKE identifier/name\r\nake_group: The group which the DH will be operated in\r\nake_hash_alg : The name of the hash algorithm to be used in the AKE\r\n(If applicable - for Sigma)\r\nsigma_sig_alg : The name of the signature algorithm to be used (indicates also the nature of sku/pku)\r\n```\r\n\r\n( I tried different configurations for \"exploratory full tests\" (with different akes and other parameters) [here](https://github.com/bytemare/opaque/blob/main/vectors_test.go), but they need to be stripped down)",
          "createdAt": "2021-01-21T21:28:55Z",
          "updatedAt": "2021-01-21T21:28:55Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Also `password_file `-> `credential_file` to stay consistent with https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/7539e8665bae01e8c96f79b8f378f56dcbb8bab7/draft-irtf-cfrg-opaque.md#L666",
          "createdAt": "2021-01-21T21:56:03Z",
          "updatedAt": "2021-01-21T21:56:03Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "why these long ids? why not use the ids exactly as they are in the draft? so `client_s_pk` would be `pkU`",
          "createdAt": "2021-01-22T22:38:18Z",
          "updatedAt": "2021-01-22T22:38:18Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "I agree, I don't see a specific need to the lengthy human friendly naming",
          "createdAt": "2021-01-24T00:10:50Z",
          "updatedAt": "2021-01-24T00:10:50Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "- `client_s_sk/pk` -> `sku/pku`\n- `cliient_e_sk/pk` -> `esku/epku`\n- `server_s_sk/pk` -> `sks/pks`\n- `server_e_sk/pk` -> `esks/epks`",
          "createdAt": "2021-01-24T00:17:04Z",
          "updatedAt": "2021-01-24T00:17:04Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the feedback @stef and @bytemare! I am not super tied to any of the original names I originally proposed, and am supportive of all of the changes mentioned. Will leave it up to @chris-wood to also chime in with his opinion!",
          "createdAt": "2021-01-25T06:17:21Z",
          "updatedAt": "2021-01-25T06:17:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I only care that the names are consistent across the spec and test vectors :-) to that end, if folks are generally okay with what's in the draft (pkU versus client_s_pk, for example), then my preference would be to stick with them.",
          "createdAt": "2021-01-25T16:00:46Z",
          "updatedAt": "2021-01-25T16:00:46Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "+1 for consistency. What that might be in the end is less important, as long as one understands when reading the document and looks at the vectors.",
          "createdAt": "2021-01-26T00:02:03Z",
          "updatedAt": "2021-01-26T00:02:03Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@stef + @bytemare : I edited the original text to incorporate your suggestions. I decided to still use lowercase with underscores (pk_u instead of pkU, epk_u instead of epkU) for consistency. I also changed:\r\n- \"client_identifier\" -> \"id_u\" and \"server_identifier\" -> \"id_s\",\r\n- \"blinding_factor_registration\" -> \"blind_registration\" and \"blinding_factor_login\" -> \"blind_login\"\r\n- \"password_file\" -> \"credential_file\",\r\n- \"shared_secret\" -> \"session_key\"\r\n\r\nPlease let me know if you disagree with the lowercase styling, or if you have any other general feedback. Thank you again for your inputs!!",
          "createdAt": "2021-01-27T01:10:36Z",
          "updatedAt": "2021-01-27T01:10:36Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Looks good to me \ud83d\ude42",
          "createdAt": "2021-01-27T09:09:50Z",
          "updatedAt": "2021-01-27T09:09:50Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "i don't see the reason why not use exactly the same identifiers as in the spec, but i guess it's good enough.",
          "createdAt": "2021-01-27T22:38:07Z",
          "updatedAt": "2021-01-27T22:38:07Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Some proposed changes from @chris-wood:\r\n- Remove the `credential_file` parameter entirely from the outputs.\r\n- Follow the rest of the draft with variable names and abandon things like `pk_u` in favor of `pkU`, `registration_request` -> `RegistrationRequest`, `oprf_key` -> `kU`\r\n\r\nLet me know if there are any other suggestions, and I'll be happy to edit the top-level post \r\n",
          "createdAt": "2021-02-02T20:47:04Z",
          "updatedAt": "2021-02-02T20:47:04Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "thanks a lot!",
          "createdAt": "2021-02-03T21:56:16Z",
          "updatedAt": "2021-02-03T21:56:16Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "i'm a bit confused, why is this issue closed? looking at \r\nhttps://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#opaque-3dh-test-vector-1\r\nand at https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/poc/vectors/vectors.json i see a lot of parameters which i have no clue what they correspond to in the specification.",
          "createdAt": "2021-02-11T14:38:23Z",
          "updatedAt": "2021-02-11T14:38:23Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "huh. sorry, i see that the 3dh part does name some of these values as in the testvectors. will check the consistency of those.",
          "createdAt": "2021-02-11T15:03:30Z",
          "updatedAt": "2021-02-11T15:03:30Z"
        }
      ]
    },
    {
      "number": 120,
      "id": "MDU6SXNzdWU3OTE1MDgwMzE=",
      "title": "Simplifying envelope construction",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/120",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Here are a subset of the steps for envelope construction:\r\n\r\n```\r\n1. N = Unblind(blind, response.data)\r\n2. y = Finalize(pwdU, N, \"OPAQUE01\")\r\n3. rwdU = HKDF-Extract(\"rwdU\", Harden(y, params))\r\n4. Create SecretCredentials secret_creds with creds.skU\r\n5. Create CleartextCredentials cleartext_creds with response.pkS\r\n   and custom identifiers creds.idU and creds.idS if mode is customIdentifier\r\n6. nonce = random(32)\r\n7. pseudorandom_pad = HKDF-Expand(rwdU, concat(nonce, \"Pad\"), len(pt))\r\n8. auth_key = HKDF-Expand(rwdU, concat(nonce, \"AuthKey\"), Nh)\r\n9. export_key = HKDF-Expand(rwdU, concat(nonce, \"ExportKey\"), Nh)\r\n...\r\n```\r\n\r\nCan we instead change this to:\r\n```\r\n3. nonce = random(32)\r\n4. rwdU = HKDF-Extract(nonce, Harden(y, params))\r\n5. Create SecretCredentials secret_creds with creds.skU\r\n6. Create CleartextCredentials cleartext_creds with response.pkS\r\n   and custom identifiers creds.idU and creds.idS if mode is customIdentifier\r\n7. pseudorandom_pad = HKDF-Expand(rwdU, \"Pad\", len(pt))\r\n8. auth_key = HKDF-Expand(rwdU, \"AuthKey\", Nh)\r\n9. export_key = HKDF-Expand(rwdU, \"ExportKey\", Nh)\r\n```\r\n?\r\n\r\nAdditionally, we could consider bundling up steps 7-9 into a single HKDF-Expand call, and taking slices of that output for each of the individual variables.",
      "createdAt": "2021-01-21T21:30:46Z",
      "updatedAt": "2021-02-02T19:52:20Z",
      "closedAt": "2021-02-01T14:31:15Z",
      "comments": [
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Replacing the static salt with the nonce, does is change any security property except added entropy ?",
          "createdAt": "2021-01-21T23:19:18Z",
          "updatedAt": "2021-01-21T23:19:18Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, we are actually moving the incorporation of the nonce from steps 7-9 into step 3, so I don't think this is actually adding entropy. The only thing it accomplishes is removing the need for the static salt \"rwdU\".",
          "createdAt": "2021-01-22T02:58:17Z",
          "updatedAt": "2021-01-22T02:58:17Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "If I'm not mistaken, until now rwdu was not derived from the nonce. What I mean is that the nonce has more entropy than the string \"rwdu\" :)",
          "createdAt": "2021-01-22T08:55:20Z",
          "updatedAt": "2021-01-22T08:55:20Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "It is true that the rwdU will have more entropy now, but the only uses of `rwdU` in the current protocol are to be used to derive `pseudorandom_pad`, `auth_key`, and `export_key`, all of which incorporate the nonce into the HKDF. That's all I meant by saying that the overall entropy is the same.",
          "createdAt": "2021-01-22T18:07:27Z",
          "updatedAt": "2021-01-22T18:07:27Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Would it therefore be necessary to keep using the nonce in these HKDF derivations ? \nThe harden function could output something the length of rwdu + nonce, and that would be fed into the HKDF expansions.",
          "createdAt": "2021-01-23T23:42:56Z",
          "updatedAt": "2021-01-23T23:42:56Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "what would be the benefit of\r\n\r\n> Additionally, we could consider bundling up steps 7-9 into a single HKDF-Expand call, and taking slices of that output for each of the individual variables.\r\n?",
          "createdAt": "2021-01-24T20:04:05Z",
          "updatedAt": "2021-01-24T20:04:05Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "and what is the benefit of having the nonce included earlier in this procedure?",
          "createdAt": "2021-01-24T20:04:35Z",
          "updatedAt": "2021-01-24T20:04:35Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@bytemare I think there is a security benefit to having the nonce being chosen independently of the output of the harden function, actually. It means that if a (kU, pwdU) pair were reused for multiple users, we would still get independent export keys / auth keys / pseudorandom_pads.\r\n\r\n@stef: The only benefit is that we remove the need for a fixed string \"rwdU\" from this computation, and slightly simplify steps 7/8/9 to not involve concatenation of any strings.\r\n\r\nThis should not have any impact on anything except for simplicity.\r\n\r\nBumping this for @chris-wood / @hugokraw for comments",
          "createdAt": "2021-01-27T01:04:05Z",
          "updatedAt": "2021-01-27T01:04:05Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "simplification, and not concatenating strings is a very good reason to do this. thumbsup!",
          "createdAt": "2021-01-27T01:07:02Z",
          "updatedAt": "2021-01-27T01:07:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this suggestion a lot, with one exception: I'd prefer we keep the expand calls separate. There were, in the past, issues where the attacker played with the expand parameters to try and recover the secrets. Keeping them separate helps not reintroduce that issue.",
          "createdAt": "2021-01-30T15:25:06Z",
          "updatedAt": "2021-01-30T15:25:06Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "@kevinlewi I understood this :) what I meant is to not keep using the nonce in HKDF-Expand.\r\nLike so https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/126/commits/00810795fa60f5a5e77cee205d1e698d3b533077#diff-09a16f0dd79bfde63faf766f3c58ba43f6795026ce020fa36006cfec7094cf0aR642",
          "createdAt": "2021-01-31T21:45:31Z",
          "updatedAt": "2021-01-31T21:45:31Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "General  comment: I appreciate that you guys add @hugokraw when discussing stuff that needs my attention. But since my attention these days is divided into so many things, please double check with me before approving any such crypto-relevant changes if I do not provide feedback.\r\n\r\nRegarding involving the nonce into the derivation of RwdU: I am ok with it. The reason Nonce was used in the derivation of pad is for the (not too common but possible case) that someone would re-register same PwdU (and without the server changing kU), but would change the registered skU. If this happened, one would be using the same pad to encrypt two different plaintexts.  But the proposed change is correct: Once you use the nonce to modify the RwdU derivation there is no need to include the nonce in the derivation of pseudorandom_pad as long as Nonce is chosen anew each time a password is registered (or re-registered). \r\n\r\nLastly, there was a comment in this thread about the nonce helping in the case of different users using the same password and same kU by the server. A server should  never use the same kU with two different users. We may want to add such remark in the security considerations and also around the place where we specify the choice of kU.  \r\n",
          "createdAt": "2021-02-01T05:01:19Z",
          "updatedAt": "2021-02-01T05:01:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Lastly, there was a comment in this thread about the nonce helping in the case of different users using the same password and same kU by the server. A server should never use the same kU with two different users. We may want to add such remark in the security considerations and also around the place where we specify the choice of kU.\r\n\r\nGood idea -- I'll make a note of this and address it in a future change.",
          "createdAt": "2021-02-01T13:36:33Z",
          "updatedAt": "2021-02-01T13:36:33Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "> as long as Nonce is chosen anew each time a password is registered (or re-registered)\r\n\r\nThis should be specified as well. Servers must ensure that the client doesn't reuse nonces. In practice, this means the server must retain these nonce (or a fingerprint) and validate new ones on each (re)-registration.",
          "createdAt": "2021-02-02T15:31:05Z",
          "updatedAt": "2021-02-02T16:56:37Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "This needs to be specified but enforcement does not need to go all the way as you suggest. As long as the server chooses random independent keys for different users, the nonce in the envelope is of limited consequences (you only need it for the case where the user re-registers, does not change the password but chooses a new secret keys skU and the server does not change the user's OPRF key; and even then the damage of repeating or omitting the nonce is not very significant)",
          "createdAt": "2021-02-02T19:52:19Z",
          "updatedAt": "2021-02-02T19:52:19Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "MDU6SXNzdWU3OTE2NjUxMjc=",
      "title": "Change all occurrences of variable-length public/private keys to be fixed length?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/121",
      "state": "OPEN",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "In the current version of the draft, there are occurrences such as:\r\n\r\n```\r\nstruct {\r\n    SerializedElement data;\r\n    opaque pkS<1..2^16-1>;\r\n} RegistrationResponse;\r\n```\r\n\r\n```\r\nstruct {\r\n    opaque pkU<1..2^16-1>;\r\n    Envelope envU;\r\n} RegistrationUpload;\r\n```\r\n\r\nShould we change these to instead say:\r\n```\r\n    opaque pkS[LK];\r\n```\r\n\r\nwhere `LK` is a fixed constant dependent on the group representation?\r\n\r\n@chris-wood ",
      "createdAt": "2021-01-22T03:24:18Z",
      "updatedAt": "2021-02-09T05:48:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems fine, but I would say that `LK` is not a function of the *group*, but simply the fixed length of an AKE public key. @kevinlewi, could you please propose text?",
          "createdAt": "2021-02-05T23:56:36Z",
          "updatedAt": "2021-02-05T23:56:36Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "See my comment on #132 ",
          "createdAt": "2021-02-09T05:48:07Z",
          "updatedAt": "2021-02-09T05:48:07Z"
        }
      ]
    },
    {
      "number": 122,
      "id": "MDU6SXNzdWU3OTIzNDYyNDM=",
      "title": "envelope structure is not unambigious",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/122",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#credential-types-and-envelope-construction-data-types\r\n\r\ndefines the envelope as:\r\n```\r\nstruct {\r\n  InnerEnvelopeMode mode;\r\n  opaque nonce[32];\r\n  opaque encrypted_creds<1..2^16-1>;\r\n} InnerEnvelope;\r\n\r\nstruct {\r\n  InnerEnvelope contents;\r\n  opaque auth_tag[Nh];\r\n} Envelope;\r\n```\r\n\r\nwhy is the type of `encrypted_creds` `opaque` and not `SecretCredentials` as already defined right before this?\r\nthat `encrypted_creds` is actually `SecretCredentials` is only mentioned in the following \"prosa\" text.\r\n\r\nand then says this:\r\n\r\n> auth_tag : Authentication tag protecting the contents of the envelope, covering InnerEnvelope and CleartextCredentials.\r\n\r\nwhy is this `CleartextCredentials` not explicitly specified in the envelope struct?\r\n",
      "createdAt": "2021-01-22T22:27:03Z",
      "updatedAt": "2021-01-23T01:36:30Z",
      "closedAt": "2021-01-23T01:36:29Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> why is the type of encrypted_creds opaque and not SecretCredentials as already defined right before this?\r\n\r\n`encrypted_creds` is the *encrypted* form of `SecretCredentials`\r\n\r\n> why is this CleartextCredentials not explicitly specified in the envelope struct?\r\n\r\nNo cleartext credentials are included in the envelope -- they're only authenticated during the protocol (by being included in the MAC computation). ",
          "createdAt": "2021-01-22T23:54:36Z",
          "updatedAt": "2021-01-22T23:54:36Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "hmmm. that kind of makes sense, i guess i was mislead by the previous version and the context implied by that. ",
          "createdAt": "2021-01-23T01:36:29Z",
          "updatedAt": "2021-01-23T01:36:29Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "MDU6SXNzdWU3OTI4ODAwNTY=",
      "title": "bunch of questions - after a full reading of the latest draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/124",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "> 2OSP and OS2IP: Convert a byte string to and from a non-negative integer as described in {{?RFC8017}}.\r\n\r\nlink to https://tools.ietf.org/html/rfc8017#section-4.1 and https://tools.ietf.org/html/rfc8017#section-4.2\r\n\r\nperhaps also note that this is also known as the htons/ntohs functions in POSIX - implementors might find this very helpful!\r\n\r\n------- \r\n\r\n> kX: An OPRF private key used in role X. For example, kU refers to U's private OPRF key.\r\n\r\nis there any other role besides kU?\r\n\r\n------- \r\n\r\n> random(n): Generate a random byte string of length n bytes.\r\n\r\nnote that this random string should be of cryptographic quality. although there is a note under all the definitions saying so, it's better to have it closer where it matters and less ignored.\r\n\r\n\r\n------- \r\n\r\nin #cryptographic-protocol-and-algorithm-dependencies-dependencies\r\n\r\nthe note that only the base variant of the OPRF is needed is also a bit far away from where the OPRF dependency is specified.\r\n\r\n------- \r\n\r\n> auth_tag : Authentication tag protecting the contents of the envelope, covering InnerEnvelope and CleartextCredentials\r\n\r\nthen it notes:\r\n> The full procedure for constructing Envelope and InnerEnvelope from SecretCredentials and CleartextCredentials is described in {{finalize-request}}.\r\n\r\nwhich is:\r\n\r\n> 12. auth_tag = HMAC(auth_key, concat(contents, cleartext_creds))\r\n\r\nit's all there but quite dispersed spatially, someone trying to implement this has to jump around in the doc, it's very hard to read this spec sequentially.\r\n\r\n------- \r\n\r\n> Credential information corresponding to the configuration-specific mode, along with the user public key pkU and private key skU, are stored in a Credentials object with the following named fields:\r\n> skU, pkU, idU, idS\r\n\r\nit is not necessary to specify for interoperability how an implementation stores these values. also for security i think it is better to handle skU seperatately from the other values - or maybe not, depending on the configuration, if any of the other values is also to be kept secret. a sensible implementation wants to actually protect the sensitive values differently from the public values. maybe by storing them in mprotected/sanitized-after-use storage, in secure elements, or something else.\r\n\r\ni do see how it is a shortcut to list all the necessary items from the creds struture as an input to finalizerequest though.\r\n\r\n> Clients MUST NOT use the same key pair (skU, pkU) for two different accounts.\r\n\r\nwhy is this, when the server can use the same keypair for different accounts? in the case when idU == pkU this is not even possible i guess.\r\n\r\n------\r\n\r\n> pkS : An encoded public key that will be used for the online authenticated key exchange stage.\r\n\r\nadd explicitly that this is the *servers* pubkey\r\n\r\nsimilarly be explicit also about this:\r\n\r\n> pkU : An encoded public key, corresponding to the private key skU.\r\n\r\n-------\r\n\r\n#credential-file\r\n\r\nwe agree these things need to be persisted, however i do not see how this helps interoperability or security specifying this struct. i propose to change the wording to something like:\r\n\r\nthe server needs to be able to reproduce the following values for the online phase.\r\n\r\nan implementation might choose to generate kU by doing a KDF on some global secret value in combination with idU for example, then this storage of kU can be skipped. again we should realize that kU is a sensitive value which needs protection (like sanitization, possibly also at-rest encryption, not being swapped to disk, stored in a secure element, etc) while envU is an encrypted blob that does not need these kind of protections. in case pkU == idU it might be possbile that envU is stored in a hashdictionary that is indexed by idU, and thus pkU does not need to be stored at all. lumping these values together and requiring them to be stored in this structure creates unnecessary limitations on implementations. while this specification might harm security, it does not really improve interoperability.\r\n\r\neither delete this section, or make this optional, and put it into an non-binding appendix.\r\n\r\nanother thing against this, is the usage of export-keys, in case an implementation chooses to encrypt data with an export-key but wants to stay stateless on the client, then the export-key encrypted data might also be stored on the server.\r\n",
      "createdAt": "2021-01-24T20:01:04Z",
      "updatedAt": "2021-02-13T17:56:42Z",
      "closedAt": "2021-02-13T17:56:42Z",
      "comments": []
    },
    {
      "number": 128,
      "id": "MDU6SXNzdWU3OTc5MjE0MDg=",
      "title": "HMQV and SIGMA to an Appendix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/128",
      "state": "CLOSED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "next-version"
      ],
      "body": "I want the HMQV and SIGMA specification to appear in an appendix. It serves as illustration and guidance for these and other instantiations.  Note that there is text referring to these protocols (e.g., introduction) that needs to be updated.",
      "createdAt": "2021-02-01T03:41:32Z",
      "updatedAt": "2021-02-05T21:00:08Z",
      "closedAt": "2021-02-05T21:00:08Z",
      "comments": []
    },
    {
      "number": 129,
      "id": "MDU6SXNzdWU3OTg0NDUxMjI=",
      "title": "Clarify OPRF mode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/129",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "OPAQUE only requires the OPRF \"base\" mode, which does not have evaluation verification.",
      "createdAt": "2021-02-01T15:14:46Z",
      "updatedAt": "2021-02-03T00:40:47Z",
      "closedAt": "2021-02-03T00:40:46Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Isn't this already addressed here, at the top of the \"Configurations\" section:\r\n\r\n> An OPAQUE configuration is a tuple (OPRF, Hash, MHF, EnvelopeMode). The OPAQUE OPRF protocol is drawn from the \"base mode\" variant of {{I-D.irtf-cfrg-voprf}}",
          "createdAt": "2021-02-03T00:39:35Z",
          "updatedAt": "2021-02-03T00:39:35Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing after agreement offline with @chris-wood ",
          "createdAt": "2021-02-03T00:40:46Z",
          "updatedAt": "2021-02-03T00:40:46Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "MDU6SXNzdWU3OTg0NTEyMTA=",
      "title": "Elaborate on export_key usage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/130",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "Applications can use export_key in a variety of ways (after OPAQUE completes successfully). The draft should describe some of these in more detail, perhaps in an appendix to keep the main body of text slim.\r\n\r\ncc @rot256",
      "createdAt": "2021-02-01T15:21:00Z",
      "updatedAt": "2021-02-03T20:16:23Z",
      "closedAt": "2021-02-03T20:16:23Z",
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Here is one sample text that we could add to the appendix:\r\n\r\n> The export key can be used (separately from the OPAQUE protocol) to provide confidentiality and integrity to other data which only the client should be able to process. For instance, if the server is expected to maintain any client-side secrets which require a password to access, then this export key can be used to encrypt these secrets so that they remain hidden from the server.\r\n\r\nThis only describes one application, but it is the main application that comes to mind for me.",
          "createdAt": "2021-02-02T00:49:34Z",
          "updatedAt": "2021-02-02T00:49:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi, could you please throw this up in a PR? I think the proposed text is just right.",
          "createdAt": "2021-02-02T01:10:27Z",
          "updatedAt": "2021-02-02T01:10:34Z"
        }
      ]
    },
    {
      "number": 131,
      "id": "MDU6SXNzdWU3OTg0Njg1MjM=",
      "title": "Static DH oracle text",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/131",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "We should ensure that we acknowledge this type of attack in theory, and describe how OPAQUE deals with it. In particular, since each OPRF key is per-user, which means that any reduction in security is per-user, which is unlikely to be a problem in practice.",
      "createdAt": "2021-02-01T15:39:48Z",
      "updatedAt": "2021-02-06T00:00:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "There is text in the security considerations section about this but it contains an error: A later paper by Cheon shows that one does not need the exponential memory. Also, we need to provide a reference to Taylor Campbel's comprehensive note on this. It is also worth noting Loup Vaillant observation on communication time (with the OPRF server), lower bounded by speed of light, given that this attack is inherently sequential. Maybe you will summarize these things in the OPRF draft and then we only refer to the fact that in OPAQUE kU is per user so this (anyway infeasible) attack would be directed to enable a dictionary attack against a single user.",
          "createdAt": "2021-02-01T19:52:32Z",
          "updatedAt": "2021-02-01T19:52:32Z"
        }
      ]
    },
    {
      "number": 132,
      "id": "MDU6SXNzdWU3OTg1NDc5OTA=",
      "title": "HKDF-Expand limits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/132",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "RFC 5869 limits the output length of Expand to 255*HashLen, but the envelope ciphertext has a larger capacity. (In theory, HKDF can produce any number of bytes, but we should abide by the interface limitations.) ",
      "createdAt": "2021-02-01T17:13:19Z",
      "updatedAt": "2021-02-09T18:12:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you have a suggestion for how we should address this? The only way in which our outputs might need to be variable size would be if we support super long key lengths, right? But this doesn't seem like it would happen based on the configurations / ciphersuites we plan to support.\r\n\r\nUnless I am missing something?",
          "createdAt": "2021-02-02T00:46:20Z",
          "updatedAt": "2021-02-02T00:46:20Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "After some offline discussion: in order to address this, we will limit all opaque key types to be at most 255 bytes instead of 2^16-1.",
          "createdAt": "2021-02-03T02:07:28Z",
          "updatedAt": "2021-02-03T02:07:28Z"
        },
        {
          "author": "rot256",
          "authorAssociation": "NONE",
          "body": "That is not enough for a 2048-bit RSA key.\r\n\r\n> Each public and private key value is an opaque byte string, specific\r\n> to the AKE protocol in which OPAQUE is instantiated.  For example, if\r\n> used as raw public keys for TLS 1.3 [RFC8446], they may be RSA or\r\n> ECDSA keys as per [RFC7250]\r\n\r\nDoes this mean that the spec bans the use of RSA?",
          "createdAt": "2021-02-03T18:41:09Z",
          "updatedAt": "2021-02-03T18:41:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> That is not enough for a 2048-bit RSA key.\r\n\r\nThis is an interesting point, but as I see it, one could just seed a PRNG with the secret bytes in the envelope. (This is related to #84.) Of course, I Am Not A Cryptographer, so perhaps this is bad practice? \ud83e\udd37 ",
          "createdAt": "2021-02-03T19:01:13Z",
          "updatedAt": "2021-02-03T19:01:13Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Deterministic generation of RSA keys is non-standard, and the tricks and hacks to make it work are quite \"roll your own\".",
          "createdAt": "2021-02-03T19:07:39Z",
          "updatedAt": "2021-02-03T19:07:39Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood : I think the current direction we are taking is to not support RSA keys, which means that the text that @rot256 linked to should be removed. Thoughts?\r\n\r\nThe group representations we *are* supporting are listed out in the Configurations section (https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/draft-irtf-cfrg-opaque.md#configurations-configurations) and those should all fit within the 255-byte limit.\r\n\r\nEdit: Additionally, In response to:\r\n\r\n> one could just seed a PRNG with the secret bytes in the envelope\r\n\r\nI am not so much a fan of allowing for flexibility in what goes in the secret bytes in the envelope, and hence I do not see a need for considering this. In my opinion, applications that wish to use the secrecy provided by OPAQUE can do so with the export_key parameter.",
          "createdAt": "2021-02-03T19:23:54Z",
          "updatedAt": "2021-02-03T19:26:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood : I think the current direction we are taking is to not support RSA keys, which means that the text that @rot256 linked to should be removed. Thoughts?\r\n\r\nYep, I think that's right. RSA is incompatible with 3DH anyway. For the SIGMA-I variant, we would need to make it clear that the envelope structure or its encryption mechanism would need to change. (Given that we don't have a use case for SIGMA-I right now, I think I'm fine with this outcome.)\r\n\r\n@hugokraw, one consequence of the change proposed in this issue is that it would limit OPAQUE-EA instantiations to non-RSA keys. I quite like this as a forcing function away from RSA, though I'm curious to hear your thoughts. \r\n\r\n> I am not so much a fan of allowing for flexibility in what goes in the secret bytes in the envelope, and hence I do not see a need for considering this. In my opinion, applications that wish to use the secrecy provided by OPAQUE can do so with the export_key parameter.\r\n\r\nI wasn't envisioning this being a flexible thing. I was suggesting that, rather than the envelope store the raw private key, it store a seed used to deterministically derive the key. In any case, that's a separate change if we are to make it, likely as part of #84.",
          "createdAt": "2021-02-03T19:30:35Z",
          "updatedAt": "2021-02-03T19:32:09Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> RFC 5869 limits the output length of Expand to 255*HashLen, but the envelope ciphertext has a larger capacity. (In theory, HKDF can produce any number of bytes, but we should abide by the interface limitations.)\r\n\r\nThis is an example of a tradeoff between simplicity and flexibility for future use.  I am all for simplicity but extensibility mechanisms have always proved useful in long-lived protocols. The discussion on the info fields we are having here illustrates this issue.\r\n\r\nPhilosophy apart, one can generate more than 255 octets with HKDF-Expand by calling HKDF-Expand(prk, \"Block 1\"), HKDF-Expand(prk, \"Block 2\"), etc., where each block contains 255 bytes.\r\n",
          "createdAt": "2021-02-04T18:48:06Z",
          "updatedAt": "2021-02-04T18:48:06Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> After some offline discussion: in order to address this, we will limit all opaque key types to be at most 255 bytes instead of 2^16-1.\r\n\r\nThis may not be sufficient for some post-quantum algorithms, including lattice-based constructions and hash-based signatures, or RSA (even 2048 needs 256 bytes).  There is always the option to only encrypt a seed to a PRG/PRF that generates the randomness from which one generates the private key (e.g., for RSA  you would encrypt two 256 values whose PRG expansions give you the primes that form your the private key). More precisely and more generally, the encrypted value is a seed to the key generation procedure). How time consuming this generation is depends on the PK scheme.  \r\nNote that long public keys (that cannot be compressed as in the case of private keys above) is not a problem since they do not need to be encrypted.",
          "createdAt": "2021-02-04T19:02:39Z",
          "updatedAt": "2021-02-04T19:02:39Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Deterministic generation of RSA keys is non-standard, and the tricks and hacks to make it work are quite \"roll your own\".\r\n\r\nI sent the previous response without reading the full thread so I am repeating some stuff people were already saying. The issue is not deterministic generation but expansion of a seed to a full key generation. Note that any key generation starts from a seed to a PRG so this technique is quite universal. Where the tricks come into play is for reducing the cost of key generation (that in our case happens online during user authentication). It is not the end of the world and hopefully not too much of an issue with RSA (whose coming the the end of its life) but it can be an issue with lattice based and other PQ algorithms.",
          "createdAt": "2021-02-04T19:07:43Z",
          "updatedAt": "2021-02-04T19:07:43Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Yes, you're totally right, I was wrong in using that term, as I meant exactly what you described marvelously good. Thank you !\n\nAs for such a key reproduction for RSA, do you know about an acceptable method to reduce the cost to something acceptable if it reveals to be an issue ? (E.g. run in-browser on low power device)",
          "createdAt": "2021-02-07T22:35:54Z",
          "updatedAt": "2021-02-07T22:35:54Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not an expert on what implementations do these days for selecting random primes. But if we assume that primes are chosen by choosing a random value and testing for primality, then at time of password registration you would derive a PRF key P from rwdU. Then, test all values PRF_P(1), PRF_P(2), ... and choose the first two that are primes as your RSA primes. You can make the process of reconstructing the primes very efficient if you put in the envelope the positions i and j where the primes were found (these do not need to be encrypted).  ",
          "createdAt": "2021-02-07T22:49:49Z",
          "updatedAt": "2021-02-07T22:49:49Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "This was the method I was referencing to, but I'm not aware how \"standard\" it is (if it needs to be) or about reference paper on this. (Also, I'm always wary around RSA)",
          "createdAt": "2021-02-07T23:00:50Z",
          "updatedAt": "2021-02-07T23:00:50Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "In #121, the proposal is actually to use fixed-length keys instead of variable ones. This means that rather than limiting the maximum key size to be 255 bytes as I wrote earlier, we would instead use a parameter (e.g. `Nk`) to denote the key size, which could be set by the particular ciphersuite.\r\n\r\nI believe this means that we can defer the conversation of whether or not PQ algorithms or RSA would be restricted by this 255-byte limit, since such future specifications could simply set the `Nk` value to whatever is appropriate.\r\n\r\nSee the new comment I appended to the PR here (https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/137#issuecomment-774785807) which should incorporate this.",
          "createdAt": "2021-02-07T23:11:37Z",
          "updatedAt": "2021-02-07T23:13:28Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought that the concern was that HKDF limits the output to 255*HashLen and one could presumably have some algorithms that would require a larger private key (but see below). How does fixing the length of the key to some parameter addresses this issue? if Nk is shorter than 255*HashLen then there wasn't a problem to start with and if it is larger then you still have an issue with HKDF not producing enough bits for the encryption pad.  I must be misunderstanding this.\r\n\r\nBtw, I got confused earlier in this thread when I said we have a limit of 255 bytes for the HKDF pad (hence for the private key). The limit is 255*HashLen bytes which for a minimal hashlen of 32 bytes gives 255*32 bytes =65,280 bits or almost 65KB which does not seem too restrictive. ",
          "createdAt": "2021-02-09T05:46:28Z",
          "updatedAt": "2021-02-09T05:46:28Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "So, the problem that we are discussing originates from lines like this:\r\n\r\n```\r\nstruct {\r\n  opaque client_private_key<1..2^16-1>;\r\n} SecretCredentials;\r\n```\r\n\r\nIt says that the `client_private_key` value is allowed to be of any length between 1 and 2^16-1 bytes. However, because this value is eventually fed into an HKDF computation, if it were to actually be 2^16-1 bytes long, we would run into conflict with the HKDF limitations.\r\n\r\nSo, a couple of options for resolving this issue:\r\n- Limit the size of this value to be between 1..2^8-1 bytes long. This would save us 1 byte on the length-prefixing of this value, and would resolve the HKDF limitation issue, but as you pointed out, this could be too restrictive for future PQ/RSA-based values.\r\n- Limit the size of this value to be at most 25532 bytes long. This could work too (as it gets around the HKDF limitation issue, and should be large enough for future PQ/RSA-based values), but it seems a bit inelegant to hardcode this value.\r\n- Restrict this value to be exactly `Nk` bytes long, where `Nk` would be a parameter configured based on the ciphersuite selection. As discussed in #121, these key values don't need to be of variable-length size anyway, and so I think it would be most elegant to just rely on the configuration specifying exactly what `Nk` is, and **ensuring, when we propose new configurations, that no configuration specifies an `Nk` that exceeds the HKDF limitations**. So for example, `Nk` for Ristretto-Sha512 would be set to `32`, and maybe a future PQ/RSA-based scheme could pick a larger `Nk`.\r\n\r\nAlso, restricting the value to be exactly `Nk` bytes long means that we no longer have to length-prefix these currently variable-length values (thus saving 1-2 bytes on the wire).\r\n\r\nHope that makes sense @hugokraw!",
          "createdAt": "2021-02-09T12:49:42Z",
          "updatedAt": "2021-02-09T12:51:38Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Your solution does not address the real issue here which is the limit of 8160 bytes imposed by HKDF. To me it makes more sense to have this as a limit instead of asking to configure the exact number. The latter reduces flexibility that future applications may want to have without much gain.  But, as always, for decisions that do not have a significant security/cryptography implication, I delegate to you guys.",
          "createdAt": "2021-02-09T18:12:06Z",
          "updatedAt": "2021-02-09T18:12:06Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "MDU6SXNzdWU3OTk4NDUxMTM=",
      "title": "Rename all instances of \"user\" and \"U\" to \"client\" and \"C\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/134",
      "state": "CLOSED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kevinlewi"
      ],
      "labels": [],
      "body": "Per discussion with @chris-wood \r\n\r\nOpen to feedback / objections for this!",
      "createdAt": "2021-02-03T00:38:07Z",
      "updatedAt": "2021-02-03T20:27:18Z",
      "closedAt": "2021-02-03T20:27:18Z",
      "comments": []
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWU4MDU5NjQ5Mjk=",
      "title": "KE2 and KE3 transcript mac pre-hashing",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/142",
      "state": "OPEN",
      "author": "bytemare",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the poc, KE2 and KE3 have their transcript hashed before feeding it into the HMAC\r\n\r\nKE2 https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/poc/opaque_ake.sage#L160\r\nKE3 https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/master/poc/opaque_ake.sage#L207\r\n\r\nBut the draft doesn't mention these pre-hashing steps. This changes the HMAC output, thus don't conform with the design in the draft.\r\ncc @chris-wood and @kevinlewi",
      "createdAt": "2021-02-10T23:39:42Z",
      "updatedAt": "2021-02-10T23:39:42Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 143,
      "id": "MDU6SXNzdWU4MDY0NDQzMDI=",
      "title": "follow rfc2119 to indicate requirement levels",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/143",
      "state": "CLOSED",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "rfcs generally refer and use https://tools.ietf.org/html/rfc2119 to define requirement levels. this spec should follow that tradition diligently. ",
      "createdAt": "2021-02-11T14:33:06Z",
      "updatedAt": "2021-02-13T18:05:18Z",
      "closedAt": "2021-02-13T17:57:56Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "RFC2119 [is already cited](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#section-1.1) for the purposes of requirement and normative language.",
          "createdAt": "2021-02-13T17:57:56Z",
          "updatedAt": "2021-02-13T17:57:56Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "aaah. i didn't see this in the source markdown file.",
          "createdAt": "2021-02-13T18:05:18Z",
          "updatedAt": "2021-02-13T18:05:18Z"
        }
      ]
    },
    {
      "number": 146,
      "id": "MDU6SXNzdWU4MDc4MzIzOTk=",
      "title": "Inconsistency between OPRF ciphersuites in draft-irtf-cfrg-voprf and draft-irtf-cfrg-opaque",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/146",
      "state": "OPEN",
      "author": "rot256",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "draft-irtf-cfrg-voprf lists the following OPRF  instanciations:\r\n\r\n\r\n  OPRF(ristretto255, **SHA-256**)\r\n  OPRF(decaf448, SHA-512) \r\n  OPRF(P-256, SHA-256)\r\n  OPRF(P-384, SHA-512)\r\n  OPRF(P-521, SHA-512)\r\n\r\nHowever section 5 of draft-irtf-cfrg-opaque, says:\r\n\r\n\r\n   An OPAQUE configuration is a tuple (OPRF, Hash, MHF, EnvelopeMode).\r\n   The OPAQUE OPRF protocol is drawn from the \"base mode\" variant of\r\n   [I-D.irtf-cfrg-voprf].  The following OPRF ciphersuites are\r\n   supported:\r\n\r\n   *  OPRF(ristretto255, **SHA-512**)\r\n   *  OPRF(decaf448, SHA-512)\r\n   *  OPRF(P-256, SHA-256)\r\n   *  OPRF(P-384, SHA-512)\r\n   *  OPRF(P-521, SHA-512)\r\n\r\nIt seems like it should be SHA-256 in both places (targeting 128-bits of security)?",
      "createdAt": "2021-02-13T21:25:17Z",
      "updatedAt": "2021-02-13T21:25:40Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5NTMwNTY4",
      "title": "Cleanup the document.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/1",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-18T14:14:15Z",
      "updatedAt": "2020-05-18T14:14:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "141e15efee0a73c14ce1d9766c591e7fd974dba9",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/cleanup",
      "headRefOid": "1f060a625d001ec1e9ba4cfcc1ba25c23a8b7742",
      "closedAt": "2020-05-18T14:14:21Z",
      "mergedAt": "2020-05-18T14:14:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3b004d0e822b3bdb0d3e2c42eefcadf4c1c5c0c6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMjMzOTc1",
      "title": "Fixed typo in K3dh definition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/10",
      "state": "MERGED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #8",
      "createdAt": "2020-05-19T16:34:15Z",
      "updatedAt": "2020-05-19T16:43:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "3b004d0e822b3bdb0d3e2c42eefcadf4c1c5c0c6",
      "headRepository": "hugokraw/draft-irtf-cfrg-opaque",
      "headRefName": "patch-1",
      "headRefOid": "5a5d843c37034a6bddab4de46951382be9761480",
      "closedAt": "2020-05-19T16:43:28Z",
      "mergedAt": "2020-05-19T16:43:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e73d7287709206ea755e23e6369e989b16bea940"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjMzMzE3",
          "commit": {
            "abbreviatedOid": "5a5d843"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-19T16:43:22Z",
          "updatedAt": "2020-05-19T16:43:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMjQxNTk0",
      "title": "Minor fix",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/11",
      "state": "MERGED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-19T16:48:47Z",
      "updatedAt": "2020-05-19T17:02:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e73d7287709206ea755e23e6369e989b16bea940",
      "headRepository": "hugokraw/draft-irtf-cfrg-opaque",
      "headRefName": "patch-1",
      "headRefOid": "0d9b5d801cf2d87dd7d6e575a75780acf174457f",
      "closedAt": "2020-05-19T17:02:19Z",
      "mergedAt": "2020-05-19T17:02:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "64e188b1197d555f14a4358bde2d9541b056b956"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjQ4MzUz",
          "commit": {
            "abbreviatedOid": "0d9b5d8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-19T17:02:13Z",
          "updatedAt": "2020-05-19T17:02:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxMTIyMjUw",
      "title": "Apply Hugo's changes.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/12",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @hugokraw ",
      "createdAt": "2020-05-21T03:04:11Z",
      "updatedAt": "2020-05-21T13:24:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "64e188b1197d555f14a4358bde2d9541b056b956",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hugo-branch",
      "headRefOid": "5514ae0638c28572bc0ea06dfbbaf0a8ca71591e",
      "closedAt": "2020-05-21T13:24:21Z",
      "mergedAt": "2020-05-21T13:24:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9cef30edba1afce5701546450fa5be004e87fdd5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxNDUwODQ5",
      "title": "Add self as an author.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/13",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-21T16:25:28Z",
      "updatedAt": "2020-05-21T21:32:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "9cef30edba1afce5701546450fa5be004e87fdd5",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/author",
      "headRefOid": "5a7be151b0db2b30242c4973bcfa13b24fe170ce",
      "closedAt": "2020-05-21T21:32:59Z",
      "mergedAt": "2020-05-21T21:32:58Z",
      "mergedBy": "hugokraw",
      "mergeCommit": {
        "oid": "1a45065d3f8ef7617093b9e36d874a20f5d5a2ca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTA4MjU2",
          "commit": {
            "abbreviatedOid": "5a7be15"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Welcome Chris :-)",
          "createdAt": "2020-05-21T21:31:57Z",
          "updatedAt": "2020-05-21T21:31:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxNDUyNDc3",
      "title": "Address Eric's comments.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/14",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #9.",
      "createdAt": "2020-05-21T16:28:33Z",
      "updatedAt": "2020-05-21T21:27:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "9cef30edba1afce5701546450fa5be004e87fdd5",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/eric-comments",
      "headRefOid": "39be24df302cfce0bcc0ef9d66d4281ab1fd5ef8",
      "closedAt": "2020-05-21T21:27:52Z",
      "mergedAt": "2020-05-21T21:27:52Z",
      "mergedBy": "hugokraw",
      "mergeCommit": {
        "oid": "5bbe4a7e6e1b3938dd78ebe25470246301cf0418"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTA1MTE4",
          "commit": {
            "abbreviatedOid": "39be24d"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm good with #14 resolution (Eric comments)",
          "createdAt": "2020-05-21T21:27:22Z",
          "updatedAt": "2020-05-21T21:27:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIyMjg1MzU1",
      "title": "Initial draft of wire format messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change shuffles around content and replaces the text-based protocol descriptions with protocol flows and messages. It also includes a first cut at wire format details for these messages. (We can always iterate later on!) \r\n\r\ncc @hugokraw \r\n",
      "createdAt": "2020-05-23T14:58:59Z",
      "updatedAt": "2020-05-28T12:32:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "1a45065d3f8ef7617093b9e36d874a20f5d5a2ca",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/wire-formats",
      "headRefOid": "f9e7f430da7a35fcf3ec751927d31edcd9f0185a",
      "closedAt": "2020-05-28T12:32:08Z",
      "mergedAt": "2020-05-28T12:32:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "21de69f0b70488207df108cd25023ed421be24df"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Chris, I went over the specification text. Looks good (and a lot of\nwork).\nThanks!\n\nI have several comments. I was not sure how to better communicate this in\nthe\ngithub so pardon the use of 20th century technology here...\n\nComments are mostly in the order of appearance in the document, not by\norder of\nimportance.\n\n-- You say:\n> Client (U): Entity which has knowledge of a password and wishes to\nauthenticate.\nHere and in other places, including the naming of the online phase as the\n\"authentication\" phase, make this seem as just authentication when it is\nalso\nkey exchange. I have this note in the draft saying that authentication\nwithout\nkey exchange is \"analogous to carefully checking a visitor's credential at\nthe door and then leaving the door open for others to enter freely.\"\n\n-- The expression \"group key pair\" was unclear/confusing to me.\n\n-- Somewhere you say: \"Where noted, random choices can be replaced with\nfresh\noutputs from a cryptographically strong pseudorandom generator or\npseudorandom\nfunction.\"\n\nThe default is that we can replace randomness with pseudorandomness; we\nshould\nnote the cases where this is not the case and not the cases where\nreplacement is\nfine (essentially all cases).\n\n-- VOPRF: We never use the verifiability property; it would violate the\nPKI-freeness. We can use g^kU for fixed-base blinding but g^kU in this case\nis\nnot certified, just sent from server to client (possibly cached by the\nlatter)\n\n-- Fixed-base blinding: You are defining the OPRF with var-base blinding,\nnot\nleaving the option of fixed-base blinding (which would need to transfer\ng^kU).\n\n-- Generic OPRF vs DH-OPRF: This issue of blinding mechanisms points to the\nfact\nthat while all components of the protocol are generic in your\nspecification, the\nOPRF is fixed to DH-OPRF. I do not suggest complicating presentation too\nmuch\njust for the sake of being generic but I would definitely want to allow an\noptimization such as fixed-base blinding, and this may call for a more\ngeneral\nAPI (e.g., an OPRF structure with Request/Response).\n\n-- From the expression Open(k, n, aad, ct) I understand that you do not see\naad\nas part of ct. Is this right?\n\n-- In the OPRF ciphersuites there is no 256-bit curve. Why is that?\nIn the case of integration with TLS wouldn't we be using the curves TLS\nuses?\n\n-- In the hardening functions, shouldn't one allow for PBKDF for backward\ncompatibility reasons? I know of some company that wanted that exactly for\nthat\nreason.\n\n-- The Credentials structure: Setting it to the 4 elements as you define is\nfine\nand should cover common cases. However, pkU is usually not needed by the\nclient\n(that's the case for all the AKE examples I considered) so it may be\nremoved.\nThe public key pkS need not be encrypted but I assume we don't gain much by\nnot\nencrypting it. Do you mean to always encrypt all elements? And if so, why is\nthere a AAD field?\n\nI know we do not want to leave too many options but I would not want to\nprohibit\nthe encryption-less case where you only send the authenticated pkS (skS is\nderived from RwdU). The only place where I saw some benefit in AuCPace is\nthat\nthey had less bits in the wire. OPAQUE with the encryption-less option beats\nthem in that sense too. This mode also removes the annoying equivocable\nencryption property that we need in the UC analysis.\n\n--  When specifying the envelope encryption, I defined an optional key KdKey\nderived from RwdU for extended functionalities, e.g., as a way to retrieve\nnon-OPAQUE credentials (or to support the encryption-less option). We will\nsee\nhow we go about specifying the envelope encryption and then see what\nhappens to\nsuch KdKey.\n\n-- RwdU = Harden(y): This function should accept hardness parameters (or you\nassume they are part of the function definition)\n\n-- The name OPAQUE collides with \"opaque\" as an object type. Maybe say at\nthe\nbeginning that the name OPAQUE is always capitalized while the object type\nis\nnot (or don't say anything and trust the intelligence of the reader :-)\n\n-- You ask: should we blind both the identity and password?\n   Is the question whether IdU should be part of the input to the OPRF\n(together\n   with PwdU)? It is not necessary, I think, because kU is supposed to be\nunique\n   per user. Also, servers may use more than on IdU value to identify a\nuser or\n   use a value of IdU different than the one the user has (but we need some\n   agreement on the value of IdU for the sake of key derivation so maybe\nthis\n   would not be a problem if we wanted to use IdU as input to the OPRF).\n\n-- At registration the use chooses fresh keys (skU, pkU) =\nGenerateKeyPair().\n   Would it be possible that the user has a specific pair it wants to\nregister?\n   Maybe because it has a hardware token with these keys? But still uses the\n   envelope in case he left them at home...? WebAuth related?\n\n-- You say (regarding IdS): \"we should probably improve this a bit and\nprovide\n   guidance for where and how IdS is provisioned to clients\"\n   Probably such guidance is needed although there may be many use cases.\nOne\n   place where this id can be communicated is in the Response message from\nthe\n   server or in the envelope.\n\n-- Regarding the second stage you say: \"This stage is composed of a\nsequential\nOPRF and key exchange flow.\"\nDo not use the word sequential as we run them in parallel. In integration\nwith\nTLS we even start the KE part before the OPRF (exchanging DH values).\n\n-- \"client and server agree on the knowledge of the password and have\nmutually\nauthenticated one another\"\nThis is more like: Client proves user's knowledge of the password and agree\non a\nmutually authenticated shared secret key.\n\n-- In the online stage, should IdS be (at least an optional) input to the\nclient? It needs it to contact the server. Otoh, the name IdS used later in\nthe\nprotocol may be different than the one the client initially has for\ncontacting\nthe server, especially if IdS is communicated in the envelope.\n\n-- the context value is always derived as fresh randomness. However, it\nwould\nmake sense to set this value to the KE nonces (particularly in the case of\nTLS).\n\n-- Specification of the key-exchange protocol is out of scope for this\ndocument.\nThere is one point where the two components, OPRF and AKE, need to be bound\ntogether. This can be done by adding OPRF1 (what I call the value alpha) to\nthe\ndata authenticated by the KE. In the current specific, as I wrote it, all\nof the\nOPRF transcript (and even the envelope) is authenticated, not because this\nis\nneeded but because it is simpler to just add everything to the stream of\nauthenticated data. Anyway, the point is that this binding needs to be\naccommodated in gluing the OPRF and KE.\n\n-- Generic committed encryption. I am not convinced that the use of RKR here\njustifies a separate document. The main reason for having such document is\nbecause the trivial solution, namely, encrypt-then-CRmac (CRmac is any MAC\nthat\nis collision resistant), is slow for large pieces of data which is not the\ncase\nhere. I am afraid that such separate document will have much more complexity\nthat what's needed here, and we will end recommending using\nencrypt-then-hmac\nfor OPAQUE (it is the most robust mode for RKR encryption). I would have\nhoped\nto have a spec for it already but even defining it specifically for OPAQUE\nis\nnot a big deal. One issue is that given the popularity of GCM, people will\nwant\nto use it as the encryption part.  This is not a problem security-wise but\nwastes computation and bandwidth (not sure how serious this is). That's why\nI\ndefined standalone counter mode encryption (another self-contained spec I\ncould\nnot find).\n\n\n\nOn Sat, May 23, 2020 at 10:59 AM Christopher Wood <notifications@github.com>\nwrote:\n\n> This change shuffles around content and replaces the text-based protocol\n> descriptions with protocol flows and messages. It also includes a first cut\n> at wire format details for these messages. (We can always iterate later on!)\n>\n> cc @hugokraw <https://github.com/hugokraw>\n> ------------------------------\n> You can view, comment on, or merge this pull request online at:\n>\n>   https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17\n> Commit Summary\n>\n>    - Work in progress on the wire format details.\n>    - Merge branch 'master' of github.com:cfrg/draft-irtf-cfrg-opaque into\n>    caw/wire-formats\n>    - Finish online authentication phase.\n>\n> File Changes\n>\n>    - *M* draft-irtf-cfrg-opaque.md\n>    <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17/files#diff-49c06d6581f7de28ecde5fcfac409830>\n>    (929)\n>\n> Patch Links:\n>\n>    - https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17.patch\n>    - https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17.diff\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/17>, or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXSS5EXWDTICPK34XZDRS7QD7ANCNFSM4NIPH3UQ>\n> .\n>\n",
          "createdAt": "2020-05-24T16:07:56Z",
          "updatedAt": "2020-05-24T16:07:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI0NjczODg3",
      "title": "Generate nonces randomly.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/24",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #23.",
      "createdAt": "2020-05-28T19:01:02Z",
      "updatedAt": "2020-05-29T00:44:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "21de69f0b70488207df108cd25023ed421be24df",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/random-nonces",
      "headRefOid": "7d7a9bdc07b6bb8cb68336c2e92903fd3391034c",
      "closedAt": "2020-05-29T00:44:49Z",
      "mergedAt": "2020-05-29T00:44:49Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f39bcc8e8a4aceefeff19d778ceb4e6dcb0de1ec"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1MDkyMjQ4",
      "title": "Add HMQV key derivation changes.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/28",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #18.",
      "createdAt": "2020-05-29T13:06:33Z",
      "updatedAt": "2020-05-29T15:08:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f39bcc8e8a4aceefeff19d778ceb4e6dcb0de1ec",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hmqv-changes",
      "headRefOid": "2576ebb427c8bd9d189a2b6687c44f2dae839bfe",
      "closedAt": "2020-05-29T15:08:36Z",
      "mergedAt": "2020-05-29T15:08:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3a62bfb1ac0a1cc6e0d8f2492da0256724805be1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDQyMzUy",
          "commit": {
            "abbreviatedOid": "2576ebb"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-29T15:08:08Z",
          "updatedAt": "2020-05-29T15:08:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI4MDc4Mjgz",
      "title": "Replace Encode/Decode with Serialize/Deserialize.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/32",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is to match the VOPRF document, which uses Serialize/Deserialize. (Encode was also used as a type of Hash in hash-to-curve, so this is probably better.)",
      "createdAt": "2020-06-04T20:44:51Z",
      "updatedAt": "2020-06-05T16:00:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "41068ef6e0a02eed821764cc80ab8fe7fa084e32",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/encode-to-serialize",
      "headRefOid": "49033dd3d7167467e3ad9f7738160f4801e450be",
      "closedAt": "2020-06-05T16:00:44Z",
      "mergedAt": "2020-06-05T16:00:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7b2ac5fad20d031fedd697e5fe5ff2a75b245902"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1Mzk2Mjgz",
          "commit": {
            "abbreviatedOid": "49033dd"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-05T15:20:40Z",
          "updatedAt": "2020-06-05T15:20:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI4MTM3NTIw",
      "title": "Fix and relocate KdKey derivation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/33",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This moves derivation of the KdKey to the main protocol flow (outside of the RKR-AEAD algorithm), uses HKDF-Extract for secret derivation, and renames KdKey to exporter_key. ",
      "createdAt": "2020-06-04T23:17:51Z",
      "updatedAt": "2020-06-05T18:04:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "41068ef6e0a02eed821764cc80ab8fe7fa084e32",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/kdkey",
      "headRefOid": "f2dcf38c76c026d6b78b1195b9c48fd730691800",
      "closedAt": "2020-06-05T18:04:34Z",
      "mergedAt": "2020-06-05T18:04:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d4e6be35083e0280e749c87f6140ef1a13072f13"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I want to beef up the explanation of how the exporter_key may be used but no need to keep this open now.\r\n\r\nYeah, more text would certainly be useful. I figured we could do that in another PR. :-)",
          "createdAt": "2020-06-05T18:04:25Z",
          "updatedAt": "2020-06-05T18:04:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTEwNjQ2",
          "commit": {
            "abbreviatedOid": "f2dcf38"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It looks fine. I want to beef up the explanation of how the exporter_key may be used but no need to keep this open now. ",
          "createdAt": "2020-06-05T18:00:51Z",
          "updatedAt": "2020-06-05T18:00:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM0MzgwMTYz",
      "title": "Addressing minor grammar and typo fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/34",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Mostly addressing some minor grammar fixes and typos that I found during my pass.\r\n\r\nI also renamed \"xcript2\", \"xcript3\" to \"transcript2\" and \"transcript3\", feel free to push back on that.\r\n\r\nI noticed also that in some places it is referred to as \"xcript2\" and others it is \"xscript2\", at the very least those should be made consistent.",
      "createdAt": "2020-06-15T08:39:51Z",
      "updatedAt": "2020-12-16T09:54:46Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "b5894704b46ed915abf4d1c98734651caf59bb58",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "typo_fixes",
      "headRefOid": "245688a2d5779e7dd6b22d274e9ab439de59a299",
      "closedAt": "2020-06-15T14:23:27Z",
      "mergedAt": "2020-06-15T14:23:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "df8af66cf5dd6cf86c7c07fa7c853a6e7a42df44"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNjgyODcw",
          "commit": {
            "abbreviatedOid": "245688a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-06-15T14:12:19Z",
          "updatedAt": "2020-06-15T14:12:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 35,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NTc1MDM3",
      "title": "Add 256-bit curve suites.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/35",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We address static DH oracle attacks in the security considerations. Nothing to be worried about! :-)",
      "createdAt": "2020-06-17T03:12:09Z",
      "updatedAt": "2020-06-17T13:10:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "df8af66cf5dd6cf86c7c07fa7c853a6e7a42df44",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/oprf-suites",
      "headRefOid": "b2b814034fcd2863c1307d2bccf70850b9194ec9",
      "closedAt": "2020-06-17T13:10:39Z",
      "mergedAt": "2020-06-17T13:10:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5b15b1938e36d068e600eed46442ec3cb3317e9a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMDY4ODQ3",
          "commit": {
            "abbreviatedOid": "b2b8140"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good.",
          "createdAt": "2020-06-17T05:30:00Z",
          "updatedAt": "2020-06-17T05:30:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1OTY0MTE5",
      "title": "Remove RKR-AEAD dependency.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This removes the RKR-AEAD dependency in favor of a simpler OTP-like construction for credential secrecy. It also replaces redundant Extract calls on RwdU with Expand calls (RwdU is already assumed to be the output of a RO). Finally, it removes the `context` parameter from all protocol messages, punting that functionality to applications.",
      "createdAt": "2020-06-17T16:29:13Z",
      "updatedAt": "2020-06-18T23:04:26Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "5b15b1938e36d068e600eed46442ec3cb3317e9a",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/otp",
      "headRefOid": "7fa14ae888c0edc05973148faee435b0a2fd3396",
      "closedAt": "2020-06-18T23:04:26Z",
      "mergedAt": "2020-06-18T23:04:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ed6bbd3cbffa33a78dd3c03369423d3280a11023"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Chris, I have several comments/corrections for PR #36.\nLet me know if there is a better way to communicate such things in github\nrather than as an email.\n\nHere is a list (items marked by *)\n\nLet me know if you have questions or need more clarity on these issues.\n\n\n* Question (pure curiosity): What was the functionality of the \"context\"\nvalue\nwhat was context\n\n* Line 642: Envelope is defined as an encryption of a Credentials\nstructure, but\n  encryption is only required for skU. Maybe \"an authenticated encoding\"\ninstead\n  of encryption, since everything in it requires authentication.\n\n(same appears in line 821)\n\n* params, the MHF parameters established out of band\n\nShouldn't we allow for params to be communicated by the server to client\n(this\nwould be another potential element of Envelope)\n\n* Calculation of keys using HKDF-Expand (lines 720..., also 891...)\n\nHere is how the calculation should look:\n\npseudorandom_pad = HKDF-Expand(Key=RwdU, info = nonce | \"Pad\", len(pt))\nauth_key         = HKDF-Expand(Key=RwdU, info = nonce | \"AuthKey\", Na)\nexporter_key     = HKDF-Expand(Key=RwdU, info = nonce | \"ExporterKey\", Ne)\n\nThe keywords Key= and info= are not needed. RFC 5869 defines HKDF-Expand\nwith\nthree parameters corresponding to key, info and length, so just writing\npseudorandom_pad = HKDF-Expand(RwdU, nonce | \"Pad\", len(pt))\nshould be enough\n(I write the name of the fields to clarify the semantics but this is not\nneeded\nfor specification).\n\nBtw, I prefer \"nonce\" or \"Nonce\" better than n.\n\nAlso: Is Ne (the length of exporter_key) defined?\nWe can use the same length for auth_key and exporter_key - they should be\nHashLen where this denotes the output length from the hash underlying HKDF\n(or\nHMAC)\n\n* Encryption and aad\n\nYou define (line 718)\n  pt = SerializeCredentials(C)\nand then (line 723)\n  ct = xor(pt, pseudorandom_pad)\nwhich means you are mandating the encryption of all fields in Credentials.\nI don't think we want to do that.\nSome people (like Kevin and I got this feedback from AWS too) want to keep\npkS\nunencrypted so we should accommodate that.\nI also find the text in line 733-736 confusing.\nShouldn't the SerializeCredentials get as input an indication of what\nCredentials fields are included and which are part of pt and which of aad?\n\nIn particular I don't like to leave this to the application:\n  \"Instantiations of OPAQUE MUST specify how aad is constructed and\nserialized.\"\nShouldn't the OPAQUE client be standardized independently of the\napplications?\n\n> Is it ok to leave it up to the application? Don't you want to build\ngeneric\nclients? Can't the SerializeCredentials function have as input the\nencrypted and\nauthenticated elements?\n\nBtw, you use the notation pk(skU) but this is denoted by the simple pkU\n\n* Important correction\n\nWhere it says (line 724):\n\nt = HMAC(auth_key, concat(ct, aad)),  where aad is application-specific\n\nit should be\n\nt = HMAC(auth_key, concat(n, ct, aad)),  where aad is application-specific\n\nthe nonce needs to be authenticated (it's my fault, I overlooked it in the\ntext\nI sent you).\n\n* line 896 Abort(): should one define an error message for it?\n\n\n\nOn Wed, Jun 17, 2020 at 12:34 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> @chris-wood <https://github.com/chris-wood> requested your review on: #36\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36> Remove RKR-AEAD\n> dependency..\n>\n> \u2014\n> You are receiving this because your review was requested.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36#event-3454432475>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXX5T5AHOTNA2WBILLDRXDWAVANCNFSM4OAYKGZQ>\n> .\n>\n",
          "createdAt": "2020-06-18T02:17:40Z",
          "updatedAt": "2020-06-18T02:17:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> * Question (pure curiosity): What was the functionality of the \"context\" value what was context \r\n\r\nIt was meant to link requests/responses together. But that's something that can be handled by the instantiation (OPAQUE-EA in this case).\r\n\r\n> * Line 642: Envelope is defined as an encryption of a Credentials structure, but encryption is only required for skU. Maybe \"an authenticated encoding\" instead of encryption, since everything in it requires authentication. (same appears in line 821) \r\n\r\nThat works for me -- I'll use that text.\r\n\r\n> * params, the MHF parameters established out of band Shouldn't we allow for params to be communicated by the server to client (this would be another potential element of Envelope) \r\n\r\nI don't think so. Clients can choose to harden the password using whatever parameters they wish, right? Why does the server need to have any input here?\r\n\r\n> * Calculation of keys using HKDF-Expand (lines 720..., also 891...) Here is how the calculation should look: pseudorandom_pad = HKDF-Expand(Key=RwdU, info = nonce | \"Pad\", len(pt)) auth_key = HKDF-Expand(Key=RwdU, info = nonce | \"AuthKey\", Na) exporter_key = HKDF-Expand(Key=RwdU, info = nonce | \"ExporterKey\", Ne) The keywords Key= and info= are not needed. RFC 5869 defines HKDF-Expand with three parameters corresponding to key, info and length, so just writing pseudorandom_pad = HKDF-Expand(RwdU, nonce | \"Pad\", len(pt)) should be enough (I write the name of the fields to clarify the semantics but this is not needed for specification). \r\n\r\nTo be clear, you're just suggesting removing the argument labels (\"key=\"), right? I don't see any difference between concat(nonce, \"Pad\") and concat(\"Pad\", nonce). \r\n\r\n> Btw, I prefer \"nonce\" or \"Nonce\" better than n. Also: Is Ne (the length of exporter_key) defined? We can use the same length for auth_key and exporter_key - they should be HashLen where this denotes the output length from the hash underlying HKDF (or HMAC) \r\n\r\nYep, Ne is the length of the exporter key. It's a parameter to the functions where it's used. I folded Na and Ne together. I'll specify a value for this in a separate PR.\r\n\r\n> * Encryption and aad You define (line 718) pt = SerializeCredentials(C) and then (line 723) ct = xor(pt, pseudorandom_pad) which means you are mandating the encryption of all fields in Credentials. I don't think we want to do that. Some people (like Kevin and I got this feedback from AWS too) want to keep pkS unencrypted so we should accommodate that. I also find the text in line 733-736 confusing. Shouldn't the SerializeCredentials get as input an indication of what Credentials fields are included and which are part of pt and which of aad? In particular I don't like to leave this to the application: \"Instantiations of OPAQUE MUST specify how aad is constructed and serialized.\" Shouldn't the OPAQUE client be standardized independently of the applications?\r\n\r\nI don't know of a good way to specify this in the pseudocode without a mess of branches. I think the default case should be to encrypt pkS, and we can specify variants (moving pkS out of Credentials and into aad, for example) in the text. But we can also flip that around and make the default case be to only authenticate pkS, with text suggesting it may optionally be encrypted. Would that work?\r\n\r\n> Is it ok to leave it up to the application? Don't you want to build generic clients? Can't the SerializeCredentials function have as input the encrypted and authenticated elements? \r\n\r\nI'm not sure what you mean here. By leaving it up to applications, we are allowing generic clients to use this as needed.\r\n\r\n> Btw, you use the notation pk(skU) but this is denoted by the simple pkU \r\n\r\nThat works. :-)\r\n\r\n> * Important correction Where it says (line 724): t = HMAC(auth_key, concat(ct, aad)), where aad is application-specific it should be t = HMAC(auth_key, concat(n, ct, aad)), where aad is application-specific the nonce needs to be authenticated (it's my fault, I overlooked it in the text I sent you). \r\n\r\nWhoops -- yes, will fix!\r\n\r\n>* line 896 Abort(): should one define an error message for it?\r\n\r\nI replaced this with \"raise DecryptionError\", to make it a bit more clear.",
          "createdAt": "2020-06-18T02:43:03Z",
          "updatedAt": "2020-06-18T02:43:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw -- I updated this based on your feedback above. Everything should be accounted for, but please let me know if not!",
          "createdAt": "2020-06-18T02:45:31Z",
          "updatedAt": "2020-06-18T02:45:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw, I pushed one more update that separates application AAD and the authentication-only data in credentials. Hopefully this is more clear!",
          "createdAt": "2020-06-18T03:08:02Z",
          "updatedAt": "2020-06-18T03:08:02Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "On Wed, Jun 17, 2020 at 10:43 PM Christopher Wood <notifications@github.com>\nwrote:\n\n>\n>    - Question (pure curiosity): What was the functionality of the\n>    \"context\" value what was context\n>\n> It was meant to link requests/responses together. But that's something\n> that can be handled by the instantiation (OPAQUE-EA in this case).\n>\n>\n>    - Line 642: Envelope is defined as an encryption of a Credentials\n>    structure, but encryption is only required for skU. Maybe \"an authenticated\n>    encoding\" instead of encryption, since everything in it requires\n>    authentication. (same appears in line 821)\n>\n> That works for me -- I'll use that text.\n>\n>\n>    - params, the MHF parameters established out of band Shouldn't we\n>    allow for params to be communicated by the server to client (this would be\n>    another potential element of Envelope)\n>\n> I don't think so. Clients can choose to harden the password using whatever\n> parameters they wish, right? Why does the server need to have any input\n> here?\n>\nThe question is how the client knows at login time what parameters it has\nto use. The client machine may be running OPAQUE instances with different\nservers and users that have different parameters. In such a case, the\nserver needs to store these parameters (that were set a password\nregistration phase)  and send them to the client.\n\n\n>    - Calculation of keys using HKDF-Expand (lines 720..., also 891...)\n>    Here is how the calculation should look: pseudorandom_pad =\n>    HKDF-Expand(Key=RwdU, info = nonce | \"Pad\", len(pt)) auth_key =\n>    HKDF-Expand(Key=RwdU, info = nonce | \"AuthKey\", Na) exporter_key =\n>    HKDF-Expand(Key=RwdU, info = nonce | \"ExporterKey\", Ne) The keywords Key=\n>    and info= are not needed. RFC 5869 defines HKDF-Expand with three\n>    parameters corresponding to key, info and length, so just writing\n>    pseudorandom_pad = HKDF-Expand(RwdU, nonce | \"Pad\", len(pt)) should be\n>    enough (I write the name of the fields to clarify the semantics but this is\n>    not needed for specification).\n>\n> To be clear, you're just suggesting removing the argument labels (\"key=\"),\n> right? I don't see any difference between concat(nonce, \"Pad\") and\n> concat(\"Pad\", nonce).\n>\nYes, that is what I was suggesting but note that the change from what you\nhad before is much more significant than that. You had\nHKDF-Expand(salt=n, IKM=RwdU, \"Pad\", len(pt))\nwhich uses the nonce as salt, but only HKDF-Extract uses salt, not Expand.\n\nBtw, I prefer \"nonce\" or \"Nonce\" better than n. Also: Is Ne (the length of\n> exporter_key) defined? We can use the same length for auth_key and\n> exporter_key - they should be HashLen where this denotes the output length\n> from the hash underlying HKDF (or HMAC)\n>\n> Yep, Ne is the length of the exporter key. It's a parameter to the\n> functions where it's used. I folded Na and Ne together. I'll specify a\n> value for this in a separate PR.\n>\n>\n>    - Encryption and aad You define (line 718) pt =\n>    SerializeCredentials(C) and then (line 723) ct = xor(pt, pseudorandom_pad)\n>    which means you are mandating the encryption of all fields in Credentials.\n>    I don't think we want to do that. Some people (like Kevin and I got this\n>    feedback from AWS too) want to keep pkS unencrypted so we should\n>    accommodate that. I also find the text in line 733-736 confusing. Shouldn't\n>    the SerializeCredentials get as input an indication of what Credentials\n>    fields are included and which are part of pt and which of aad? In\n>    particular I don't like to leave this to the application: \"Instantiations\n>    of OPAQUE MUST specify how aad is constructed and serialized.\" Shouldn't\n>    the OPAQUE client be standardized independently of the applications?\n>\n> I don't know of a good way to specify this in the pseudocode without a\n> mess of branches. I think the default case should be to encrypt pkS, and we\n> can specify variants (moving pkS out of Credentials and into aad, for\n> example) in the text. But we can also flip that around and make the default\n> case be to only authenticate pkS, with text suggesting it may optionally be\n> encrypted. Would that work?\n>\nWhy can't you have two components in Credentials: pt and aad, and the\napplication chooses which fields to map to each one? I understand that what\nyou propose is simpler but it also requires customizing the client to\ndifferent applications. In the case where the client is \"written\" for a\nspecific application, that's fine, but if you have a situation where the\nsame client interacts with different applications/servers then things\nbecome problematic.\n\nIs it ok to leave it up to the application? Don't you want to build generic\n> clients? Can't the SerializeCredentials function have as input the\n> encrypted and authenticated elements?\n>\n> I'm not sure what you mean here. By leaving it up to applications, we are\n> allowing generic clients to use this as needed.\n>\nI am thinking of a web browser running OPAQUE (as a client) with different\nservers that may have different policies regarding what is\nincluded/encrypted/authenticated. So you want a standardized way for the\nserver to  communicate the structure of the envelope to the browser.\n\n\n> Btw, you use the notation pk(skU) but this is denoted by the simple pkU\n>\n> That works. :-)\n>\n>\n>    - Important correction Where it says (line 724): t = HMAC(auth_key,\n>    concat(ct, aad)), where aad is application-specific it should be t =\n>    HMAC(auth_key, concat(n, ct, aad)), where aad is application-specific the\n>    nonce needs to be authenticated (it's my fault, I overlooked it in the text\n>    I sent you).\n>\n> Whoops -- yes, will fix!\n>\n>\n>    - line 896 Abort(): should one define an error message for it?\n>\n> I replaced this with \"raise DecryptionError\", to make it a bit more clear.\n>\n> \u2014\n> You are receiving this because your review was requested.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36#issuecomment-645735586>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXXW5OCWTJT6XD646JTRXF5MHANCNFSM4OAYKGZQ>\n> .\n>\n",
          "createdAt": "2020-06-18T04:29:52Z",
          "updatedAt": "2020-06-18T04:29:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The question is how the client knows at login time what parameters it has to use. The client machine may be running OPAQUE instances with different servers and users that have different parameters. In such a case, the server needs to store these parameters (that were set a password registration phase)  and send them to the client.\r\n\r\nAh, okay, good point. I was assuming the application was \"fixed,\" e.g., a mobile app in which the parameters are baked into the code. But that might not always be the case. I'll just revert this for now.\r\n\r\n> Why can't you have two components in Credentials: pt and aad, and the application chooses which fields to map to each one? I understand that what you propose is simpler but it also requires customizing the client to different applications. In the case where the client is \"written\" for a specific application, that's fine, but if you have a situation where the same client interacts with different applications/servers then things become problematic.\r\n\r\nSent an email to discuss offline!",
          "createdAt": "2020-06-18T05:05:15Z",
          "updatedAt": "2020-06-18T05:05:15Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the difference in our approaches/expectations is that you think of\nOPAQUE for use inside a standalone application that has full control of the\nclient and I think more about a \"universal\" mechanism, e.g., a standardized\nbrowser-based client.\n\nOn Thu, Jun 18, 2020 at 1:05 AM Christopher Wood <notifications@github.com>\nwrote:\n\n> The question is how the client knows at login time what parameters it has\n> to use. The client machine may be running OPAQUE instances with different\n> servers and users that have different parameters. In such a case, the\n> server needs to store these parameters (that were set a password\n> registration phase) and send them to the client.\n>\n> Ah, okay, good point. I was assuming the application was \"fixed,\" e.g., a\n> mobile app in which the parameters are baked into the code. But that might\n> not always be the case. I'll just revert this for now.\n>\n> Why can't you have two components in Credentials: pt and aad, and the\n> application chooses which fields to map to each one? I understand that what\n> you propose is simpler but it also requires customizing the client to\n> different applications. In the case where the client is \"written\" for a\n> specific application, that's fine, but if you have a situation where the\n> same client interacts with different applications/servers then things\n> become problematic.\n>\n> Sent an email to discuss offline!\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/36#issuecomment-645774735>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXVWM7BCPBSA5PNEDKTRXGOBPANCNFSM4OAYKGZQ>\n> .\n>\n",
          "createdAt": "2020-06-18T20:26:37Z",
          "updatedAt": "2020-06-18T20:26:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjg4MzY5",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:26:41Z",
          "updatedAt": "2020-06-18T22:26:42Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "I prefer OPAQUE credentials than application credentials",
              "createdAt": "2020-06-18T22:26:41Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjg5Mjgw",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:28:57Z",
          "updatedAt": "2020-06-18T22:28:58Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "I would not call all of them essential, just skU and pkS are.\r\n\r\nDo we want to restrict to just these five or leave further extensibility in case it is needed (e.g., we were discussing the hardening parameters as a possible addition to the envelope).\r\n",
              "createdAt": "2020-06-18T22:28:58Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjg5ODYy",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:30:21Z",
          "updatedAt": "2020-06-18T22:30:21Z",
          "comments": [
            {
              "originalPosition": 218,
              "body": "Applications credentials that require authentication but not secrecy",
              "createdAt": "2020-06-18T22:30:21Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjkwNDQ0",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:31:50Z",
          "updatedAt": "2020-06-18T22:31:51Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "maybe auth_tag instead of just tag? (not too important)",
              "createdAt": "2020-06-18T22:31:50Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjkyMDIz",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:36:05Z",
          "updatedAt": "2020-06-18T22:36:05Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "I noted that skU and pkS are mandatory. We might want to leave room for other things. The hardening parameters might be one of them, if they aren't transmitted at the application layer.",
              "createdAt": "2020-06-18T22:36:05Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjkzNzky",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:40:39Z",
          "updatedAt": "2020-06-18T22:40:39Z",
          "comments": [
            {
              "originalPosition": 399,
              "body": "How is server policy (what is encrypted and what is not in the envelope) communicated to the client? DO we need a special message (echoing the credentials structure) for that?",
              "createdAt": "2020-06-18T22:40:39Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk0NDc0",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:42:21Z",
          "updatedAt": "2020-06-18T22:42:21Z",
          "comments": [
            {
              "originalPosition": 382,
              "body": "what is the use of aad (additional to auth_data)?",
              "createdAt": "2020-06-18T22:42:21Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk0NzQ4",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:43:07Z",
          "updatedAt": "2020-06-18T22:43:07Z",
          "comments": [
            {
              "originalPosition": 382,
              "body": "Any AAD specific to the application, really. It's an opaque slot.",
              "createdAt": "2020-06-18T22:43:07Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk1MDE0",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:43:50Z",
          "updatedAt": "2020-06-18T22:43:51Z",
          "comments": [
            {
              "originalPosition": 407,
              "body": "Do we need aad? If so, where is it transmitted? It is not part of the envelope.",
              "createdAt": "2020-06-18T22:43:50Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk1NTYx",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:45:12Z",
          "updatedAt": "2020-06-18T22:45:12Z",
          "comments": [
            {
              "originalPosition": 399,
              "body": "I figured it'd be best to omit that from this, since it's an application-specific detail. But we could probably have the server be crystal clear about this inline. ",
              "createdAt": "2020-06-18T22:45:12Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk1NjE0",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:45:20Z",
          "updatedAt": "2020-06-18T22:45:20Z",
          "comments": [
            {
              "originalPosition": 407,
              "body": "Yes, I think so.",
              "createdAt": "2020-06-18T22:45:20Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk2MDQ5",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:46:27Z",
          "updatedAt": "2020-06-18T22:46:27Z",
          "comments": [
            {
              "originalPosition": 423,
              "body": "We need to specify that *all* values in EnvU require authentication, only secrecy is optional (except for skU for which it is mandatory)",
              "createdAt": "2020-06-18T22:46:27Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk2MTcy",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:46:47Z",
          "updatedAt": "2020-06-18T22:46:48Z",
          "comments": [
            {
              "originalPosition": 423,
              "body": "I think that's already clear from context, no?",
              "createdAt": "2020-06-18T22:46:48Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk3MDI3",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:49:10Z",
          "updatedAt": "2020-06-18T22:49:10Z",
          "comments": [
            {
              "originalPosition": 535,
              "body": "pkS is a mandatory part of EnvU",
              "createdAt": "2020-06-18T22:49:10Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk4ODI0",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:54:01Z",
          "updatedAt": "2020-06-18T22:54:01Z",
          "comments": [
            {
              "originalPosition": 564,
              "body": "why tag?",
              "createdAt": "2020-06-18T22:54:01Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk5NTcz",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:56:06Z",
          "updatedAt": "2020-06-18T22:56:06Z",
          "comments": [
            {
              "originalPosition": 402,
              "body": "Make reference to RFC 5869 about the roles of the three inputs to HKDF-Expand, namely, key, info, and output length.",
              "createdAt": "2020-06-18T22:56:06Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAwNzMx",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:13Z",
          "updatedAt": "2020-06-18T22:59:14Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "(This list is meant to be extended, basically.)",
              "createdAt": "2020-06-18T22:59:14Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAwODYz",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:34Z",
          "updatedAt": "2020-06-18T22:59:35Z",
          "comments": [
            {
              "originalPosition": 535,
              "body": "I removed this left-over text.",
              "createdAt": "2020-06-18T22:59:34Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAwODk3",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:41Z",
          "updatedAt": "2020-06-18T22:59:41Z",
          "comments": [
            {
              "originalPosition": 564,
              "body": "Bug -- fixed!",
              "createdAt": "2020-06-18T22:59:41Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAwOTIx",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:45Z",
          "updatedAt": "2020-06-18T22:59:46Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "I guess that aad should be replaced here with cleartext_credentials? ",
              "createdAt": "2020-06-18T22:59:46Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAxMDAz",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T22:59:57Z",
          "updatedAt": "2020-06-18T22:59:58Z",
          "comments": [
            {
              "originalPosition": 402,
              "body": "I added a reference at the end of this algorithm.",
              "createdAt": "2020-06-18T22:59:57Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAxMzA4",
          "commit": {
            "abbreviatedOid": "c72f34b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T23:00:44Z",
          "updatedAt": "2020-06-18T23:00:44Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "Yep, good catch!",
              "createdAt": "2020-06-18T23:00:44Z",
              "updatedAt": "2020-06-18T23:03:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzAxMzkw",
          "commit": {
            "abbreviatedOid": "47601cc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I approve this but see the comments I have interleaved in the code",
          "createdAt": "2020-06-18T23:00:57Z",
          "updatedAt": "2020-06-18T23:00:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2ODEyMzE4",
      "title": "Remove TLS 1.3 integration details.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/38",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #2.\r\n\r\nThis removes TLS 1.3 integration details, but keeps the SIGMA-I content. (TLS 1.3 details will go in the TLS document.)",
      "createdAt": "2020-06-18T23:35:42Z",
      "updatedAt": "2020-06-19T15:14:46Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "683cb6842f4a9e862cc5982247afdc4ce2526282",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/remove-tls",
      "headRefOid": "2196764fc36b09dbb5719a18760c6d1b8d1ab604",
      "closedAt": "2020-06-19T15:14:46Z",
      "mergedAt": "2020-06-19T15:14:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "13cb903eee61256b31c08b1dadbbabe47d3fcee6"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I love that line :-D",
          "createdAt": "2020-06-19T15:11:58Z",
          "updatedAt": "2020-06-19T15:11:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzk5OTUx",
          "commit": {
            "abbreviatedOid": "cfb1c92"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good. I would still have some text pointing to the need to integrate with TLS to achieve user account privacy and to implement the record layer where information is protected by keys generated/authenticated by OPAQUE. \r\n\r\nSomewhat related, I would like to keep this remark (possible re-phrased and shortened): \r\n   Note on user authentication vs. authenticated key exchange. OPAQUE\r\n   provides PAKE (password-based authenticated key exchange)\r\n   functionality in the client-server setting. While in the case of user\r\n   identification, focus is often on the authentication part, we stress\r\n   that the key exchange element is not less crucial. Indeed, in most\r\n   cases user authentication is performed to enforce some policy, and\r\n   the key exchange part is essential for binding this enforcement to\r\n   the authentication step. Skipping the key exchange part is analogous\r\n   to carefully checking a visitor's credential at the door and then \r\n   leaving the door open for others to enter freely.",
          "createdAt": "2020-06-19T04:49:35Z",
          "updatedAt": "2020-06-19T04:49:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2ODI0NDgy",
      "title": "Move configuration information to separate section.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/39",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This shuffles content around, mostly.",
      "createdAt": "2020-06-19T00:24:24Z",
      "updatedAt": "2020-06-19T15:06:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "12c2440575fd2bb47a3aaaeffc7152806b44d94a",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/configurations",
      "headRefOid": "56231a77e51785ee2ba6ec9d55bcf2aa8549facf",
      "closedAt": "2020-06-19T15:06:44Z",
      "mergedAt": "2020-06-19T15:06:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "683cb6842f4a9e862cc5982247afdc4ce2526282"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzk3NzA0",
          "commit": {
            "abbreviatedOid": "56231a7"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-19T04:41:06Z",
          "updatedAt": "2020-06-19T04:41:06Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "It is TBD how the server does that",
              "createdAt": "2020-06-19T04:41:06Z",
              "updatedAt": "2020-06-19T04:41:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzk3Nzc2",
          "commit": {
            "abbreviatedOid": "56231a7"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-19T04:41:24Z",
          "updatedAt": "2020-06-19T04:41:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTUwNTIx",
          "commit": {
            "abbreviatedOid": "56231a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-19T15:06:38Z",
          "updatedAt": "2020-06-19T15:06:39Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Yeah, we'll need to work out a way to do this before revving the draft.",
              "createdAt": "2020-06-19T15:06:38Z",
              "updatedAt": "2020-06-19T15:06:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3MTM3MDYw",
      "title": "Exporter -> export, adding HKDF-Extract around Harden call",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/40",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We should wrap the Harden() call with an HKDF-Extract call, since there is no guarantee that Harden will output pseudorandom bits\r\n\r\nAlso changed \"exporter key\" to read simply as \"export key\"",
      "createdAt": "2020-07-09T23:08:17Z",
      "updatedAt": "2020-12-16T09:54:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "120464d640d093ff99da8d8350766aafb5f28974",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "add_hkdf_extract",
      "headRefOid": "f136373e87fad07782041b9129ff36e73e3b98fb",
      "closedAt": "2020-07-11T00:30:40Z",
      "mergedAt": "2020-07-11T00:30:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "aae69344bcc40290a825b9503540f607e48bcac7"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ",
          "createdAt": "2020-07-10T22:35:47Z",
          "updatedAt": "2020-07-10T22:35:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzU5ODg1",
          "commit": {
            "abbreviatedOid": "f136373"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-07-11T00:30:34Z",
          "updatedAt": "2020-07-11T00:30:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ5NjkyNjU1",
      "title": "Recommend a particular encoding policy for skU, pkS, and IdS.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/41",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @kevinlewi ",
      "createdAt": "2020-07-15T19:41:04Z",
      "updatedAt": "2020-07-21T16:42:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "aae69344bcc40290a825b9503540f607e48bcac7",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/recommend-encoding",
      "headRefOid": "d31dd83f56078d8f3c00f19d953668e96cb6cfbf",
      "closedAt": "2020-07-21T16:42:39Z",
      "mergedAt": "2020-07-21T16:42:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "21f45acd09457f120470a946de1f9a9851b74de5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDYyMDY3",
          "commit": {
            "abbreviatedOid": "2de0620"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Regarding: \"to not store redundant encryptions of these (shared) values for each user.\" Reusing pkS with different users is not a must, and in principle even idS could be different for different users. So I would say something like \"to not store redundant encryptions of these values for each user in case the server uses the same values for multiple/all users.\" (Or something like that)\r\n\r\nThe word  '(shared)' with the meaning of \"common to multiple/all users\" may be unclear. Use something else (I couldconfusing as it could be shared with t",
          "createdAt": "2020-07-18T14:55:31Z",
          "updatedAt": "2020-07-18T14:55:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY3MDc1NTMw",
      "title": "Fixing length requirement typos for RegistrationResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/44",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- secret_types must contain at least skU\r\n- cleartext_types may be empty\r\n\r\nTherefore, lowering the length requirements of these vectors in RegistrationResponse to be 1 and 0, respectively.\r\n\r\nAlso updating my email and adding a close bracket",
      "createdAt": "2020-08-13T00:27:36Z",
      "updatedAt": "2020-12-16T09:54:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e03a8a3e945193567e99424db5bda83f33219fe9",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "typos_1",
      "headRefOid": "9f6b074d83ba64607fcd735f23f1b76832014057",
      "closedAt": "2020-08-20T19:52:46Z",
      "mergedAt": "2020-08-20T19:52:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f32a22595db939752bd94c51bb2a4cc1c53e24e6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxOTM4Nzg1",
          "commit": {
            "abbreviatedOid": "9f6b074"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-20T19:52:42Z",
          "updatedAt": "2020-08-20T19:52:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxNjI4NDQx",
      "title": "Align KE instantiations with the core protocol messages.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/45",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This aligns the KE instantiations with the core protocol messages, using them where appropriate instead of OPRF1/OPRF2/EnvU etc directly. ",
      "createdAt": "2020-08-21T13:18:40Z",
      "updatedAt": "2020-08-24T17:31:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "f32a22595db939752bd94c51bb2a4cc1c53e24e6",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/align-kes",
      "headRefOid": "c3052cc22e44bd9cea52b02f4b947bbcbd7f7d38",
      "closedAt": "2020-08-24T17:31:51Z",
      "mergedAt": "2020-08-24T17:31:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d6fcfaa0ce739c702683cc555b7aa4d1d9cb251a"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I updated the change based on your comments. Thanks for the feedback! In response to your overall comment:\r\n\r\n> I left multiple comments, most minor. Two important issues to finalize is the derivation of keys for the KE protocols, specifically should we use a single call to HKDF or should we have separate calls for each key (in any case one needs to define the lengths of the individual keys). The other is to finalize some details in the computation of the HMQV key. I owe that to you.\r\n\r\nLet's update the key schedule in a separate PR. I'll await your input for the HMQV key derivation.",
          "createdAt": "2020-08-23T14:28:23Z",
          "updatedAt": "2020-08-23T14:28:45Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok. Just add to the last sentence:\n\nand KE3 provides explicit client authentication and full forward security\n(without it forward secrecy is only achieved against eavesdroppers)\n\nOn Sun, Aug 23, 2020 at 4:59 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> *@chris-wood* commented on this pull request.\n> ------------------------------\n>\n> In draft-irtf-cfrg-opaque.md\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/45#discussion_r475266680>\n> :\n>\n> > @@ -1015,28 +1022,27 @@ login.\n>\n>  # OPAQUE Instantiations {#instantiations}\n>\n> -We present several instantiations of OPAQUE using DH-OPRF\n> -and different KE protocols. For the sake of concreteness we focus on\n> -KE protocols consisting of three messages, denoted KE1, KE2, KE3, and\n> -such that KE1 and KE2 include DH values sent by user and server,\n> -respectively, and KE3 provides explicit user authentication.\n> +This section describes several instantiations of OPAQUE using different KE protocols.\n> +For the sake of concreteness it only includes KE protocols consisting of three messages,\n> +denoted KE1, KE2, KE3, where KE1 and KE2 include DH values sent by client and\n> +server, respectively, and KE3 provides explicit client authentication.\n>\n> I chose to keep this text (since it's not new, only copied). We can fix it\n> in a separate issue if needed.\n>\n> \u2014\n> You are receiving this because your review was requested.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/45#discussion_r475266680>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXSE3V6WRN7YOFAKQUTSCF7K7ANCNFSM4QHI6AMA>\n> .\n>\n",
          "createdAt": "2020-08-23T21:31:12Z",
          "updatedAt": "2020-08-23T21:31:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTc2MjE3",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T03:28:07Z",
          "updatedAt": "2020-08-23T03:28:08Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I do not like the \"at the end, the client proves the user's knowledge of the password\" as it sounds as if that is a step in the protocol. It is true that for the KE protocol to be successfully authenticated, the client must have possession of the user's password. Maybe you want to rephrase somehow.\r\n",
              "createdAt": "2020-08-23T03:28:07Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTc2ODIw",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T03:46:23Z",
          "updatedAt": "2020-08-23T03:46:24Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "This is existing text, but I\u2019ll see if we can rework it.",
              "createdAt": "2020-08-23T03:46:23Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTc2Mzg0",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I left multiple comments, most minor. Two important issues to finalize is the derivation of keys for the KE protocols, specifically should we use a single call to HKDF or should we have separate calls for each key (in any case one needs to define the lengths of the individual keys). The other is to finalize some details in the computation of the HMQV key. I owe that to you.",
          "createdAt": "2020-08-23T03:33:12Z",
          "updatedAt": "2020-08-23T05:46:38Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Just to make sure, this error should lead to aborting the session",
              "createdAt": "2020-08-23T03:33:12Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 85,
              "body": "All the protocols we describe provide explicit mutual authentication, so not sure I would single out the explicit authentication of the user, except if you feel the need to say what KE3 is for. Btw, in these protocols, the third message has the essential role of providing \"full forward security\" to the protocol. Without it, the protocol would only have weak forward secrecy which is not enough in general for OPAQUE security.",
              "createdAt": "2020-08-23T03:39:52Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 107,
              "body": "Can we say \"authenticate credential_request and credential_response, resepctively, ...\"?\r\nIt is longer but clearer (to me at least)",
              "createdAt": "2020-08-23T03:44:41Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 114,
              "body": "DH keys are for the HMQV and 3DH cases, not for SIGMA",
              "createdAt": "2020-08-23T03:57:44Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 193,
              "body": "Remove this last remark, it is not entirely correct.",
              "createdAt": "2020-08-23T04:08:01Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 164,
              "body": "Add here (or elsewhere) that  these ephemeral DH values need to be  verified to belong to the correct group (via membership tests or cofactor exponentiation, depending on curve details). The same holds for public keys during the registration phase.",
              "createdAt": "2020-08-23T04:23:28Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 114,
              "body": "Important: These public keys, exchanged during the registration phase  should be  verified to belong to the correct group (via membership tests or cofactor exponentiation, depending on curve details). ",
              "createdAt": "2020-08-23T04:24:50Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 209,
              "body": "Should we use the derivation style from TLS 1.3 and the rest of this document where each key has its own Expand call (and its own info/label value)? Either way, one needs to define the length of each of these keys (which depend on the MAC and encryption functions in use and whatever length one wants SK to be)",
              "createdAt": "2020-08-23T04:32:28Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 224,
              "body": "The definition of HMQV needs some care: the values u and s should be mapped to elements mod q where q is the order of the group and one should not use the hash function directly but some RO-like construction, maybe HKDF itself. I need to think about this. Also, the computation of Khmqv by the server (and similarly for the client) should first define the intermediate value  v = (eskS + u\\*skS) mod q and then compute Khmqv = (epkU \\* pkU^u)^v. I need to think about this some more. In particular, I need to check how you deal with some of similar issues, particularly RO hashing, in your definition of OPRF.",
              "createdAt": "2020-08-23T05:28:32Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 246,
              "body": "move nonceU before info1* for uniformity with the other specifications",
              "createdAt": "2020-08-23T05:34:35Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            },
            {
              "originalPosition": 258,
              "body": "IdU and IdS are defined in the explanation of these fields (appearing first for HMQV/3DH). In particular it is said there that IdU is the  identity used to create credential_request. I don't think it needs to be said here again (and if there is a reason for it, why only define IdU here and not also IdS?)",
              "createdAt": "2020-08-23T05:41:32Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDEzNTEw",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T13:55:28Z",
          "updatedAt": "2020-08-23T13:55:28Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "I'd be fine with that change. Specifying a key schedule similar to TLS 1.3 seems reasonable. Let me try and put that together.",
              "createdAt": "2020-08-23T13:55:28Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDEzNTgy",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T13:56:06Z",
          "updatedAt": "2020-08-23T13:56:06Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "I forgot to revert this -- thanks for flagging it.",
              "createdAt": "2020-08-23T13:56:06Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDEzNzY0",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T13:58:28Z",
          "updatedAt": "2020-08-23T13:58:28Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "I felt it was worth highlighting since otherwise it appears out fo context. I'll just remove it. ",
              "createdAt": "2020-08-23T13:58:28Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDEzOTA5",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T14:00:08Z",
          "updatedAt": "2020-08-23T14:00:09Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Yep!",
              "createdAt": "2020-08-23T14:00:09Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDE1Njk2",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T14:23:16Z",
          "updatedAt": "2020-08-23T14:23:16Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "(I'll do that in a followup change, to keep this diff smaller)",
              "createdAt": "2020-08-23T14:23:16Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDE1OTcz",
          "commit": {
            "abbreviatedOid": "3ae28e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T14:26:25Z",
          "updatedAt": "2020-08-23T14:26:26Z",
          "comments": [
            {
              "originalPosition": 224,
              "body": "The OPRF document uses hash_to_curve where appropriate: https://tools.ietf.org/html/draft-irtf-cfrg-voprf-04#section-2.1",
              "createdAt": "2020-08-23T14:26:25Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDE2MTMz",
          "commit": {
            "abbreviatedOid": "9ddc0a0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T14:27:51Z",
          "updatedAt": "2020-08-23T14:27:51Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Yep, it does. If this isn't clear, I can add a note as such.",
              "createdAt": "2020-08-23T14:27:51Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDQ1MzE0",
          "commit": {
            "abbreviatedOid": "9ddc0a0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-23T20:59:15Z",
          "updatedAt": "2020-08-23T20:59:15Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I chose to keep this text (since it's not new, only copied). We can fix it in a separate issue if needed.",
              "createdAt": "2020-08-23T20:59:15Z",
              "updatedAt": "2020-08-23T22:17:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcyNjczOTgx",
      "title": "Update the HMQV key derivation details. Clean up some presentation bugs.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/46",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-24T17:53:03Z",
      "updatedAt": "2020-08-25T03:55:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "d6fcfaa0ce739c702683cc555b7aa4d1d9cb251a",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hmqv-update",
      "headRefOid": "b3781464f814953b38080ac849589203e09e8ef5",
      "closedAt": "2020-08-24T22:41:28Z",
      "mergedAt": "2020-08-24T22:41:28Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "63a8acabd6e6420146cb38a0cd8f238688839107"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODIxMzAy",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I approve pending the attached review comments.",
          "createdAt": "2020-08-24T20:11:17Z",
          "updatedAt": "2020-08-24T21:27:24Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "#derive-3dh should be #derive-hmqv  here",
              "createdAt": "2020-08-24T20:11:17Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 51,
              "body": "let's change mod p to mod (len(p)-1)",
              "createdAt": "2020-08-24T20:14:08Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 44,
              "body": "Both client and server need to compute u and s, so it does not work to put the definition of u under the client computation and s under the server computation. They should go together at the beginning, at the end, or both as part of the user computation, and then saying that the server computes them same as the client.",
              "createdAt": "2020-08-24T20:17:18Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 74,
              "body": "change to:\r\nlen(\"server\") || \"server\"",
              "createdAt": "2020-08-24T21:17:02Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 75,
              "body": "change mod p to mod (len(p)-1)",
              "createdAt": "2020-08-24T21:17:57Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            },
            {
              "originalPosition": 81,
              "body": "remove last line",
              "createdAt": "2020-08-24T21:19:38Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODcwMDM4",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T21:29:13Z",
          "updatedAt": "2020-08-24T21:29:13Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Oops, wrong headers!",
              "createdAt": "2020-08-24T21:29:13Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODcwODMz",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T21:30:40Z",
          "updatedAt": "2020-08-24T21:30:40Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "hah, I thought I copied the right text!",
              "createdAt": "2020-08-24T21:30:40Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODcxMzA4",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T21:31:33Z",
          "updatedAt": "2020-08-24T21:31:34Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "Which line?",
              "createdAt": "2020-08-24T21:31:33Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczOTQyMzQz",
          "commit": {
            "abbreviatedOid": "de43db3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T22:40:57Z",
          "updatedAt": "2020-08-24T22:40:58Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "(I wasn't sure what line you were referring to, so I'll merge now and can clean this up later!)",
              "createdAt": "2020-08-24T22:40:58Z",
              "updatedAt": "2020-08-24T22:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MTE3MTAx",
          "commit": {
            "abbreviatedOid": "b378146"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T03:55:48Z",
          "updatedAt": "2020-08-25T03:55:49Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "My bad. I read HMQV instead of HKDF (too many H's :-)",
              "createdAt": "2020-08-25T03:55:49Z",
              "updatedAt": "2020-08-25T03:55:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 47,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcyODI5NjIy",
      "title": "Adopt the TLS 1.3 key schedule for better separation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/47",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-24T23:00:22Z",
      "updatedAt": "2020-08-26T12:26:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "63a8acabd6e6420146cb38a0cd8f238688839107",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/key-schedule",
      "headRefOid": "335f4e66c75d6523d85fb16811f0753dd42f4ec5",
      "closedAt": "2020-08-26T12:26:35Z",
      "mergedAt": "2020-08-26T12:26:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "196753132f819990fa1c582995985fbe87ae6de7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MTIxMjMy",
          "commit": {
            "abbreviatedOid": "c9f73de"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "See the comments on the key derivation. We need to decide on these (annoying) details",
          "createdAt": "2020-08-25T04:10:03Z",
          "updatedAt": "2020-08-25T04:37:17Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "\"OPAQUE\" instead of \"tls13\" I guess (use upper case OPAQUE to distinguish from the opaque type.",
              "createdAt": "2020-08-25T04:10:03Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            },
            {
              "originalPosition": 25,
              "body": "What I call Ke2, Ke3  is the equivalent of the handshake write keys in TLS 1.3, and Km2, Km3 are the equivalent of Finished keys. What I call SK is a key from which traffic write keys are derived. \r\nSo the equivalent to TLS would be to use  Derive_Secret to output handshake_traffic_secret and application_traffic_secret and then define the write_key derivations as in Section 7.3 of TLS 1.3 and the Finished key derivation as in Section 4.4 and 4.4.4.\r\nIf you want to simplify and keep it the way you defined it now, note that Ke2 and Ke3 cannot use hash.length but would have a length that depends on the ciphersuite's AEAD.\r\n\r\n",
              "createdAt": "2020-08-25T04:34:43Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NDUyMDc4",
          "commit": {
            "abbreviatedOid": "c9f73de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T12:56:03Z",
          "updatedAt": "2020-08-25T12:56:04Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Copy-paste bug :) Will fix!",
              "createdAt": "2020-08-25T12:56:03Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NDc0NzYy",
          "commit": {
            "abbreviatedOid": "46c5d09"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T13:22:27Z",
          "updatedAt": "2020-08-25T13:22:28Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Ah! Thanks for clarifying. I split the schedule into two parts: one for handshake secrets (Ke2, Ke3, Km2, Km3) and output AKE secrets (SK). All handshake keys, including the encryption and Finished/MAC keys, are derived from the client/server handshake secrets. What do you think?",
              "createdAt": "2020-08-25T13:22:28Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTc3Nzg0",
          "commit": {
            "abbreviatedOid": "46c5d09"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:24:09Z",
          "updatedAt": "2020-08-25T22:24:09Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Here is a simplification\r\n\r\n  HKDF-Extract(salt=0, IKM) = main_secret\r\n      |\r\n      +--> Derive-Secret(., \"c hs secret\", info) = client_handshake_secret\r\n      |\r\n      +--> Derive-Secret(., \"s hs secret\", info) = server_handshake_secret\r\n      |\r\n      +--> Derive-Secret(., \"c sk secret\", info) = client_session_key\r\n      |\r\n      +--> Derive-Secret(., \"s sk secret\", info) = server_session_key\r\n      |\r\n      v\r\n\r\nAnd it can even be simplified further by deriving a single handshake_secret and single session_key and do the separation client/server in further derivation.\r\n\r\nIt really depends how close to TLS 1.3 you want to be.  For example, do we want to stop at the session_key derivation or also derive the \"write keys\" for the AEAD to protect subsequent traffic as TLS 1.3 does?  \r\n",
              "createdAt": "2020-08-25T22:24:09Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTg5NDI0",
          "commit": {
            "abbreviatedOid": "46c5d09"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:29:45Z",
          "updatedAt": "2020-08-25T22:29:45Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Btw, getting too close to TLS 1.3 in names (e.g. client_handshake_secret), we may need to add \"OPAQUE\" as a label. Or maybe this is only done when actually integrating with TLS. \r\n",
              "createdAt": "2020-08-25T22:29:45Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MDA5NzE5",
          "commit": {
            "abbreviatedOid": "4525e69"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:39:49Z",
          "updatedAt": "2020-08-25T22:39:49Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Yeah, I think it's fine to reuse the names here. I applied the simplification you suggested (compressed to a single handshake and session secret), and then derived all handshake secrets (MAC and enc keys) from the handshake_secret.",
              "createdAt": "2020-08-25T22:39:49Z",
              "updatedAt": "2020-08-26T12:25:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MTEyODk0",
          "commit": {
            "abbreviatedOid": "5c0b90e"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Look good! One nit: Change labels \"client auth\" to \"client mac\" (same for server)",
          "createdAt": "2020-08-26T02:46:09Z",
          "updatedAt": "2020-08-26T02:46:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc0OTk3NjI0",
      "title": "Fix the nonce length (Nn) to 32 bytes.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/48",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Making this a parameter seems like too much flexibility, so I suggest we be opinionated and remove it. ",
      "createdAt": "2020-08-27T23:11:34Z",
      "updatedAt": "2020-08-28T17:07:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "196753132f819990fa1c582995985fbe87ae6de7",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/fix-nonce",
      "headRefOid": "9fd53b3663bfb8bc871e3556ccd135df6a303242",
      "closedAt": "2020-08-28T17:07:59Z",
      "mergedAt": "2020-08-28T17:07:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a7d1e6cc3f87c7e4a1c4ed02aa633650191ea074"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> that in the future someone will want to steal a few bytes here and there from the nonce and then... :- )\r\n\r\nHah! :-)\r\n\r\n> Anyway, I would keep the Nn but I am ok if you feel strongly about getting rid of it.\r\n\r\nMy take is that an OPAQUE configuration can simply specify an OPRF, hash function (for HMAC and HKDF), and MHF, without any additional parameters. \r\n\r\nHow about I merge this with a note saying we could make this a parameter if flexibility is desired, and then as the larger group for feedback?",
          "createdAt": "2020-08-28T00:00:30Z",
          "updatedAt": "2020-08-28T00:00:30Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine with the 32 bytes. There is enough room to steal from it if needed. I can see it as more probable that someone will want to save in EnvU size than that 32 bytes will not be enough.\r\nBtw, you also need an AKE to specify OPAQUE in addition to the components you mention. ",
          "createdAt": "2020-08-28T00:52:55Z",
          "updatedAt": "2020-08-28T00:52:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Btw, you also need an AKE to specify OPAQUE in addition to the components you mention.\r\n\r\nYep!",
          "createdAt": "2020-08-28T17:07:55Z",
          "updatedAt": "2020-08-28T17:07:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTU3Mjgy",
          "commit": {
            "abbreviatedOid": "e0622f3"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't feel strongly about this but I don't see why with all parameters that are there, we need to remove just this one. One can imagine, in a very hypothetical way, that in the future someone will want to steal a few bytes here and there from the nonce and then... :- )\r\nIt also works in the other direction, for example for the envelope nonces 32 bytes is quite overkill as all one needs is that it does not repeat for a number of uses that is upper bound by the number of times the user changes his password over the history of his account. A 64-bit nonce would probably ok a 128-bit for sure. \r\nAnyway, I would keep the Nn but I am ok if you feel strongly about getting rid of it.\r\nYour call, I approve it anyway.",
          "createdAt": "2020-08-27T23:54:35Z",
          "updatedAt": "2020-08-27T23:54:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc1NTM5MzQy",
      "title": "Add a hash function dependency",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/49",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "And use it to control the auth_key and exporter_key size(s). ",
      "createdAt": "2020-08-28T17:21:45Z",
      "updatedAt": "2020-08-30T16:20:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "a7d1e6cc3f87c7e4a1c4ed02aa633650191ea074",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/hash",
      "headRefOid": "23077ece157fe3da3a8a59b93b5f55814d52a337",
      "closedAt": "2020-08-30T16:20:07Z",
      "mergedAt": "2020-08-30T16:20:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7065e8d74c16275d98131340d3d197ee17cdf4b5"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I agree that it's overkill. I'll mark this as an OPEN ISSUE to consider fixing in the OPRF draft. (There was no reason to use SHA-512, other than being conservative, I think.)",
          "createdAt": "2020-08-30T16:18:48Z",
          "updatedAt": "2020-08-30T16:18:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDk4MDA5",
          "commit": {
            "abbreviatedOid": "c238558"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I am ok with the changes. SHA-512 is overkill for most keys derived in the protocol (256 bits are more than enough) but I guess we inherit the 512 from the OPRF ciphersuites.  Was there a special reason to use SHA-512 with 256-bit curves (P256 and 25519)? \r\n",
          "createdAt": "2020-08-29T04:44:43Z",
          "updatedAt": "2020-08-29T04:44:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc1OTMyNTc3",
      "title": "Require that the envelope export_key HMAC is checked before using the key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/50",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #30.",
      "createdAt": "2020-08-30T16:25:31Z",
      "updatedAt": "2020-08-31T14:25:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "7065e8d74c16275d98131340d3d197ee17cdf4b5",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/export-key-check",
      "headRefOid": "3914250e1bead6a4deef2f124b1ee8e0268d42c0",
      "closedAt": "2020-08-31T14:25:21Z",
      "mergedAt": "2020-08-31T14:25:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "48ad199022ca5fdaa6e99a45a08c4adc4a3b7cb8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MzAzNTU1",
          "commit": {
            "abbreviatedOid": "3914250"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-31T04:46:39Z",
          "updatedAt": "2020-08-31T04:46:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc4Mjg0Njc4",
      "title": "Restructure the document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/52",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This shuffles text around and fixes some lingering issues. I'll do a full pass over the text after we merge this (or some variant of it)!",
      "createdAt": "2020-09-03T01:35:51Z",
      "updatedAt": "2020-09-05T00:15:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "48ad199022ca5fdaa6e99a45a08c4adc4a3b7cb8",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/restructure",
      "headRefOid": "ef79a5b6b1cfe7d0e2d5d0bd3239d7d1f19cb25c",
      "closedAt": "2020-09-05T00:15:22Z",
      "mergedAt": "2020-09-05T00:15:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e1ff2f58342b48bb881538e3f80fa77e9af85096"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Chris, how do I edit the text in the pull request? This includes edits to\nparts you changed and also to text that existed before.\n\nOn Wed, Sep 2, 2020 at 9:36 PM Christopher Wood <notifications@github.com>\nwrote:\n\n> @chris-wood <https://github.com/chris-wood> requested your review on: #52\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/52> Restructure the\n> document.\n>\n> \u2014\n> You are receiving this because your review was requested.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/52#event-3722484022>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AICFFXXZ7SDU72CEZFQ2NDDSD3XIJANCNFSM4QUC3XTQ>\n> .\n>\n",
          "createdAt": "2020-09-04T19:54:46Z",
          "updatedAt": "2020-09-04T19:54:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMDA1NzQz",
          "commit": {
            "abbreviatedOid": "ef79a5b"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Ready for last round before 00!",
          "createdAt": "2020-09-04T23:20:17Z",
          "updatedAt": "2020-09-04T23:20:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg3OTc5MzUz",
      "title": "Address Eric Crockett's review comments.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/56",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @crockeea",
      "createdAt": "2020-09-16T13:12:00Z",
      "updatedAt": "2020-09-22T01:56:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "eb5855c74d8068fdcd6267bc8beeb7865e8132b8",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/eric-review",
      "headRefOid": "7e61839c338a8224d277b985c79d909a7ffff813",
      "closedAt": "2020-09-22T01:56:40Z",
      "mergedAt": "2020-09-22T01:56:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "33e5132a3e7d20f0ef33cb4a1682a3eb490e9540"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw this PR should be good to go!",
          "createdAt": "2020-09-18T12:59:46Z",
          "updatedAt": "2020-09-18T12:59:46Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am afraid that I did not pushed  my comments (which I wrote them a couple of days ago) before for you to see.  Sorry for that. Eric also asked for a couple of clarifications to add (on the need of forward secrecy and something else). If you need text from me let me know.",
          "createdAt": "2020-09-19T00:57:30Z",
          "updatedAt": "2020-09-19T00:57:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw Thanks for the feedback -- I incorporated your comments. I also added some additional changes on top. Namely:\r\n\r\n- Fix the auth_tag size to the output of HMAC. (One less variable-length thing to worry about.)\r\n- Change how the auth_tag is computed. Previously, it did not include the length of the ciphertext or auth_data, which was worrisome. Now it's computed over the structure:\r\n\r\n```\r\nstruct {\r\n  opaque nonce[32];\r\n  opaque ct<1..2^16-1>;\r\n  opaque auth_data<0..2^16-1>;\r\n} InnerEnvelope;\r\n```\r\n\r\nwhich includes the length of `ct` and `auth_data`.\r\n\r\nPlease let me know what you think!",
          "createdAt": "2020-09-19T12:25:59Z",
          "updatedAt": "2020-09-19T12:25:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@hugokraw, friendly bump! Please feel free to edit the PR directly if that's easier for you. :-)",
          "createdAt": "2020-09-21T23:51:53Z",
          "updatedAt": "2020-09-21T23:51:53Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the delay in responding to the latest changes. I was busy welcoming my second grandson... :-)",
          "createdAt": "2020-09-22T00:45:50Z",
          "updatedAt": "2020-09-22T00:45:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5ODU2OTM5",
          "commit": {
            "abbreviatedOid": "7d6ffa3"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-16T17:46:27Z",
          "updatedAt": "2020-09-19T00:54:26Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "You say AKE is out-of-scope but then we define several instantiations. I'm confused.",
              "createdAt": "2020-09-16T17:46:27Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 82,
              "body": "Shouldn't this (keygen for OPRF) be part of the above specification of the elements related to OPRF?",
              "createdAt": "2020-09-16T18:00:03Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 264,
              "body": "Simplify this sentence as:\r\nApplications may optionally include pkU, idU, or IdS in the Credentials.cleartext_credentials structure, or in envelopeCredentials.secret if secrecy of these values is desired. ",
              "createdAt": "2020-09-16T18:16:24Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 264,
              "body": "There is a sentence following this paragraph about server identity but the identity issues are discussed elsewhere A\r\n\r\nAlso: IdS uses capital I (also in other instances). It seems you skipped IdS in the global change to idS.",
              "createdAt": "2020-09-16T18:20:28Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 305,
              "body": "change 'authenticate stage' to \"authenticated key exchange stage\"",
              "createdAt": "2020-09-16T18:23:03Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 401,
              "body": "It is not clear what it means that \"applications must authenticate pkS\". This value is authenticated by the HMAC computation on the whole envelope so I don't think we need to single out this authentication as a separate/additional step.  Did you mean something different with this sentence?\r\n\r\nThe following text:\r\n\"If an application requires secrecy of pkS, this value SHOULD be omitted from auth_data (step 9).\"\r\nseems to belong to registration where the envelope is created not here.\r\nIf needed, let me know why (btw, the auth_data is now step 10)",
              "createdAt": "2020-09-16T18:32:06Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 438,
              "body": "I would not include this sentence about KCI here as it may be distracting. \r\nIf you think it should be there, I would say\r\nThis section describes several instantiations of OPAQUE using different AKE protocols (all of which satisfy the forward secrecy and KCI properties discussed in {{security-considerations}}).",
              "createdAt": "2020-09-16T18:36:41Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 472,
              "body": "It needs to be KCI resistant and also forward secure. Also, PQ AKE is not enough to PQ-protect data, also the data encryption scheme needs to be PQ secure.",
              "createdAt": "2020-09-16T18:41:23Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            },
            {
              "originalPosition": 792,
              "body": "Two comments on other parts of the specification:\r\n- Please add Greg Rubin to the list of Acknowledgments \r\n- I would change the following sentence:\r\nNote that this does not prevent a malicious server from conducting a dictionary attack on inputs provided by the client. OPAQUE assumes the server is honest, and only guarantees safeguards against parties who may later compromise the server and any stored user account information.\r\ninto:\r\nNote that a corrupted server can run an exhaustive offline dictionary attack to validate guesses for the user's password; this is inevitable in any aPAKE protocol. (OPAQUE enables a defense against such offline dictionary attacks by distributing the server so that an offline attack is only possible if all - or a minimal number of - servers are compromised.)\r\n",
              "createdAt": "2020-09-16T19:04:52Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTkzOTM0",
          "commit": {
            "abbreviatedOid": "a64bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T11:52:58Z",
          "updatedAt": "2020-09-19T11:52:58Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "It's currently not part of the OPRF API, so I left it off the list above. If the OPRF draft changes, we can change this too.",
              "createdAt": "2020-09-19T11:52:58Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTkzOTYz",
          "commit": {
            "abbreviatedOid": "a64bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T11:53:37Z",
          "updatedAt": "2020-09-19T11:53:38Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "What I meant is that this document doesn't intend to specify, describe, etc *new* AKEs, but I see how this is confusing. I'll just remove it.",
              "createdAt": "2020-09-19T11:53:37Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTk0MDE4",
          "commit": {
            "abbreviatedOid": "a64bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T11:54:51Z",
          "updatedAt": "2020-09-19T11:54:51Z",
          "comments": [
            {
              "originalPosition": 401,
              "body": "I think this entire paragraph is probably obsolete. I'll just remove it.",
              "createdAt": "2020-09-19T11:54:51Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTk0MDYw",
          "commit": {
            "abbreviatedOid": "a64bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T11:55:34Z",
          "updatedAt": "2020-09-19T11:55:35Z",
          "comments": [
            {
              "originalPosition": 438,
              "body": "That's a nice rewrite -- I'll take it!",
              "createdAt": "2020-09-19T11:55:34Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTk1NDM2",
          "commit": {
            "abbreviatedOid": "adb6579"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T12:23:49Z",
          "updatedAt": "2020-09-19T12:23:49Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "Fixed!",
              "createdAt": "2020-09-19T12:23:49Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxOTk1NDQ0",
          "commit": {
            "abbreviatedOid": "adb6579"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-19T12:23:54Z",
          "updatedAt": "2020-09-19T12:23:54Z",
          "comments": [
            {
              "originalPosition": 305,
              "body": "Fixed!",
              "createdAt": "2020-09-19T12:23:54Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDY5MDU3",
          "commit": {
            "abbreviatedOid": "adb6579"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T00:44:07Z",
          "updatedAt": "2020-09-22T00:44:08Z",
          "comments": [
            {
              "originalPosition": 874,
              "body": "Add a reference to the OPAQUE paper at the end of the parentheses",
              "createdAt": "2020-09-22T00:44:07Z",
              "updatedAt": "2020-09-22T01:56:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDY5MTE2",
          "commit": {
            "abbreviatedOid": "adb6579"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T00:44:21Z",
          "updatedAt": "2020-09-22T00:44:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4MzAxNTY3",
      "title": "Clarify that keys must be unique per account.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/57",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We can address private key possession proofs and WebAuthn in a future change!",
      "createdAt": "2020-09-16T23:36:25Z",
      "updatedAt": "2020-09-18T12:40:32Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "e1ff2f58342b48bb881538e3f80fa77e9af85096",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/key-reuse",
      "headRefOid": "baf190fd07fbe640d60dd0cbf99ef7e0d6ad7ee0",
      "closedAt": "2020-09-18T12:40:32Z",
      "mergedAt": "2020-09-18T12:40:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "eb5855c74d8068fdcd6267bc8beeb7865e8132b8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxMTE3ODMx",
          "commit": {
            "abbreviatedOid": "baf190f"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T03:02:01Z",
          "updatedAt": "2020-09-18T03:02:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkzNzk2NDI5",
      "title": "Update draft-irtf-cfrg-opaque.md",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/61",
      "state": "MERGED",
      "author": "hugokraw",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I made some minir edits, nothing worth highlighting I think.\r\nTwo issues that we may want to address before submitting are:\r\n\r\n1. We say IBM has a patent on HMQV. Is that enough (for now at least) or do we need to have some formal IP notice?\r\n\r\n2. Section 6.3 (called from section 3.2 and 4.2.1) refers to SP800-56A Sec 5.6.2.3.4 which seems to be phrased for ephemeral keys while in the context of Sec 3.2 we talk about static ones. More importantly, the NIST document omits any tests of membership as they assume/require cofactor clearing. Is this something we want to assume/require ourselves? I thought we would \"outsource\" these issues to documents describing the curves themselves as the choice between explicit membership tests, prime order tests, cofactor operations, etc. may depend on the specific curve. If you do not want to get into these issues now (I am happy not to), we should still mention membership tests in Section 6.3. \r\n\r\nOnce we are done with these two issues, we can submit.\r\n",
      "createdAt": "2020-09-27T23:32:55Z",
      "updatedAt": "2020-09-28T18:33:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "13b1c0dcf6489faf7ca72b102358eda7168bee31",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "hugokraw-patch-1",
      "headRefOid": "e3e25988db565e6c8d2eeb16fad92ca0e165d94c",
      "closedAt": "2020-09-28T18:33:11Z",
      "mergedAt": "2020-09-28T18:33:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3c9462c70a3f2966d0b2ab3cfd8dafc805fae563"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> We say IBM has a patent on HMQV. Is that enough (for now at least) or do we need to have some formal IP notice?\r\n\r\nI think you can submit IPR here: https://datatracker.ietf.org/ipr/\r\n\r\n> If you do not want to get into these issues now (I am happy not to), we should still mention membership tests in Section 6.3.\r\n\r\nI think this is covered by \"MUST validate the other party's public key(s) used for the execution of OPAQUE\", no? If not, what would you change?",
          "createdAt": "2020-09-28T14:31:58Z",
          "updatedAt": "2020-09-28T14:31:58Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding:\r\n\r\n> >If you do not want to get into these issues now (I am happy not to), we should still mention membership tests in Section 6.3.\r\n\r\n> I think this is covered by \"MUST validate the other party's public key(s) used for the execution of OPAQUE\", no? If not, what would you change?\r\n\r\nThe problem is that we refer to the NIST document that does not include membership tests as they assume cofactor clearing which we don't assume. \r\nNote that we say explicitly:\r\n\r\nepkU, epkS are Diffie-Hellman ephemeral public keys chosen by user and server, respectively, which MUST be validated to be in the correct group (see {{validation}});\r\n\r\nbut then the membership test is lost in the reference to NIST.\r\n",
          "createdAt": "2020-09-28T16:55:28Z",
          "updatedAt": "2020-09-28T16:55:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The NIST document pertains only to the NIST curves, which don't require cofactor clearing (h=1). The other curves may involve cofactor clearing, but I think that's covered by the public key validation text. ",
          "createdAt": "2020-09-28T17:24:15Z",
          "updatedAt": "2020-09-28T17:24:15Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh. Ok. I missed the (clear) point that this is an example that only pertains to the NIST curves. Sorry for the confusion. You can go ahead and submit. Thanks.",
          "createdAt": "2020-09-28T18:25:38Z",
          "updatedAt": "2020-09-28T18:25:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Perfect -- thanks!",
          "createdAt": "2020-09-28T18:33:08Z",
          "updatedAt": "2020-09-28T18:33:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk3NTQ0MTQ2",
      "title": "Fixing typo in CredentialExtension definition and updating affiliation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/64",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I believe the type of the parameter `data` in `CredentialExtension` should be `opaque`, since there is no `CredentialData` defined anywhere.\r\n\r\nAlso updating my affiliation",
      "createdAt": "2020-10-05T02:21:20Z",
      "updatedAt": "2020-12-16T09:54:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "3c9462c70a3f2966d0b2ab3cfd8dafc805fae563",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_typo_1",
      "headRefOid": "405d25a53e81a3a3e51207f543712330b37969e3",
      "closedAt": "2020-10-19T18:29:41Z",
      "mergedAt": "2020-10-19T18:29:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "225bc77bec4a91c86519858ac20671fc6cd82aab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDQ2NzE1",
          "commit": {
            "abbreviatedOid": "405d25a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-19T18:29:35Z",
          "updatedAt": "2020-10-19T18:29:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2MjE2MTYw",
      "title": "Changing envelope representation in CredentialResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/66",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #62 ",
      "createdAt": "2020-10-19T19:07:37Z",
      "updatedAt": "2020-12-16T09:54:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "225bc77bec4a91c86519858ac20671fc6cd82aab",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_issue_62",
      "headRefOid": "05d229212a21eb826abe1c9c7e29bff26d86b52b",
      "closedAt": "2020-10-20T00:47:33Z",
      "mergedAt": "2020-10-20T00:47:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "550c550ecdc86ce362d613afebad67ce186cae73"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjU0OTc4",
          "commit": {
            "abbreviatedOid": "05d2292"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T00:47:29Z",
          "updatedAt": "2020-10-20T00:47:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3ODgyNjY4",
      "title": "Add a preliminary Sage implementation with many TODOs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/70",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This gets us started towards test vectors, with something that's \"as close\" to the specification as possible. There's definitely lots of ways this can be improved, including adding proper configuration and agility support, supporting different credentials in client and server, implementing a proper password file, etc. If this generally seems useful, we can add these missing pieces and then wrap it with code that generates test vectors from a variety of flows. \r\n\r\nNote that this *does not* have AKE integration. It only implements the OPAQUE core protocol. For the specification, I wonder if it makes sense to include test vectors for both the core protocol and AKE instantiations. \r\n\r\n@kevinlewi, please have a look!",
      "createdAt": "2020-10-21T21:47:26Z",
      "updatedAt": "2020-10-28T01:21:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "550c550ecdc86ce362d613afebad67ce186cae73",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/ref-impl",
      "headRefOid": "dbfb4c2d52519f01ed14fc440e28858c9a9485c8",
      "closedAt": "2020-10-28T01:21:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now -- I'll re-open when the 3DH implementation is in place.",
          "createdAt": "2020-10-28T01:21:43Z",
          "updatedAt": "2020-10-28T01:21:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 71,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3OTU3MDY4",
      "title": "Remove pkS from CredentialResponse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/71",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #63 ",
      "createdAt": "2020-10-22T01:42:06Z",
      "updatedAt": "2020-12-16T09:54:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "550c550ecdc86ce362d613afebad67ce186cae73",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_issue_63",
      "headRefOid": "dddf8300098fcd9aa71c4c54b0fa5e801008553d",
      "closedAt": "2020-10-23T21:04:20Z",
      "mergedAt": "2020-10-23T21:04:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "630173e46eaff00862dbb8446aa8a3c0b0bed8d1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDA5NTEz",
          "commit": {
            "abbreviatedOid": "dddf830"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T21:04:16Z",
          "updatedAt": "2020-10-23T21:04:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3OTcxMjYz",
      "title": "Omitting idU from RegistrationRequest and CredentialRequest",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/73",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This removes the inclusion of idU from RegistrationRequest and CredentialRequest (see #65)\r\n\r\nI also noticed that the functions `RecoverCredentials` and `FinalizeRequest` should either not take idU, or should take idU, idS, and pkU as parameters. In this PR I simply made RecoverCredentials also take idU as a parameter, but I opened #72 to discuss this further.",
      "createdAt": "2020-10-22T02:33:22Z",
      "updatedAt": "2020-12-16T09:54:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "630173e46eaff00862dbb8446aa8a3c0b0bed8d1",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "fix_issue_65",
      "headRefOid": "7b76e78abfaa2a6a5f37f2b83438928d774b9412",
      "closedAt": "2020-10-27T22:59:30Z",
      "mergedAt": "2020-10-27T22:59:29Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b775d13311dcc73bbf9eefad1b00453c9ba1bb2f"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood : This should be ready to review",
          "createdAt": "2020-10-27T03:27:32Z",
          "updatedAt": "2020-10-27T03:27:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjEyMzE1",
          "commit": {
            "abbreviatedOid": "7b76e78"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-27T22:59:25Z",
          "updatedAt": "2020-10-27T22:59:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0NTExNTMzNjQ5",
      "title": "Remove the performance considerations section.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/76",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #5.\r\n\r\nIt was somewhat stale, and I'm not sure it adds much to the document.\r\n\r\ncc @kevinlewi ",
      "createdAt": "2020-10-28T13:08:34Z",
      "updatedAt": "2020-11-02T22:18:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "30a4a795bf17e7352a4c197d621dd4ede1db8101",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/remove-perf-section",
      "headRefOid": "85366a81b2bcfe89beb2c4b6dd8c874146538602",
      "closedAt": "2020-11-02T22:18:22Z",
      "mergedAt": "2020-11-02T22:18:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a41ef961ea49207c1ad256b1457631b673e5d198"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": " This is fine by me",
          "createdAt": "2020-10-28T19:13:20Z",
          "updatedAt": "2020-10-28T19:13:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE0MzkxOTE1",
      "title": "Swap labels, and adopt new OPRF suites.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/78",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @kevinlewi, I'll target submission today!",
      "createdAt": "2020-11-02T23:28:48Z",
      "updatedAt": "2020-11-02T23:35:46Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "a41ef961ea49207c1ad256b1457631b673e5d198",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/align-with-oprf",
      "headRefOid": "88c7e056eb21ae40766714d5add629e8c55ba81d",
      "closedAt": "2020-11-02T23:35:46Z",
      "mergedAt": "2020-11-02T23:35:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "25c0a16c4983d50ae4a75b415651034092ada78b"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Great!",
          "createdAt": "2020-11-02T23:34:33Z",
          "updatedAt": "2020-11-02T23:34:33Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 80,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE3NDU2Mzk3",
      "title": "Clarify base mode variant usage of voprf",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/80",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #79 ",
      "createdAt": "2020-11-09T04:22:23Z",
      "updatedAt": "2020-12-16T09:54:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "25c0a16c4983d50ae4a75b415651034092ada78b",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "clarify_base_mode_voprf",
      "headRefOid": "76c1112254a38e287019dc7d5ed14d8c1c96bbb8",
      "closedAt": "2020-11-09T16:31:46Z",
      "mergedAt": "2020-11-09T16:31:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "dd8581b6ac1d884673c017bd3666c6783f70baee"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NDMzNjMy",
          "commit": {
            "abbreviatedOid": "76c1112"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-09T16:31:35Z",
          "updatedAt": "2020-11-09T16:31:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE4ODI2NjI0",
      "title": "Defining idU and idS in AKE section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/81",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Points mentioned after discussion from #74 \r\n\r\n- Removes the sending of idU in KE1\r\n- Adds clarification text around what idU and idS refers to in the AKE key derivation. By default, they will be taken from the idU and idS specified in the envelope. If they are not specified, then they are taken to be equal to pkU and pkS.\r\n- Also clarify that if pkU is not in the envelope, then it must be computed from skU.",
      "createdAt": "2020-11-10T23:32:21Z",
      "updatedAt": "2020-12-16T09:54:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "dd8581b6ac1d884673c017bd3666c6783f70baee",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "ake_ids",
      "headRefOid": "73e04f431366c4f5275d5ff7fd311976be41d0de",
      "closedAt": "2020-11-12T23:32:13Z",
      "mergedAt": "2020-11-12T23:32:13Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "deeeead3207280710202773f68edb85c8171704b"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I am ok with these changes, they reflect the conclusions of our discussion. \r\nI have a feeling that people will wonder about why are pkU, pkS set as default identities and in what cases they should or should not set different values for idU and idS.  Answering these question would require iterating some of the issues discussed in our thread (why identities are needed at all, what's their roles, etc.). Do you think there is some text you could write to explain some of these things and preempt some of the confusion? I would not dare to write such text myself :-)",
          "createdAt": "2020-11-11T04:11:33Z",
          "updatedAt": "2020-11-11T04:11:33Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am ok with these changes, they reflect the conclusions of our discussion.\r\n> I have a feeling that people will wonder about why are pkU, pkS set as default identities and in what cases they should or should not set different values for idU and idS. Answering these question would require iterating some of the issues discussed in our thread (why identities are needed at all, what's their roles, etc.). Do you think there is some text you could write to explain some of these things and preempt some of the confusion? I would not dare to write such text myself :-)\r\n\r\n@hugokraw Please take a look at the text that I have added to the \"Security Considerations\" section, also copied below:\r\n\r\n```\r\n## User and server identities\r\n\r\nThe user identity (idU) and server identity (idS) are optional parameters\r\nwhich are left to the application to designate as monikers for the client\r\nand server. If the application layer does not supply values for these\r\nparameters, then they will be omitted from the creation of the envelope\r\nduring the registration stage. Furthermore, they will be substituted with\r\nidU = pkU and idS = pkS during the authenticated key exchange stage.\r\n\r\nThe advantage to supplying a custom idU and idS (instead of simply relying\r\non a fallback to pkU and pkS) is that the client can then ensure that any\r\nmappings between idU and pkU (and idS and pkS) are protected by the\r\nauthentication from the envelope. Then, the client can attempt to verify\r\nthat the idU and idS contained in its envelope matches the idU and idS\r\nsupplied by the server.\r\n\r\nHowever, if this extra layer of verification is unnecessary for the\r\napplication, then simply leaving idU and idS unspecified is acceptable.\r\n```\r\n---\r\n\r\nLet me know if you think we should edit this.",
          "createdAt": "2020-11-12T22:17:38Z",
          "updatedAt": "2020-11-12T22:17:38Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I like it. Two edits:\r\n- remove \"attempt to\"\r\n- edit last sentence to: then simply leaving idU and idS unspecified, and using pkU and pkS instead, is acceptable.",
          "createdAt": "2020-11-12T22:58:28Z",
          "updatedAt": "2020-11-12T22:58:28Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Done. Thanks!",
          "createdAt": "2020-11-12T23:13:24Z",
          "updatedAt": "2020-11-12T23:13:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjkzNDc3",
          "commit": {
            "abbreviatedOid": "65b3353"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This matches my understanding. @hugokraw, can you please have a look?",
          "createdAt": "2020-11-10T23:36:27Z",
          "updatedAt": "2020-11-10T23:36:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 86,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIxOTI3NTQ5",
      "title": "Remove protocol messages.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/86",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #85. \r\n\r\ncc @kevinlewi, @stef",
      "createdAt": "2020-11-16T20:21:12Z",
      "updatedAt": "2020-11-16T20:31:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "deeeead3207280710202773f68edb85c8171704b",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/remove-protocol-messages",
      "headRefOid": "dc89d10a1c38b16fba682c0c61a0b7f31203a4a6",
      "closedAt": "2020-11-16T20:31:56Z",
      "mergedAt": "2020-11-16T20:31:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0e1da280c97f4402d4f2fd56d4ef4451b9d46ac1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNzIxMDg5",
          "commit": {
            "abbreviatedOid": "a274e8e"
          },
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T20:29:37Z",
          "updatedAt": "2020-11-16T20:30:08Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Perhaps we want to keep this sentence:\r\n\r\n> This section specifies the structure of these protocol\r\nmessages using TLS notation (see {{RFC8446}}, Section 3).\r\n\r\nSince it still applies for the remainder of the document",
              "createdAt": "2020-11-16T20:29:37Z",
              "updatedAt": "2020-11-16T20:31:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 92,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI4Nzg1NjQ5",
      "title": "Update to some minor details of the current VOPRF draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/92",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "cc./ @chris-wood ",
      "createdAt": "2020-11-27T20:56:26Z",
      "updatedAt": "2020-12-01T15:40:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "0e1da280c97f4402d4f2fd56d4ef4451b9d46ac1",
      "headRepository": "claucece/draft-irtf-cfrg-opaque",
      "headRefName": "master",
      "headRefOid": "19de398f26ef20e44ac7dceb1bb165b9c2013043",
      "closedAt": "2020-12-01T15:40:33Z",
      "mergedAt": "2020-12-01T15:40:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8894db3c031a56873bbd536f7fe3eaf4dc1e4ad6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwOTgyNDMy",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks! I've been meaning to get around to this. I think some things regressed, which I've noted. Otherwise, this is good.",
          "createdAt": "2020-11-30T14:52:49Z",
          "updatedAt": "2020-11-30T15:01:11Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Can we please revert this? `KeyGen` returns a public and private key pair. It just so happens that OPAQUE ignores the public key for per-user keys. \r\n\r\nAlternatively, we can change `KeyGen` notation in pseudocode below.",
              "createdAt": "2020-11-30T14:52:49Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            },
            {
              "originalPosition": 38,
              "body": "Why did we remove this clarifying text?",
              "createdAt": "2020-11-30T14:53:21Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            },
            {
              "originalPosition": 71,
              "body": "Perhaps we should use notation `SerializeScalar`?",
              "createdAt": "2020-11-30T14:55:39Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            },
            {
              "originalPosition": 149,
              "body": "Please revert this change.",
              "createdAt": "2020-11-30T14:59:12Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            },
            {
              "originalPosition": 262,
              "body": "This should be reverted. It's the server that looks up envU using idU.",
              "createdAt": "2020-11-30T14:59:52Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDMyNDg4",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:43:01Z",
          "updatedAt": "2020-11-30T15:43:02Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I'll revert it ;)",
              "createdAt": "2020-11-30T15:43:02Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDMzMDI1",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:43:37Z",
          "updatedAt": "2020-11-30T15:43:37Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The data returned from the OPRF functions is always already encoded/serialized, so no need to specify how to encode.",
              "createdAt": "2020-11-30T15:43:37Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDMzNDMy",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:44:04Z",
          "updatedAt": "2020-11-30T15:44:04Z",
          "comments": [
            {
              "originalPosition": 262,
              "body": "Ah, ok. Reverting this.",
              "createdAt": "2020-11-30T15:44:04Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDM0OTI3",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:45:36Z",
          "updatedAt": "2020-11-30T15:45:36Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Except for the scalar that is returned from `blind`.",
              "createdAt": "2020-11-30T15:45:36Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDM1ODI5",
          "commit": {
            "abbreviatedOid": "53cc32c"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T15:46:30Z",
          "updatedAt": "2020-11-30T15:46:30Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Agreed ;)",
              "createdAt": "2020-11-30T15:46:30Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMDUwMjU2",
          "commit": {
            "abbreviatedOid": "40c68c9"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-30T16:00:49Z",
          "updatedAt": "2020-11-30T16:00:50Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "Done.",
              "createdAt": "2020-11-30T16:00:49Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTgxNzg4",
          "commit": {
            "abbreviatedOid": "40c68c9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-01T14:56:02Z",
          "updatedAt": "2020-12-01T14:56:03Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-12-01T14:56:03Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTgyMDQx",
          "commit": {
            "abbreviatedOid": "40c68c9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-01T14:56:17Z",
          "updatedAt": "2020-12-01T14:56:17Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-12-01T14:56:17Z",
              "updatedAt": "2020-12-01T14:56:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTgyNTE2",
          "commit": {
            "abbreviatedOid": "19de398"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-01T14:56:42Z",
          "updatedAt": "2020-12-01T14:56:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 93,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMwMzYyMDYy",
      "title": "Move idU to CreateCredentialResponse parameter.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/93",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The OPAQUE wrapper protocol is responsible for transmitting idU from\r\nclient to server. OPAQUE does not use it for anything other than password\r\nfile lookup.\r\n\r\nCloses #88.\r\n\r\ncc @kevinlewi, @stef",
      "createdAt": "2020-12-01T14:55:31Z",
      "updatedAt": "2020-12-02T03:15:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "8894db3c031a56873bbd536f7fe3eaf4dc1e4ad6",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/move-idU-to-parameter",
      "headRefOid": "8d779da370c0ba14e5f35a4539a920a303fb5a8f",
      "closedAt": "2020-12-02T03:15:07Z",
      "mergedAt": "2020-12-02T03:15:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "455538b2043587ea9e455e4f64b111a012dacee7"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks good, but I do have a general comment that maybe we can move to discussion in an issue:\r\n\r\nWould it make more sense to perhaps make kU, envU, pkU parameters to CreateCredentialResponse? The reason is because \"LookupUserRecord\" is not actually defined anywhere, and is only run in the wrapper protocol, so it may cause confusion.\r\n\r\n",
          "createdAt": "2020-12-02T02:14:32Z",
          "updatedAt": "2020-12-02T02:14:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Would it make more sense to perhaps make kU, envU, pkU parameters to CreateCredentialResponse? The reason is because \"LookupUserRecord\" is not actually defined anywhere, and is only run in the wrapper protocol, so it may cause confusion.\r\n\r\nYeah, I like that suggestion. Stand by while I make the change!",
          "createdAt": "2020-12-02T02:23:00Z",
          "updatedAt": "2020-12-02T02:23:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kevinlewi fixed!",
          "createdAt": "2020-12-02T02:25:54Z",
          "updatedAt": "2020-12-02T02:25:54Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Cool, looks! Minor nit: Shouldn't kU, envU, pkU be listed in the Input, not the Parameters (and also following an update to read as: \"CreateCredentialResponse(request)\" -> \"CreateCredentialResponse(request, kU, envU, pkU))",
          "createdAt": "2020-12-02T02:27:03Z",
          "updatedAt": "2020-12-02T02:27:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I opted to keep them as parameters since they're handled by the wrapper protocol and provided by context. Would it be more clear if they were inputs?",
          "createdAt": "2020-12-02T02:58:41Z",
          "updatedAt": "2020-12-02T02:58:41Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can leave it to a separate change since it is probably a separate discussion, but I also noted that for \"CreateRegistrationResponse\", pkS is an input instead of a parameter. Not sure if that should change, but it seems like they should both be parameters or both be inputs.\r\n\r\nAnyway, not a big deal either way, at least for now!",
          "createdAt": "2020-12-02T03:01:29Z",
          "updatedAt": "2020-12-02T03:01:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch -- moved to inputs!",
          "createdAt": "2020-12-02T03:08:23Z",
          "updatedAt": "2020-12-02T03:08:23Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Excellent",
          "createdAt": "2020-12-02T03:14:39Z",
          "updatedAt": "2020-12-02T03:14:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 95,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMxNDM3MjM4",
      "title": "Remove wrapper RequestMetadata type.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/95",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #94.\r\n\r\ncc @kevinlewi ",
      "createdAt": "2020-12-03T03:55:58Z",
      "updatedAt": "2020-12-03T04:14:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "455538b2043587ea9e455e4f64b111a012dacee7",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/remove-metadata-wrapper",
      "headRefOid": "fe4625c9650c5added4c1b4ea1105707886a6c7b",
      "closedAt": "2020-12-03T04:14:20Z",
      "mergedAt": "2020-12-03T04:14:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c4246341b42614facba070e74733cd6391a6bc80"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI0OTA0",
          "commit": {
            "abbreviatedOid": "ab207c2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T03:58:22Z",
          "updatedAt": "2020-12-03T03:58:23Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "\"a RequestMetadata structure\" should be replaced with \"an OPRF Scalar value\"",
              "createdAt": "2020-12-03T03:58:23Z",
              "updatedAt": "2020-12-03T04:07:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI1Mzk1",
          "commit": {
            "abbreviatedOid": "ab207c2"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T03:59:48Z",
          "updatedAt": "2020-12-03T03:59:48Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Where is SerializedElement defined? Perhaps a reference to an RFC #?",
              "createdAt": "2020-12-03T03:59:48Z",
              "updatedAt": "2020-12-03T04:07:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI3NDEw",
          "commit": {
            "abbreviatedOid": "ab207c2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T04:06:07Z",
          "updatedAt": "2020-12-03T04:06:07Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "Missed this one -- thanks!",
              "createdAt": "2020-12-03T04:06:07Z",
              "updatedAt": "2020-12-03T04:07:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI3ODIy",
          "commit": {
            "abbreviatedOid": "fe4625c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-03T04:07:25Z",
          "updatedAt": "2020-12-03T04:07:26Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I clarified that this is an alias for a serialized group element, i.e., output of `Serialize()`.",
              "createdAt": "2020-12-03T04:07:26Z",
              "updatedAt": "2020-12-03T04:07:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDI5Mzkz",
          "commit": {
            "abbreviatedOid": "fe4625c"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good!",
          "createdAt": "2020-12-03T04:12:18Z",
          "updatedAt": "2020-12-03T04:12:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 101,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQxNTUyNzM1",
      "title": "Reference \"Partitioning Oracle Attacks\" paper.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/101",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #100.\r\n\r\ncc @hugokraw, @stef",
      "createdAt": "2020-12-17T02:10:12Z",
      "updatedAt": "2020-12-21T16:42:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "c4246341b42614facba070e74733cd6391a6bc80",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/ref-partition-oracles",
      "headRefOid": "baa0242e64db498dbdea171d3de227a39cdf9486",
      "closedAt": "2020-12-21T16:42:15Z",
      "mergedAt": "2020-12-21T16:42:15Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d7cb97511bbfa2a55c29b44600be11d0cb5ae3cc"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> In this case we would say that while the paper requires it, this specification does not (in particular, partition attacks as those described in the Julia et al paper are irrelevant to this specification).\r\n\r\nSo, to be clear, would you just drop the reference from this PR? If so, we lose a pointer to the RKR definition, which I was hoping to outsource to somewhere else. ",
          "createdAt": "2020-12-19T15:28:32Z",
          "updatedAt": "2020-12-19T15:28:32Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the following text in the security considerations addresses this issue.\r\n\r\nWe note that the analysis of OPAQUE from {{OPAQUE}} requires the authenticated encryption scheme used to produce envU to have a special property called random key-robustness (or key-committing). This specification enforces this property by utilizing encryption-then-hmac in the construction of envU. There is no option to use another authenticated-encryption scheme with this specification.  (Deviating from the key-robustness requirement may open the protocol to attacks, e.g., {{Len}}.) We remark that export_key for authentication and/or encryption requires no special properties from the authentication/encryption schemes as long as exporter_key is used only after the EnvU is validated (i.e., after the HMAC in RecoverCredentials passes verification).",
          "createdAt": "2020-12-20T22:09:31Z",
          "updatedAt": "2020-12-20T22:09:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That's much better. I'll update this PR with that suggestion and then close out this issue. ",
          "createdAt": "2020-12-21T16:34:27Z",
          "updatedAt": "2020-12-21T16:34:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzA4MTgx",
          "commit": {
            "abbreviatedOid": "03b08db"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Wait with this reference. Not sure if we need to touch on this point at all as there is no key robustness requirement for this specification. At most, it could be discussed in the security considerations just because the OPAQUE paper requires it. In this case we would say that while the paper requires it, this specification does not (in particular, partition attacks as those described in the Julia et al paper are irrelevant to this specification).  ",
          "createdAt": "2020-12-17T06:21:27Z",
          "updatedAt": "2020-12-17T06:21:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 102,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQyNDc4ODY3",
      "title": "Changing envelope definition to  support two fixed modes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/102",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #99.\r\n\r\nThis defines two modes, `base` and `customIdentifier` for the envelope. The credentials are incorporated in the `SecretCredentials` and `CleartextCredentials` structs,\r\ndepending on the mode set by the value of `EnvelopeMode`:\r\n\r\n```\r\nenum {\r\n  base(1),\r\n  customIdentifier(2),\r\n  (255)\r\n} EnvelopeMode;\r\n```\r\n\r\nThe `base` mode defines `SecretCredentials` and `CleartextCredentials` as follows:\r\n\r\n```\r\nstruct {\r\n  opaque skU<1..2^16-1>;\r\n} SecretCredentials;\r\n\r\nstruct {\r\n  opaque pkS<1..2^16-1>;\r\n} CleartextCredentials;\r\n```\r\n\r\nThe `customIdentifier` mode defines `SecretCredentials` and `CleartextCredentials` as follows:\r\n\r\n```\r\nstruct {\r\n  opaque skU<1..2^16-1>;\r\n} SecretCredentials;\r\n\r\nstruct {\r\n  opaque pkS<1..2^16-1>;\r\n  opaque idU<0..2^16-1>;\r\n  opaque idS<0..2^16-1>;\r\n} CleartextCredentials;\r\n```\r\n\r\nThese credentials are embedded into the following `Envelope` structure with\r\nencryption and authentication.\r\n\r\n```\r\nstruct {\r\n  InnerEnvelopeMode mode;\r\n  opaque nonce[32];\r\n  opaque ct<1..2^16-1>;\r\n} InnerEnvelope;\r\n\r\nstruct {\r\n  InnerEnvelope contents;\r\n  opaque auth_tag[Nh];\r\n} Envelope;\r\n```\r\n\r\nAlso updated the `FinalizeRequest` and `RecoverCredentials` procedures accordingly. Also updated the fixed string to read `OPAQUE01` instead of `OPAQUE00`.",
      "createdAt": "2020-12-18T11:16:37Z",
      "updatedAt": "2021-01-04T19:27:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "af3cd96b76fd8aaa1bf83f290f7714973ab8e64b",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "dual_mode_envelope",
      "headRefOid": "56a30f30e70f824e4ad9ad42497126c6103a14bd",
      "closedAt": "2021-01-04T19:27:56Z",
      "mergedAt": "2021-01-04T19:27:56Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0e39200d483f37d5b1be63a5fecc0b94017ccc96"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "* I added a note in the configurations section: \"The EnvelopeMode value is defined in {{data-types}} and must also be agreed upon between the client and server.\"\r\n* Thanks, good catch. Removed!\r\n* The expectation is that idS should come from the wrapper protocol. I think it is unnecessary to include idS in `RegistrationResponse`, regardless of the mode. Therefore, I think it is unnecessary to change anything here regarding this point. What do you think?",
          "createdAt": "2020-12-21T04:04:24Z",
          "updatedAt": "2020-12-21T04:04:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The expectation is that idS should come from the wrapper protocol. I think it is unnecessary to include idS in RegistrationResponse, regardless of the mode. Therefore, I think it is unnecessary to change anything here regarding this point. What do you think?\r\n\r\nI think that's fine, but I would make things more explicit. If the wrapper protocol provides them, then it might as well also supply them to the relevant procedures for constructing the envelope. Then we could replace this:\r\n\r\n\"Create cleartext_credentials with credentials matching those needed to construct the `CleartextCredentials` structure\"\r\n\r\nwith something like:\r\n\r\n\"Create `CleartextCredentials` structure cleartext_credentials where cleartext_credentials.idU = idU, cleartext_credentials.idS = idS, cleartext_credentials.pkS = pkS.\"",
          "createdAt": "2020-12-21T15:27:39Z",
          "updatedAt": "2020-12-21T15:27:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Following up on the comment above, we might simplify things by delegating the \"credential construction\" logic to the wrapper protocol, which (a) knows the mode and (b) has the relevant information (skU, idU, pkS, idS, etc). That would make the interface to `FinalizeRequest` something like so:\r\n\r\n```\r\nFinalizeRequest(pwdU, creds, blind, response)\r\n```\r\n\r\nWhere `creds` contains the `secret_credentials` and `cleartext_credentials`, already in wire format form, to use when creating the envelope. ",
          "createdAt": "2020-12-22T19:01:10Z",
          "updatedAt": "2020-12-22T19:01:10Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed comments, ready for a re-review",
          "createdAt": "2020-12-25T03:20:56Z",
          "updatedAt": "2020-12-25T03:20:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2MDI3MTA3",
          "commit": {
            "abbreviatedOid": "b627ad5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I like this :) I have a couple questions that I hope we can resolve moving forward:\r\n\r\n- The mode is currently implicit in registration and login. I assume the expectation is that configurations specify the mode so that it's known to both peers. We should probably say that somewhere. I left a suggestion to include this note, but we probably ought to expand upon it in the configuration section.\r\n- The `RegistrationResponse` definition still includes a list of secret and cleartext credential types. This can be removed given that these are dependent on the mode. \r\n- Credential construction is somewhat vague in the current description, especially since idU and idS are not passed as parameters to the main registration and login routines. As an implementor, is the expectation that idS comes from the client's wrapper protocol, or is it sent from server to client as part of the registration response? (My understanding is the latter.) Since there are only two modes, we might, for example, define two mode-specific `FinalizeRequest` variants, each of which takes the appropriate parameters. (The base mode variant includes what is currently there now, whereas the custom-mode variant might also include idU (and idS depending on the answer to the previous question).)\r\n\r\nObviously, we can work on these things incrementally and merge in pieces, but I wanted to flag these questions to start.",
          "createdAt": "2020-12-20T15:24:41Z",
          "updatedAt": "2020-12-20T15:44:19Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "```suggestion\r\ncovering `InnerEnvelope` and `CleartextCredentials`.\r\n```",
              "createdAt": "2020-12-20T15:24:42Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            },
            {
              "originalPosition": 278,
              "body": "```suggestion\r\nthen these values (independently) default to pkU and pkS instead.\r\n```",
              "createdAt": "2020-12-20T15:32:58Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            },
            {
              "originalPosition": 117,
              "body": "```suggestion\r\n`SecretCredentials` and `CleartextCredentials` is described in {{finalize-request}}.\r\n\r\nThe `EnvelopeMode` value is specified as part of a configuration. \r\n```",
              "createdAt": "2020-12-20T15:33:13Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NDYxNDAz",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-21T15:27:26Z",
          "updatedAt": "2020-12-21T15:27:27Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "This implies (to me) some sort of negotiation. Since the EnvelopeMode is already in the tuple above, I'd drop that bit:\r\n\r\n```suggestion\r\nThe EnvelopeMode value is defined in {{data-types}}.\r\n```",
              "createdAt": "2020-12-21T15:27:26Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MjgzNzUz",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-22T18:31:25Z",
          "updatedAt": "2020-12-22T18:31:26Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "Unrelated: should we lift `pkU` to the wrapper protocol, too? Specifically, perhaps `FinalizeRequest` should produce an envelope and export key, and the wrapper protocol is then responsible for sending the envelope and `pkU` to the server.",
              "createdAt": "2020-12-22T18:31:26Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Mjk4ODcw",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-22T18:59:13Z",
          "updatedAt": "2020-12-22T18:59:14Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Also unrelated, but we can remove `request` here, as it's not used.",
              "createdAt": "2020-12-22T18:59:13Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3NzkzODUz",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "bytemare",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-23T10:53:23Z",
          "updatedAt": "2020-12-23T10:53:24Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "If SecretCredentials is always equal to the client secret, wouldn't it be more straightforward to put `pt = Serialize(secret)` ?",
              "createdAt": "2020-12-23T10:53:24Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Nzk1Mjg1",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "bytemare",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-23T10:56:19Z",
          "updatedAt": "2020-12-23T10:56:19Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "If I'm not mistaken, the InnerEnvelope should also specify the InnerEnvelopeMode, doesn't it?",
              "createdAt": "2020-12-23T10:56:19Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4MjI2NTU0",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-23T21:00:06Z",
          "updatedAt": "2020-12-23T21:00:06Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "It is used in line 468:\r\n\r\n```\r\nThe full procedure for constructing `Envelope` and `InnerEnvelope` from\r\n`SecretCredentials` and `CleartextCredentials` is described in {{finalize-request}}.\r\n```",
              "createdAt": "2020-12-23T21:00:06Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NzQzODc0",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-25T03:13:01Z",
          "updatedAt": "2020-12-25T03:13:01Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "As discussed offline, let's address this API change separately.",
              "createdAt": "2020-12-25T03:13:01Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NzQ0Mzc2",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-25T03:17:17Z",
          "updatedAt": "2020-12-25T03:17:18Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "I think it may be beneficial to keep this level of generality here in case we add support for other modes that set SecretCredentials to something else in the future. This will hopefully also coincide with the changes that will be made in #105 which will pass in a generic credentials parameter.",
              "createdAt": "2020-12-25T03:17:18Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NzQ0NjY0",
          "commit": {
            "abbreviatedOid": "42b3019"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-25T03:19:54Z",
          "updatedAt": "2020-12-25T03:19:55Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Good catch, thank you! Added to parameters.",
              "createdAt": "2020-12-25T03:19:54Z",
              "updatedAt": "2020-12-30T04:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMjgyNTYw",
          "commit": {
            "abbreviatedOid": "56a30f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-04T19:27:17Z",
          "updatedAt": "2021-01-04T19:27:17Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "I'll address this in a separate PR, since it seems related to the module boundary we discussed.",
              "createdAt": "2021-01-04T19:27:17Z",
              "updatedAt": "2021-01-04T19:27:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMjgyODg5",
          "commit": {
            "abbreviatedOid": "56a30f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-04T19:27:46Z",
          "updatedAt": "2021-01-04T19:27:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ4NTcyMTAw",
      "title": "Separate the core and wrapper protocol",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/106",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Lift wrapper-specific pieces, such as credential information and key material, out of the core protocol, where they are not used. Update the reference implementation to match.\r\n\r\nI might ignore the reference implementation for the time being, since it's kind of sloppy. But if you wanted to check it for consistency against the core module API boundary, that would be useful. \r\n\r\nCloses #105.",
      "createdAt": "2021-01-05T01:24:29Z",
      "updatedAt": "2021-01-06T21:48:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "0e39200d483f37d5b1be63a5fecc0b94017ccc96",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/core-separation",
      "headRefOid": "f4bb5b809a7a1786091f07e346c293d19319640d",
      "closedAt": "2021-01-06T21:48:01Z",
      "mergedAt": "2021-01-06T21:48:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "758c8a0314775f16f3c02c7741bf282de321f0cb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMjg2NzY5",
          "commit": {
            "abbreviatedOid": "bc8584d"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-06T02:37:17Z",
          "updatedAt": "2021-01-06T02:48:55Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "Why doesn't the client just send an instance of the `RegistrationUpload` function, which includes `pkU` and `envU`? It doesn't need to send `idU` since that is taken care of in the application layer and not necessary for the OPAQUE protocol",
              "createdAt": "2021-01-06T02:37:17Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            },
            {
              "originalPosition": 35,
              "body": "I think this should be an instance of the `RegistrationUpload` structure, not `envU`",
              "createdAt": "2021-01-06T02:37:40Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            },
            {
              "originalPosition": 200,
              "body": "Line 806 should output an instance of `Credentials`, then, right? (Currently it outputs a secret_credentials)",
              "createdAt": "2021-01-06T02:46:13Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            },
            {
              "originalPosition": 12,
              "body": "I believe this will be the only instance of a struct that we define in this document which never gets serialized. Why not just replace all instances with a tuple of (mode, secret_credentials, cleartext_credentials)? And note that the RecoverCredentials function doesn't actually need to return the cleartext_credentials or the mode...",
              "createdAt": "2021-01-06T02:48:19Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMjkxOTI2",
          "commit": {
            "abbreviatedOid": "bc8584d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-06T02:55:02Z",
          "updatedAt": "2021-01-06T02:55:02Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "You could, yeah. This is just a helper type to wrap up everything in that tuple. ",
              "createdAt": "2021-01-06T02:55:02Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMjkyMTc0",
          "commit": {
            "abbreviatedOid": "bc8584d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-06T02:55:49Z",
          "updatedAt": "2021-01-06T02:55:50Z",
          "comments": [
            {
              "originalPosition": 200,
              "body": "Hmm, it is nice if it just returns a `Credentials` type. I'll make the change!",
              "createdAt": "2021-01-06T02:55:49Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMzAyNjA5",
          "commit": {
            "abbreviatedOid": "bc8584d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-06T03:26:19Z",
          "updatedAt": "2021-01-06T03:26:20Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I intentionally reverted this so that the wrapper could construct `RegistrationUpload`, but on reflection that's probably not best. I'll revert this bit.",
              "createdAt": "2021-01-06T03:26:20Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyNDM5MDAy",
          "commit": {
            "abbreviatedOid": "83a1fb0"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Sorry, I think I missed this with my first pass, but pkS needs to be a part of CredentialResponse (so I would add back pkS everywhere). Other than that, looks good!",
          "createdAt": "2021-01-06T09:21:46Z",
          "updatedAt": "2021-01-06T09:23:38Z",
          "comments": [
            {
              "originalPosition": 187,
              "body": "pkS should not be removed -- see my last comment on #63 . The problem is that the pkS is no longer included in the envelope.",
              "createdAt": "2021-01-06T09:21:46Z",
              "updatedAt": "2021-01-06T19:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMDE5MTQy",
          "commit": {
            "abbreviatedOid": "f4bb5b8"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good!",
          "createdAt": "2021-01-06T20:31:54Z",
          "updatedAt": "2021-01-06T20:31:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 107,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUwNjk2NDQ0",
      "title": "Pin envelope mode to base or customIdentifier.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/107",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I chose to leave the enumeration and restrict its values to in the text. \r\n\r\nAs discussed, this also makes pkU/pkS mandatory in the core OPAQUE messages.",
      "createdAt": "2021-01-06T22:03:34Z",
      "updatedAt": "2021-01-08T03:25:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "758c8a0314775f16f3c02c7741bf282de321f0cb",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/pin-modes",
      "headRefOid": "db59aa3ac9999cd2f3c340886d522c30e7749942",
      "closedAt": "2021-01-08T03:25:18Z",
      "mergedAt": "2021-01-08T03:25:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "dca52275f12704ef4b90aa8bbd48331007ffb9c5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzODkzNDI5",
          "commit": {
            "abbreviatedOid": "db59aa3"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Great!",
          "createdAt": "2021-01-07T23:05:56Z",
          "updatedAt": "2021-01-07T23:05:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 110,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUyMDUyOTkw",
      "title": "Remove a dead link and in the \"User enumeration\" section, update variable names.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/110",
      "state": "MERGED",
      "author": "creemama",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-09T04:29:53Z",
      "updatedAt": "2021-01-13T02:34:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "dca52275f12704ef4b90aa8bbd48331007ffb9c5",
      "headRepository": "creemama/draft-irtf-cfrg-opaque",
      "headRefName": "dead-link-and-variable-names",
      "headRefOid": "90d5a7a734734de2bf13ad2ea6880c00afa3a6c8",
      "closedAt": "2021-01-11T15:06:53Z",
      "mergedAt": "2021-01-11T15:06:53Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "268ec3d685b1d57091ba40eb3bdfce1507e09cfc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NDMyNTMx",
          "commit": {
            "abbreviatedOid": "8c55239"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-11T14:58:51Z",
          "updatedAt": "2021-01-11T15:03:50Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nsimulating a CredentialResponse for non-existing users.\r\n```",
              "createdAt": "2021-01-11T14:58:51Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nNote that if the same CredentialRequest is received\r\n```",
              "createdAt": "2021-01-11T14:59:55Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nthe construction of envU to all the key material in envU.\r\n```",
              "createdAt": "2021-01-11T15:00:53Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-01-11T15:01:00Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            },
            {
              "originalPosition": 50,
              "body": "```suggestion\r\nUpon receiving a CredentialRequest for a non-existing\r\n```",
              "createdAt": "2021-01-11T15:01:18Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nCredentialResponse carrying Z=M^kU and envU, where the latter is computed as follows.\r\nrwdU is set to kU' and secret_creds is set to the all-zero string (of the\r\n```",
              "createdAt": "2021-01-11T15:03:07Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            },
            {
              "originalPosition": 64,
              "body": "```suggestion\r\nAn attacker that attempts authentication with the same CredentialRequest twice and receives\r\n```",
              "createdAt": "2021-01-11T15:03:46Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NDM4NzE2",
          "commit": {
            "abbreviatedOid": "e249729"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-11T15:05:13Z",
          "updatedAt": "2021-01-11T15:05:13Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\nAn attacker that attempts authentication with the same CredentialRequest twice and receives\r\n```",
              "createdAt": "2021-01-11T15:05:13Z",
              "updatedAt": "2021-01-11T15:05:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 113,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUzOTk2MDgz",
      "title": "Make process diagrams match function definitions. ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/113",
      "state": "MERGED",
      "author": "creemama",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There were some inconsistencies in the process diagrams and function definitions.\r\n\r\n-----\r\n\r\nFor example, before this change, the output of CreateCredentialRequest in the process diagram\r\n```\r\nrequest, blind = CreateCredentialRequest(pwdU)\r\n```\r\ndid not match the output of CreateCredentialRequest's function definition:\r\n```\r\nOutput:\r\n- request, an CredentialRequest structure\r\n- r, an OPRF Scalar value\r\n```\r\n`r` should be `blind`, which FinalizeRequest takes as input.\r\n\r\n-----\r\n\r\nIn another example, the output of FinalizeRequest in the process diagram\r\n```\r\nrecord, export_key = FinalizeRequest(pwdU, creds, blind, response)\r\n```\r\ndid not match the output of FinalizeRequest's function definition:\r\n```\r\nOutput:\r\n- envU, the user's Envelope structure\r\n- export_key, an additional key\r\n```",
      "createdAt": "2021-01-13T07:55:47Z",
      "updatedAt": "2021-01-13T14:30:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "268ec3d685b1d57091ba40eb3bdfce1507e09cfc",
      "headRepository": "creemama/draft-irtf-cfrg-opaque",
      "headRefName": "consistency",
      "headRefOid": "4c97670a8968ba26a75ebed49841b09fd9c6b7cf",
      "closedAt": "2021-01-13T14:12:27Z",
      "mergedAt": "2021-01-13T14:12:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5956b66d1b851ef76b79219d7463851e2c74b1c4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3MjU4MDgx",
          "commit": {
            "abbreviatedOid": "4c97670"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-13T14:12:22Z",
          "updatedAt": "2021-01-13T14:12:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 114,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU0MzI2NDU4",
      "title": "Adding serialization format for credential file",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/114",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Defines the serialization for the \"credential file\" (the object that is stored server-side and acts as the user's password file).\r\n\r\nCloses #89.",
      "createdAt": "2021-01-13T16:54:31Z",
      "updatedAt": "2021-01-14T16:08:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "5956b66d1b851ef76b79219d7463851e2c74b1c4",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "credential_file",
      "headRefOid": "87a13127aa3cf0e0ea1d23a9640f06eb18d925fb",
      "closedAt": "2021-01-13T22:39:41Z",
      "mergedAt": "2021-01-13T22:39:41Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "7fc5de0c5625665e18e017bb9eddd35090a19f31"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should leave it up to a wrapper implementation to add a version around the bytes of the `CredentialFile`, no?",
          "createdAt": "2021-01-13T20:56:38Z",
          "updatedAt": "2021-01-13T20:56:38Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comments addressed -- ready to merge",
          "createdAt": "2021-01-13T22:22:43Z",
          "updatedAt": "2021-01-13T22:22:43Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "I'm not sure I have a specific question here, but may I share my thoughts on the subject?\r\n\r\nI have been playing with different ideas on my side, and found that due to the different variable parameters at play it is a quite complex subject to optimize.\r\n\r\n- **Envelope Mode**\r\nIf the envelope is serialized and opaque, the server still needs a way to know the EnvelopeMode to communicate the correct \"Credentials\" structure to the client.\r\n\r\n- **OPRF key**\r\nAs @chris-wood pointed out, the encoding of an OPRF key is tied to the suite and is not encoded into the key itself. Hence, the most straightforward thing to do is to have another field specifying the suite the key belongs to. It's a single byte, and can't hurt that much, I believe.\r\nIf one wants to separate kU from the envelope and store it elsewhere, keys belonging to the same group could be stored in the same table. Thus, the user record only references the kU in another table and doesn't care about the suite.\r\n\r\n- **AKE keys**\r\nGiven a complex environment with different conditions that open the possibility that different AKEs are used, the user record might need to keep track of that as well. Either a reference to the key pair and their type (group and AKE) or stored in a \"table\" dedicated to that key pair.\r\n\r\n- **MHF Params**\r\nThe key derivation functions have different impacts on different platforms and may impact the user experience if the login takes too long due to unsuited parameters. From what I understand, this hasn't been thoroughly discussed, yet (and rightfully so). But if different configurations were to be used for different clients, they have to be saved with the user record.\r\n\r\n\r\nA \"naive\" version of my implementation sees the complete information tied to a user record grow quite rapidly:\r\n```\r\nUserRecord {\r\n    HumanUserID  // Human-memorizable, modifiable user identifier\r\n    UUID               // Unique long-term user identifier, or idu\r\n    UserPublicKey\r\n    EnvelopeMode \r\n    Envelope     \r\n    ServerID     \r\n    OprfSecret   \r\n    ServerAkeID  \r\n    Parameters {\r\n        Ciphersuite\r\n        Hash\r\n        AKE\r\n        MHFParams {\r\n            AlgoID\r\n            time, memory, threads\r\n            KeyLength\r\n        }\r\n    }\r\n}\r\n\r\nServerAke {\r\n    ID             // unique ID for this key pair\r\n    Ake          // the AKE protocol they are used in\r\n    Group    \r\n    Hash     \r\n    SecretKey\r\n    PublicKey\r\n}\r\n```",
          "createdAt": "2021-01-13T23:28:01Z",
          "updatedAt": "2021-01-13T23:28:01Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "i'm not sure this is a good idea, different use-cases might not need all the bells and whistles. i think i asked in an issue if this is about the standardization of the protocol or it goes beyond that and standardizes also serialization of all kind of wire and storage elements. in implementations using only one instantiation of the protocol the parameters are fixed, and don't need to be stored. if an implementation does not follow the spec and does not store this redundant info in that case, will it still be standards compliant? also some implementations might want to go beyond the currently specified two envelope setups and may want to make all credential extensions configurable, i can see reasons for all configurations. i think there should be a limit of what is part of the standard, and what is free for implementations to decide themselves, and again depending on different configurations of how credential extensions are created this can lead to very different storage formats. my take is to not specify neither the storage format of the record, nor actually the configuration of the envelope. test vectors can still be provided for the protocol, especially if serialization is not fixed, in that case the test vectors can be provided as results of the various steps of the protocol, there is no combinatoric explosion.",
          "createdAt": "2021-01-14T01:53:47Z",
          "updatedAt": "2021-01-14T01:53:47Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "to quote Antoine de Saint-Exupery:\r\n> Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away .",
          "createdAt": "2021-01-14T02:00:28Z",
          "updatedAt": "2021-01-14T02:00:28Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "imagine an implementation that stores (parts of) the record in a smartcard, a cortex m[034], a cars ECU, or a yubikey. an implementation that has one pkS and one that has separate pkS for each user. it makes sense to have different implementations to be interoperable with each other on the protocol level, a client and a server running different implementations. but the records, do not need to be specified.",
          "createdAt": "2021-01-14T12:31:58Z",
          "updatedAt": "2021-01-14T12:31:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The standard needs to specify ways to interpret envelopes for the sake of security and interoperability. (What's included in the envelope is critical to the overall security of OPAQUE.) \r\n\r\nThe `mode` parameter was introduced precisely to allow the sort of extensibility you're after. For example, if neither of the envelope formats work for your use case, you may pick a new mode and its corresponding envelope structure. The existing modes were chosen because we believe they represent the minimal information needed for most applications.\r\n\r\nRegarding the CredentialFile format, this change describes the structure and format of what minimally needs to be *associated* with a given user's record. It does not mandate how server implementations store this information. ",
          "createdAt": "2021-01-14T13:41:38Z",
          "updatedAt": "2021-01-14T13:41:38Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Hello Stefan,\r\n\r\nmy point wasn't to say \"hey, this is how I think we should do it, let's put everything in there to have a perfect thingy\" :)\r\nAs I said, this is the naive structure for my proof-of-concept, and, believe me, I don't want to keep it like this.\r\n\r\nI'm aligned with you, and I think we all agree. I believe that there is a _sweet spot_ that OPAQUE is reaching, a balance between the core necessities and minimize implementation pitfalls that might introduce vulnerabilities in the usage of OPAQUE.",
          "createdAt": "2021-01-14T13:47:18Z",
          "updatedAt": "2021-01-14T13:47:43Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "> The standard needs to specify ways to interpret envelopes for the sake of security and interoperability. (What's included in the envelope is critical to the overall security of OPAQUE.)\r\n\r\nagreed. security and interop are the goals of an opaque standard.\r\n\r\n> The `mode` parameter was introduced precisely to allow the sort of extensibility you're after.\r\n> For example, if neither of the envelope formats work for your use case, you may pick a new mode and its corresponding envelope structure. \r\n\r\noh? i guess i missed the part where it says that this is an optional extensible parameter, and not necessary to be conformant with the spec. i guess i suffer from patch reading fatigue trying to keep up with all the changes, sorry for that.\r\n\r\n> The existing modes were chosen because we believe they represent the minimal information needed for most applications.\r\n\r\nis there any documentation on how this belief was established? for example why not chose the minimal envelope, with 0 credentialextensions as a base mode isn't that the minimal information already needed for most applications?\r\n \r\n> Regarding the CredentialFile format, this change describes the structure and format of what minimally needs to be _associated_ with a given user's record. It does not mandate how server implementations store this information.\r\n\r\nmaybe calling it a file is misguiding then, perhaps it might make sense to change it to something like:\r\nThe following values need to be stored by the server indexed by the idU: kU, envU, pkU.\r\ni do disagree with the part: \r\n\r\n> describes the structure and format\r\n\r\nwhat if i want to store kU in a secure element, or sgx (trying not to laugh hard...) while the rest can be stored outside of it? or alternatively, if there is cleartext elements in the envelope that can be deduped in some way, why store them in the envelope, pkS and idS are some simple candidates to have not stored in the envU, but only reassembled before sending of the CreateCredentialResponse response.",
          "createdAt": "2021-01-14T14:38:54Z",
          "updatedAt": "2021-01-14T14:39:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> is there any documentation on how this belief was established? for example why not chose the minimal envelope, with 0 credentialextensions as a base mode isn't that the minimal information already needed for most applications?\r\n\r\nThere are no more extensions, so I think this is already addressed :) Please have a look at the latest version of the draft here. (Sorry, many things are changing, and I understand it's hard to follow!)\r\n\r\n> maybe calling it a file is misguiding then, perhaps it might make sense to change it to something like:\r\n\r\nWe have a structure for applications which do not want to store things in some special way, i.e., they want to write the \"file\" as presented directly to storage.\r\n\r\n> what if i want to store kU in a secure element, or sgx (trying not to laugh hard...) while the rest can be stored outside of it? or alternatively, if there is cleartext elements in the envelope that can be deduped in some way, why store them in the envelope, pkS and idS are some simple candidates to have not stored in the envU, but only reassembled before sending of the CreateCredentialResponse response.\r\n\r\nAs above, the file format *does not* preclude implementation- or application-specific storage for these things. I recommend having a look at the latest version of the spec to see how things are described. \r\n\r\nAlternatively, if it would help, I'd be happy to hop on a call to discuss these issues in more depth. :-) ",
          "createdAt": "2021-01-14T16:08:08Z",
          "updatedAt": "2021-01-14T16:08:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NTA5OTgw",
          "commit": {
            "abbreviatedOid": "4008fe1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Since `CredentialFile` is meant to be opaque storage handled by OPAQUE, I think everything in the envelope ought to be serialized. Since the serialized format of a `Scalar` depends on the OPRF group, this does assume that the OPAQUE configuration (and OPRF suite) is known. What prevents a `CredentialFile` from one configuration being used in another configuration? ",
          "createdAt": "2021-01-13T18:34:04Z",
          "updatedAt": "2021-01-13T18:39:29Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\n    SerializedScalar kU;\r\n```",
              "createdAt": "2021-01-13T18:34:04Z",
              "updatedAt": "2021-01-13T22:22:19Z"
            },
            {
              "originalPosition": 42,
              "body": "I assume we want this to be serialized for storage, right?",
              "createdAt": "2021-01-13T18:34:28Z",
              "updatedAt": "2021-01-13T22:22:19Z"
            },
            {
              "originalPosition": 79,
              "body": "Assuming you take the suggestion above, I'd then deserialize `kU` before use.",
              "createdAt": "2021-01-13T18:34:50Z",
              "updatedAt": "2021-01-13T22:22:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NjIwMjYx",
          "commit": {
            "abbreviatedOid": "4008fe1"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-13T20:55:58Z",
          "updatedAt": "2021-01-13T20:55:59Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I could not find \"SerializedScalar\" in the VOPRF doc. Is there a definition for this somewhere?\r\n\r\nEdit: After discussion, found it :) ",
              "createdAt": "2021-01-13T20:55:58Z",
              "updatedAt": "2021-01-13T22:22:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 115,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU0NjMxMTE0",
      "title": "Make the online-phase process diagram match function definitions.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/115",
      "state": "MERGED",
      "author": "creemama",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "87a13127aa3cf0e0ea1d23a9640f06eb18d925fb changed the signature of\r\n`CreateCredentialResponse`.\r\n\r\nI also improved upon @kevinlewi's update.\r\n\r\nI took the definitions of the OPRF functions and types from\r\nhttps://cfrg.github.io/draft-irtf-cfrg-voprf/draft-irtf-cfrg-voprf.html .\r\nI modified them some. Here is the original text for reference:\r\n- SerializedElement and SerializedScalar are serialized representations of\r\n  Element and Scalar types of length Ne and Ns, respectively\r\n- SerializeElement(A): A member function of GG that maps a group element A to\r\n  a unique byte array buf of fixed length Ne.\r\n- DeserializeElement(buf): A member\r\n  function of GG that maps a byte array buf to a group element A, or fails if\r\n  the input is not a valid byte representation of an element.\r\n\r\nI removed the references to `SerializeElement` and `DeserializeElement` since\r\nthey were not referenced anywhere in the draft.\r\n\r\nThere was also no mention of `SerializeScalar`. I added\r\n\"`kU` is serialized using `SerializeScalar`\" to make its usage explicit.\r\n\r\nI changed `CredentialRequest` and `CredentialResponse` to use\r\n`SerializedElement` to match `RegistrationRequest` and `RegistrationResponse`.\r\n\r\nIn `RegistrationUpload` I moved `Envelope` to the end of the struct to be\r\nconsistent with the `Envelope`'s position in other structs:\r\n```\r\nstruct {\r\n    SerializedScalar kU;\r\n    opaque pkU<1..2^16-1>;\r\n    Envelope envU;\r\n} CredentialFile;\r\n\r\nstruct {\r\n    SerializedElement data;\r\n    opaque pkS<1..2^16-1>;\r\n    Envelope envU;\r\n} CredentialResponse;\r\n```\r\nAlso, `Envelope` is of variable length.",
      "createdAt": "2021-01-14T04:17:43Z",
      "updatedAt": "2021-01-14T14:07:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "7fc5de0c5625665e18e017bb9eddd35090a19f31",
      "headRepository": "creemama/draft-irtf-cfrg-opaque",
      "headRefName": "consistency",
      "headRefOid": "ceadc91bdaa0fc296c748e571a05c2c7014578aa",
      "closedAt": "2021-01-14T13:48:39Z",
      "mergedAt": "2021-01-14T13:48:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "788a5a3817eddd0052c9576cf27a8f3970530058"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4MjQ3MjU3",
          "commit": {
            "abbreviatedOid": "ceadc91"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-14T13:48:35Z",
          "updatedAt": "2021-01-14T13:48:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU1MzI1NTA2",
      "title": "Update headings and hyphenation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/116",
      "state": "MERGED",
      "author": "creemama",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I also tackled two suggestions in https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/112.",
      "createdAt": "2021-01-15T01:22:48Z",
      "updatedAt": "2021-01-15T01:57:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "788a5a3817eddd0052c9576cf27a8f3970530058",
      "headRepository": "creemama/draft-irtf-cfrg-opaque",
      "headRefName": "consistency",
      "headRefOid": "a0cce2da3aafc5392f422738a84fef8e4781964c",
      "closedAt": "2021-01-15T01:52:54Z",
      "mergedAt": "2021-01-15T01:52:54Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7539e8665bae01e8c96f79b8f378f56dcbb8bab7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NzYyNjUw",
          "commit": {
            "abbreviatedOid": "064c1dc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-15T01:52:28Z",
          "updatedAt": "2021-01-15T01:52:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n(PKI-free) aPAKE protocols, none of these protocols are secure against\r\n```",
              "createdAt": "2021-01-15T01:52:29Z",
              "updatedAt": "2021-01-15T01:52:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NzYyNzQ1",
          "commit": {
            "abbreviatedOid": "064c1dc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2021-01-15T01:52:47Z",
          "updatedAt": "2021-01-15T01:52:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 117,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU1MzQxMzE4",
      "title": "Surround multiple output params with parentheses in process diagrams.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/117",
      "state": "MERGED",
      "author": "creemama",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the steps for functions, we surround multiple output params with\r\nparentheses:\r\n```\r\nSteps:\r\n1. (blind, M) = Blind(pwdU)\r\n2. Create RegistrationRequest request with M\r\n3. Output (request, blind)\r\n```\r\n\r\n@crockeea pointed out that we should be consistent. From\r\nhttps://github.com/cfrg/draft-irtf-cfrg-opaque/issues/112#issuecomment-760522234,\r\n\"Be consistent about the use of parens for functions which output multiple\r\nvalues (see protocol diagrams at top of section 3.2 and at the top of 3.3)\".",
      "createdAt": "2021-01-15T02:19:51Z",
      "updatedAt": "2021-01-30T17:26:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "7539e8665bae01e8c96f79b8f378f56dcbb8bab7",
      "headRepository": "creemama/draft-irtf-cfrg-opaque",
      "headRefName": "consistency",
      "headRefOid": "4bcdd6bbe5f0100adcfba25d0308fe2a755513af",
      "closedAt": "2021-01-22T23:51:39Z",
      "mergedAt": "2021-01-22T23:51:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ac3192db44619e394344a4bff648711ffd827c4b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0Njk5NDIw",
          "commit": {
            "abbreviatedOid": "4bcdd6b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-22T23:51:34Z",
          "updatedAt": "2021-01-22T23:51:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYwMjgwOTA4",
      "title": "Minor updates",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/123",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses most small things in @crockeea's review. I'll add the updated protocol descriptions after the structural refactor, @kevinlewi!",
      "createdAt": "2021-01-23T00:28:43Z",
      "updatedAt": "2021-01-25T15:54:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ac3192db44619e394344a4bff648711ffd827c4b",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/minor-updates",
      "headRefOid": "35e3fe0418968fb7773bc8cb5c4b3090ad9464b3",
      "closedAt": "2021-01-25T15:54:01Z",
      "mergedAt": "2021-01-25T15:54:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "50b3ce795fe0ec19b74e98dcfcf482992b9bb692"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1MDg5NTY0",
          "commit": {
            "abbreviatedOid": "35e3fe0"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks great!!",
          "createdAt": "2021-01-25T06:14:12Z",
          "updatedAt": "2021-01-25T06:14:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 125,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYxNzk0MDU4",
      "title": "Structural refactor",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/125",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a pretty invasive change that tries to better organize the document and protocol description into its two steps: registration and authentication. It also includes more wire format details for the 3DH instantiation, and removes HMQV and SIGMA-I in the process. (We can bring them back in a future change as needed.) The outline now looks like so:\r\n\r\n```\r\n   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\r\n     1.1.  Requirements Notation . . . . . . . . . . . . . . . . . .   5\r\n     1.2.  Notation  . . . . . . . . . . . . . . . . . . . . . . . .   5\r\n   2.  Cryptographic Protocol and Algorithm Dependencies . . . . . .   6\r\n   3.  Offline Registration  . . . . . . . . . . . . . . . . . . . .   7\r\n     3.1.  Credential Storage  . . . . . . . . . . . . . . . . . . .   8\r\n     3.2.  Registration Messages . . . . . . . . . . . . . . . . . .  10\r\n     3.3.  Registration Functions  . . . . . . . . . . . . . . . . .  11\r\n       3.3.1.  CreateRegistrationRequest . . . . . . . . . . . . . .  11\r\n       3.3.2.  CreateRegistrationResponse  . . . . . . . . . . . . .  11\r\n       3.3.3.  FinalizeRequest . . . . . . . . . . . . . . . . . . .  11\r\n       3.3.4.  CredentialFile  . . . . . . . . . . . . . . . . . . .  13\r\n   4.  Online Authenticated Key Exchange . . . . . . . . . . . . . .  13\r\n     4.1.  Credential Retrieval  . . . . . . . . . . . . . . . . . .  13\r\n       4.1.1.  Credential Retrieval Messages . . . . . . . . . . . .  14\r\n       4.1.2.  Credential Retrieval Functions  . . . . . . . . . . .  14\r\n     4.2.  AKE Instantiations  . . . . . . . . . . . . . . . . . . .  16\r\n       4.2.1.  Key Schedule Utility Functions  . . . . . . . . . . .  17\r\n       4.2.2.  OPAQUE-3DH Instantiation  . . . . . . . . . . . . . .  18\r\n       4.2.3.  Alternate AKE instantiations  . . . . . . . . . . . .  20\r\n   5.  Configurations  . . . . . . . . . . . . . . . . . . . . . . .  20\r\n```\r\n\r\ncc @hugokraw, @crockeea",
      "createdAt": "2021-01-26T13:47:50Z",
      "updatedAt": "2021-01-30T15:19:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "50b3ce795fe0ec19b74e98dcfcf482992b9bb692",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/restructure-doc",
      "headRefOid": "db6a82ac6fd5661447ccc3773752ed12fe812dcd",
      "closedAt": "2021-01-30T15:19:17Z",
      "mergedAt": "2021-01-30T15:19:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3451ec3e3e5f6ab3d06247a8d4e7bf1488749c64"
      },
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "This re-structuring looks good, in particular it needs to correct the impression people had that the AKE part is not an integral (and essential) part of the specification.\r\n\r\nAs for the presentation of HMQV of SIGMA, I want to have a sketch of them in the document as additional examples, especially given how simple it is to do it on the basis of the 3DH description. For HMQV it just means defining the key derivation and for SIGMA it is not much more than that, and it gives a different type of protocol, in particular one that would be used with TLS and IKE.  Since this  is more on the informational side, I would move them to an appendix.\r\n\r\nRegarding the sentence \r\n`any post-quantum (PQ) AKE protocol that has the message flow above`\r\nI am not sure what the \"message flow above\" refers to but we should not prescribe a particular flow. Definitely not a 3-flow KE since KEM-based AKE would most probably not preserve that.",
          "createdAt": "2021-01-26T18:03:30Z",
          "updatedAt": "2021-01-26T18:03:30Z"
        },
        {
          "author": "crockeea",
          "authorAssociation": "NONE",
          "body": "Is there a rendered version of this somewhere?",
          "createdAt": "2021-01-26T20:47:47Z",
          "updatedAt": "2021-01-26T20:47:47Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "@crockeea you can find a rendered version at https://github.com/cfrg/draft-irtf-cfrg-opaque/blob/42c6cfc7fe40015d5e9e4956e0bfe76045bdc357/draft-irtf-cfrg-opaque.md\r\n",
          "createdAt": "2021-01-27T22:01:58Z",
          "updatedAt": "2021-01-27T22:01:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjUyODUx",
          "commit": {
            "abbreviatedOid": "42c6cfc"
          },
          "author": "crockeea",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T18:43:55Z",
          "updatedAt": "2021-01-26T18:43:56Z",
          "comments": [
            {
              "originalPosition": 665,
              "body": "The data encryption scheme for the envelope encryption is already PQ, and to me, any mention of \"data encryption\" outside the key exchange step is outside the scope of this doc. It's not clear which one you are referring to here, but either way, I would remove the references to data encryption.",
              "createdAt": "2021-01-26T18:43:55Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2ODQ3NjU4",
          "commit": {
            "abbreviatedOid": "42c6cfc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T23:17:51Z",
          "updatedAt": "2021-01-26T23:17:51Z",
          "comments": [
            {
              "originalPosition": 665,
              "body": "How about the following formulation (it refers to 'application data' explicitly to avoid confusion of what data we are talking about):\r\nNote that such an instantiation is not quantum safe unless the OPRF is quantum safe. However, an OPAQUE instantiation where the AKE is quantum safe, but the OPRF is not, would still ensure the confidentiality of application data encrypted under session_key (or a key derived from it) with a quantum-safe encryption function.",
              "createdAt": "2021-01-26T23:17:51Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2ODQ4Nzg2",
          "commit": {
            "abbreviatedOid": "42c6cfc"
          },
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T23:20:09Z",
          "updatedAt": "2021-01-26T23:20:10Z",
          "comments": [
            {
              "originalPosition": 665,
              "body": "Btw, we never say what one does with session_key. We may not want to add a derivation of traffic keys as in TLS but we should comment that deriving such keys would be the typical use although applications may have other uses. ",
              "createdAt": "2021-01-26T23:20:09Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2ODg3ODg5",
          "commit": {
            "abbreviatedOid": "42c6cfc"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is fantastic! Left some comments but overall this should help to clear things up a bit.\r\n\r\n@crockeea, unfortunately I think you just have to clone the PR and render it locally...\r\n\r\nAnd perhaps we can defer the descriptions of HMQV + SIGMA-I to the Appendix, but also in a later PR since this one already has a bunch of changes.",
          "createdAt": "2021-01-27T00:47:17Z",
          "updatedAt": "2021-01-27T00:59:49Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Nit: Perhaps at this point, we should clarify that a bunch of the variables depicted above will be clarified later? Or maybe we can reference a description to them somewhere. After reading this, I become immediately confused... but maybe it is just me :) ",
              "createdAt": "2021-01-27T00:47:17Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            },
            {
              "originalPosition": 72,
              "body": "Nit: \"the S stores U's credentials\" -> \"S stores U's credentials\" / \"the server stores the user's credentials\"",
              "createdAt": "2021-01-27T00:48:08Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            },
            {
              "originalPosition": 205,
              "body": "Rename exporter_key to export_key",
              "createdAt": "2021-01-27T00:49:12Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            },
            {
              "originalPosition": 382,
              "body": "Nit: Perhaps change the anchor link from `#SecHmqv` to something else?",
              "createdAt": "2021-01-27T00:50:55Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            },
            {
              "originalPosition": 649,
              "body": "nit: info2 does not seem to be defined anywhere",
              "createdAt": "2021-01-27T00:54:29Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5MzM0OTI2",
          "commit": {
            "abbreviatedOid": "42c6cfc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T14:59:56Z",
          "updatedAt": "2021-01-29T14:59:56Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Yep, good idea!",
              "createdAt": "2021-01-29T14:59:56Z",
              "updatedAt": "2021-01-29T15:13:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5MzQ4MDMx",
          "commit": {
            "abbreviatedOid": "db6a82a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-29T15:14:06Z",
          "updatedAt": "2021-01-29T15:14:07Z",
          "comments": [
            {
              "originalPosition": 665,
              "body": "Thanks, @hugokraw -- I applied your suggested text, and added a note describing that applications can use `session_key` to derive additional keying material.",
              "createdAt": "2021-01-29T15:14:07Z",
              "updatedAt": "2021-01-29T15:14:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 126,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY0NDQ0MTYy",
      "title": "Simplify envelope secret derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/126",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #120.\r\n\r\ncc @hugokraw ",
      "createdAt": "2021-01-30T15:33:26Z",
      "updatedAt": "2021-02-01T14:31:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "3451ec3e3e5f6ab3d06247a8d4e7bf1488749c64",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/simplify-secret-derivation",
      "headRefOid": "00810795fa60f5a5e77cee205d1e698d3b533077",
      "closedAt": "2021-02-01T14:31:15Z",
      "mergedAt": "2021-02-01T14:31:15Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "239450c6747e5aed3a3b510d9b33ac7f816534e1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5OTYyMjgx",
          "commit": {
            "abbreviatedOid": "0081079"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2021-02-01T01:18:39Z",
          "updatedAt": "2021-02-01T01:18:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY0NDc2Mzgy",
      "title": "Update the keyagreement reference",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/127",
      "state": "CLOSED",
      "author": "creemama",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "so that the \"Update Editor's Copy\" GitHub action succeeds.\r\n\r\nThe GitHub action fails with the following message:\r\n```\r\n/github/home/.cache/xml2rfc/reference.DOI.10.6028_NIST.SP.800-56Ar3--anchor=keyagreement.xml: fetching\r\n*** 404 NOT FOUND while fetching https://xml2rfc.tools.ietf.org/public/rfc/bibxml7/reference.DOI.10.6028/NIST.SP.800-56Ar3.xml?anchor=keyagreement\r\n*** No such file or directory @ rb_sysopen - /github/home/.cache/xml2rfc/reference.DOI.10.6028_NIST.SP.800-56Ar3--anchor=keyagreement.xml for /github/home/.cache/xml2rfc/reference.DOI.10.6028_NIST.SP.800-56Ar3--anchor=keyagreement.xml\r\nError: Unable to parse the XML document: /dev/stdin\r\nmake: *** [lib/main.mk:68: draft-irtf-cfrg-opaque.xml] Error 1\r\n```\r\nSee https://github.com/cfrg/draft-irtf-cfrg-opaque/runs/1797781503 .\r\n\r\nThere is an alternate link to this reference here:\r\nhttps://xml2rfc.tools.ietf.org/public/rfc/bibxml-nist/reference.NIST.NIST.SP.800-56Ar3.xml .",
      "createdAt": "2021-01-30T17:48:25Z",
      "updatedAt": "2021-01-30T21:20:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "3451ec3e3e5f6ab3d06247a8d4e7bf1488749c64",
      "headRepository": "creemama/draft-irtf-cfrg-opaque",
      "headRefName": "keyagreement",
      "headRefOid": "bce6d06160b760c6ff3e5c02f0c88e57a4acafed",
      "closedAt": "2021-01-30T17:59:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "creemama",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Awww shucks, I thought that would work. Let me see if I can figure this out.",
          "createdAt": "2021-01-30T17:50:41Z",
          "updatedAt": "2021-01-30T17:50:41Z"
        },
        {
          "author": "creemama",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The GitHub action tries to pull from \r\nhttps://xml2rfc.tools.ietf.org/public/rfc/bibxml2/reference.NIST.NIST.SP.800-56Ar3.xml\r\ninstead of\r\nhttps://xml2rfc.tools.ietf.org/public/rfc/bibxml-nist/reference.NIST.NIST.SP.800-56Ar3.xml .\r\n\r\nhttps://xml2rfc.tools.ietf.org/public/rfc/bibxml2 has some NIST references but not the one we want.",
          "createdAt": "2021-01-30T17:59:30Z",
          "updatedAt": "2021-01-30T17:59:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Don't worry about fixing this. I'll take care of it.",
          "createdAt": "2021-01-30T21:20:12Z",
          "updatedAt": "2021-01-30T21:20:12Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 133,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY2MjA0ODcy",
      "title": "First test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/133",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #119.",
      "createdAt": "2021-02-02T19:02:55Z",
      "updatedAt": "2021-02-03T21:55:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "239450c6747e5aed3a3b510d9b33ac7f816534e1",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/format-vectors",
      "headRefOid": "7402eb5441d45028adce29c8a3a41680411f078b",
      "closedAt": "2021-02-03T00:32:03Z",
      "mergedAt": "2021-02-03T00:32:02Z",
      "mergedBy": "kevinlewi",
      "mergeCommit": {
        "oid": "ea3739c54c9c580f12ade6811d5e5ea414ccc549"
      },
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "> They match!\r\n\r\ncongrats @kevinlewi  :)\r\n",
          "createdAt": "2021-02-03T21:55:16Z",
          "updatedAt": "2021-02-03T21:55:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgxNzU2NzQ0",
          "commit": {
            "abbreviatedOid": "46e2424"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "- [x] Let's move any discussion of variable name changes and designation of inputs/outputs to #119, so that once we agree on a setting, this PR can just implement whatever is decided in #119\r\n\r\n- [x] credential_request / KE1, credential_response / KE2, and credential_finalization / KE3 messages are missing\r\n\r\n- [ ] Add a glossary for some of the variable names that do not appear anywhere in the spec (for example, envelope_nonce)",
          "createdAt": "2021-02-02T20:44:45Z",
          "updatedAt": "2021-02-03T00:00:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgxODg5NjAz",
          "commit": {
            "abbreviatedOid": "7402eb5"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "They match!",
          "createdAt": "2021-02-03T00:29:38Z",
          "updatedAt": "2021-02-03T00:29:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 135,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY3MTE0MTA5",
      "title": "Adding text on export key usage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/135",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion in #130 \r\n\r\nCloses #130 ",
      "createdAt": "2021-02-03T20:13:01Z",
      "updatedAt": "2021-02-03T20:16:23Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "ea3739c54c9c580f12ade6811d5e5ea414ccc549",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "export_key_usage",
      "headRefOid": "2286ceaa269e47551febe2b3b9bd875759019d06",
      "closedAt": "2021-02-03T20:16:23Z",
      "mergedAt": "2021-02-03T20:16:23Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2d6462b358c97b192b2030eadf55dab6da4fbac9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyNzYzODEy",
          "commit": {
            "abbreviatedOid": "2286cea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-03T20:16:17Z",
          "updatedAt": "2021-02-03T20:16:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 136,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY3MTIxMjM3",
      "title": "Renaming \"user\" to \"client\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/136",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #134 ",
      "createdAt": "2021-02-03T20:25:18Z",
      "updatedAt": "2021-02-03T20:27:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "2d6462b358c97b192b2030eadf55dab6da4fbac9",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "user_to_client",
      "headRefOid": "f1d16cdc593833d188daad7606abc99c5316cd60",
      "closedAt": "2021-02-03T20:27:18Z",
      "mergedAt": "2021-02-03T20:27:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "111b02c884ca967d6c78182dae08f7d83d4be7ae"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyNzcxOTgy",
          "commit": {
            "abbreviatedOid": "f1d16cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-03T20:27:14Z",
          "updatedAt": "2021-02-03T20:27:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 137,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY3MTIzMzg4",
      "title": "Limiting opaque key types to 255 bytes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/137",
      "state": "OPEN",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changes all opaque key types to be at most 255 bytes (instead of 2^16-1). Also changed encrypted_creds in the envelope to have the same restriction.\r\n\r\nNote: Still need to update the test vectors to match this new change.\r\n\r\nCloses #132 ",
      "createdAt": "2021-02-03T20:29:15Z",
      "updatedAt": "2021-02-07T23:12:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "111b02c884ca967d6c78182dae08f7d83d4be7ae",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "hkdf_limits",
      "headRefOid": "21e9d8b937f298d7693dfdf62342d19102f94a64",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "> Changes all opaque key types to be at most 255 bytes (instead of 2^16-1). Also changed encrypted_creds in the envelope to have the same restriction.\r\n\r\nThis may be too restrictive with PQ algorithms. So if you set that limit, a discussion will be needed about what you do when the algorithm you want to deploy has more than 255 bytes. I will check more about lattice-based schemes and how well they accommodate expanding a PRG seed (namely, what's the computational cost of expanding the seed to a full key).",
          "createdAt": "2021-02-04T19:12:59Z",
          "updatedAt": "2021-02-04T19:12:59Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Putting this in draft mode so that we can address #121 with this PR as well. I intend to add a new `Nk` parameter to denote the key size, which would be set in the configuration for the ciphersuite.",
          "createdAt": "2021-02-07T23:12:18Z",
          "updatedAt": "2021-02-07T23:12:44Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 138,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY3MjQyMDU5",
      "title": "Add back alternate AKE sketches",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/138",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also, nail down the MHF parameters. We don't currently allow them to be negotiated *in* the protocol. (The wrapper protocol may choose to allow negotiation, but that negotiation would yield a different configuration.)\r\n\r\nCloses #128 and #69.\r\n\r\ncc @hugokraw ",
      "createdAt": "2021-02-04T00:20:58Z",
      "updatedAt": "2021-02-06T04:35:41Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "111b02c884ca967d6c78182dae08f7d83d4be7ae",
      "headRepository": "cfrg/draft-irtf-cfrg-opaque",
      "headRefName": "caw/add-alternates",
      "headRefOid": "ef80344d24412fab0270422536184095ba296b7f",
      "closedAt": "2021-02-05T21:00:08Z",
      "mergedAt": "2021-02-05T21:00:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "62d7d074d3a24e98d8812f0a200916330a28e9fe"
      },
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Change overall looks good to me. One nit: Perhaps preface the titles of the last few sections with \"Appendix: Test Vectors\" and \"Appendix: Alternate AKE instantiations\", just to make it extra clear?",
          "createdAt": "2021-02-04T00:59:16Z",
          "updatedAt": "2021-02-04T00:59:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "These are already rendered in the appendix:\r\n\r\n```\r\n   Appendix B.  Alternate AKE instantiations\r\n     B.1.  HMQV Instantiation Sketch\r\n     B.2.  SIGMA-I Instantiation Sketch\r\n```\r\n\r\nProbably adding \"Appendix\" to the section headers would be redundant?",
          "createdAt": "2021-02-04T01:11:12Z",
          "updatedAt": "2021-02-04T01:11:12Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "> These are already rendered in the appendix:\r\n> \r\n> ```\r\n>    Appendix B.  Alternate AKE instantiations\r\n>      B.1.  HMQV Instantiation Sketch\r\n>      B.2.  SIGMA-I Instantiation Sketch\r\n> ```\r\n> \r\n> Probably adding \"Appendix\" to the section headers would be redundant?\r\n\r\nOops, didn't realize that. Great!",
          "createdAt": "2021-02-04T01:12:40Z",
          "updatedAt": "2021-02-04T01:12:40Z"
        },
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Test vectors look good!",
          "createdAt": "2021-02-05T18:23:26Z",
          "updatedAt": "2021-02-05T18:23:26Z"
        },
        {
          "author": "hugokraw",
          "authorAssociation": "COLLABORATOR",
          "body": "I see no point in adding SIGMA to the appendix the way it is now. If you put a sketch of it in the appendix then let's put a sketch of it, not just one sentence. The only substantial difference with the description of 3DH and HMQV is the signature. The rest follows the same pattern as 3DH and HMQV.  I believe that this description will be useful and since we do not provide test vectors then it does not have an extra cost. ",
          "createdAt": "2021-02-06T04:35:41Z",
          "updatedAt": "2021-02-06T04:35:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg0NTk2MDEx",
          "commit": {
            "abbreviatedOid": "ef80344"
          },
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-05T18:23:38Z",
          "updatedAt": "2021-02-05T18:23:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 139,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY3MjQ0NTc1",
      "title": "Match identifiers with main document.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/139",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "```txt\r\nenum {\r\n  base(1),\r\n  custom_identifier(2),\r\n  (255)\r\n} EnvelopeMode;\r\n```",
      "createdAt": "2021-02-04T00:27:44Z",
      "updatedAt": "2021-02-04T13:11:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "111b02c884ca967d6c78182dae08f7d83d4be7ae",
      "headRepository": "armfazh/draft-irtf-cfrg-opaque",
      "headRefName": "patch-1",
      "headRefOid": "d4402cb2754ef734043f24dc088beaab11135404",
      "closedAt": "2021-02-04T13:11:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kevinlewi",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch, @armfazh, thanks!! @chris-wood should we instead change base to be 0 and custom_identifier to be 1 in the main document, or go ahead with this change?",
          "createdAt": "2021-02-04T00:56:24Z",
          "updatedAt": "2021-02-04T00:56:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's just update the text to start at 0. I'm not sure why we had them start at 1? @armfazh, could you please submit a PR with that change? (I can also update #138 to do that.)",
          "createdAt": "2021-02-04T01:09:08Z",
          "updatedAt": "2021-02-04T01:09:08Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "In other designs, IDs start at 1 to allow for a default value or a value that doesn't pin an exact identifier. E.g if the client starts with a configuration set where the mode is 0, the mode is not forced to be one or another, meaning the client can then determine at runtime what it prefers or what's available (given the context the client may or may not have access to identifiers, and will only decide at protocol execution).\nAlso, the OPRF ciphersuites start at 1 as well :)",
          "createdAt": "2021-02-04T04:46:35Z",
          "updatedAt": "2021-02-04T04:46:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> In other designs, IDs start at 1 to allow for a default value or a value that doesn't pin an exact identifier. E.g if the client starts with a configuration set where the mode is 0, the mode is not forced to be one or another, meaning the client can then determine at runtime what it prefers or what's available (given the context the client may or may not have access to identifiers, and will only decide at protocol execution).\r\n\r\nI don't follow this rationale. Modes are part of the configuration -- they're not 'negotiated' in any way.\r\n\r\n> Also, the OPRF ciphersuites start at 1 as well :)\r\n\r\nYeah, though it's somewhat arbitrary. I'll just take this change and update the test vectors in #138.",
          "createdAt": "2021-02-04T13:04:42Z",
          "updatedAt": "2021-02-04T13:04:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Applied this change to #138. Thanks, @armfazh!",
          "createdAt": "2021-02-04T13:11:16Z",
          "updatedAt": "2021-02-04T13:11:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 140,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcwOTc0OTU1",
      "title": "Addressing comments from issue #124",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/140",
      "state": "MERGED",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@stef, replying to your suggestions in-line below. Please let me know if these adequately address the concerns you brought up! Closes #124 \r\n\r\n> > 2OSP and OS2IP: Convert a byte string to and from a non-negative integer as described in {{?RFC8017}}.\r\n> \r\n> link to https://tools.ietf.org/html/rfc8017#section-4.1 and https://tools.ietf.org/html/rfc8017#section-4.2\r\n> \r\n> perhaps also note that this is also known as the htons/ntohs functions in POSIX - implementors might find this very helpful!\r\n\r\nAdded a mention that these can be found in Section 4, but did not add the POSIX references since I could not find a link to them, and these may not be as widely known.\r\n\r\n> \r\n> > kX: An OPRF private key used in role X. For example, kU refers to U's private OPRF key.\r\n> \r\n> is there any other role besides kU?\r\n\r\nGood point, changed the text to refer to `oprf_key` instead of `kU`.\r\n\r\n> \r\n> > random(n): Generate a random byte string of length n bytes.\r\n> \r\n> note that this random string should be of cryptographic quality. although there is a note under all the definitions saying so, it's better to have it closer where it matters and less ignored.\r\n\r\nAdded a note here that it should be cryptographically-secure\r\n\r\n> \r\n> in #cryptographic-protocol-and-algorithm-dependencies-dependencies\r\n> \r\n> the note that only the base variant of the OPRF is needed is also a bit far away from where the OPRF dependency is specified.\r\n\r\nShifted the sentence to be right under the OPRF text\r\n\r\n> \r\n> > auth_tag : Authentication tag protecting the contents of the envelope, covering InnerEnvelope and CleartextCredentials\r\n> \r\n> then it notes:\r\n> \r\n> > The full procedure for constructing Envelope and InnerEnvelope from SecretCredentials and CleartextCredentials is described in {{finalize-request}}.\r\n> \r\n> which is:\r\n> \r\n> > 1. auth_tag = HMAC(auth_key, concat(contents, cleartext_creds))\r\n> \r\n> it's all there but quite dispersed spatially, someone trying to implement this has to jump around in the doc, it's very hard to read this spec sequentially.\r\n\r\nUnfortunately I could not find a way to address this without a major rework to the organization of the doc, since I think it is somewhat inherent to how it is currently laid out.\r\n\r\n> \r\n> > Credential information corresponding to the configuration-specific mode, along with the user public key pkU and private key skU, are stored in a Credentials object with the following named fields:\r\n> > skU, pkU, idU, idS\r\n> \r\n> it is not necessary to specify for interoperability how an implementation stores these values. also for security i think it is better to handle skU seperatately from the other values - or maybe not, depending on the configuration, if any of the other values is also to be kept secret. a sensible implementation wants to actually protect the sensitive values differently from the public values. maybe by storing them in mprotected/sanitized-after-use storage, in secure elements, or something else.\r\n> \r\n> i do see how it is a shortcut to list all the necessary items from the creds struture as an input to finalizerequest though.\r\n\r\nAdded text saying that this is \"recommended\", to emphasize the point that it is not required\r\n\r\n> \r\n> > Clients MUST NOT use the same key pair (skU, pkU) for two different accounts.\r\n> \r\n> why is this, when the server can use the same keypair for different accounts? in the case when idU == pkU this is not even possible i guess.\r\n\r\nRight, well if multiple accounts have the same skU associated with them, then decrypting one envelope would result in yielding the same secret for another without having to know the other account's password -- presumably this is bad for security.\r\n\r\n> \r\n> > pkS : An encoded public key that will be used for the online authenticated key exchange stage.\r\n> \r\n> add explicitly that this is the _servers_ pubkey\r\n> \r\n> similarly be explicit also about this:\r\n> \r\n> > pkU : An encoded public key, corresponding to the private key skU.\r\n> \r\n\r\nAdded, thanks!\r\n\r\n> #credential-file\r\n> \r\n> we agree these things need to be persisted, however i do not see how this helps interoperability or security specifying this struct. i propose to change the wording to something like:\r\n> \r\n> the server needs to be able to reproduce the following values for the online phase.\r\n> \r\n> an implementation might choose to generate kU by doing a KDF on some global secret value in combination with idU for example, then this storage of kU can be skipped. again we should realize that kU is a sensitive value which needs protection (like sanitization, possibly also at-rest encryption, not being swapped to disk, stored in a secure element, etc) while envU is an encrypted blob that does not need these kind of protections. in case pkU == idU it might be possbile that envU is stored in a hashdictionary that is indexed by idU, and thus pkU does not need to be stored at all. lumping these values together and requiring them to be stored in this structure creates unnecessary limitations on implementations. while this specification might harm security, it does not really improve interoperability.\r\n> \r\n> either delete this section, or make this optional, and put it into an non-binding appendix.\r\n> \r\n> another thing against this, is the usage of export-keys, in case an implementation chooses to encrypt data with an export-key but wants to stay stateless on the client, then the export-key encrypted data might also be stored on the server.\r\n\r\nAdded text to emphasize that this is not a requirement of the spec: \"The below structure represents an example of how\r\nthese values might be conveniently stored together.\"",
      "createdAt": "2021-02-10T10:01:08Z",
      "updatedAt": "2021-02-13T17:56:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4c8321fdf18977af420c72c6d96c132b1970e3b4",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "stefs_comments",
      "headRefOid": "d186d249c017ea81c4f26a03dae156698fe4a34f",
      "closedAt": "2021-02-13T17:56:42Z",
      "mergedAt": "2021-02-13T17:56:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "572f395c8c536694ed8efe35fa80db2b213cdefd"
      },
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "good job. thanks!",
          "createdAt": "2021-02-11T14:16:25Z",
          "updatedAt": "2021-02-11T14:16:25Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "btw posix has a definition here https://pubs.opengroup.org/onlinepubs/9699919799/functions/htonl.html also known as: \r\n\r\n> The Open Group Base Specifications Issue 7, 2018 edition IEEE Std 1003.1-2017",
          "createdAt": "2021-02-11T14:23:28Z",
          "updatedAt": "2021-02-11T14:23:28Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 141,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcxMDA2MTk5",
      "title": "Adding Nk parameter to fix public/private key sizes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/141",
      "state": "OPEN",
      "author": "kevinlewi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Gets rid of the variable-length encoding of the client/server public/private keys, and restricts them to be of a fixed length (denoted by the parameter `Nk`). Note that `Nk` is a parameter that must be specified for each AKE instantiation -- this gives the flexibility of future AKE instantiations that are PQ to use a larger `Nk` if necessary.\r\n\r\nQuestion: should we have an Nsk and Npk, since the size of the private and public keys may not necessarily be the same?\r\n\r\n\r\nCloses #121 and #132 ",
      "createdAt": "2021-02-10T10:48:57Z",
      "updatedAt": "2021-02-10T10:48:57Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4c8321fdf18977af420c72c6d96c132b1970e3b4",
      "headRepository": "kevinlewi/draft-irtf-cfrg-opaque",
      "headRefName": "adding_nk",
      "headRefOid": "c7c1233bcba07fa5679489645f6caec34b236605",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 144,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcyOTMyMDYy",
      "title": "Address #142 and minor suggestions to the draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/144",
      "state": "CLOSED",
      "author": "bytemare",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In _opaque_ake.sage_ drop pre-hashing and carry only the transcript in the state + minor renaming to avoid confusion.\r\n\r\nSome typo fixing in the draft and suggestions.",
      "createdAt": "2021-02-13T12:39:27Z",
      "updatedAt": "2021-02-13T18:51:23Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "4c8321fdf18977af420c72c6d96c132b1970e3b4",
      "headRepository": "bytemare/draft-irtf-cfrg-opaque",
      "headRefName": "master",
      "headRefOid": "4c8321fdf18977af420c72c6d96c132b1970e3b4",
      "closedAt": "2021-02-13T17:54:07Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "can you please produce a diff that is not a complete replacement of the changed files. reviewing the changes like this is a bit uneconomic.",
          "createdAt": "2021-02-13T12:57:47Z",
          "updatedAt": "2021-02-13T12:57:47Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Oh, I see. I don't know how this happened. Do you know how I can avoid that?",
          "createdAt": "2021-02-13T17:19:22Z",
          "updatedAt": "2021-02-13T17:19:22Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Thanks, @stef! I submitted the same change in #145, with a correct diff :)",
          "createdAt": "2021-02-13T18:51:22Z",
          "updatedAt": "2021-02-13T18:51:22Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 145,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcyOTc3NzAw",
      "title": "Address #142 and minor suggestions to the draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-opaque/pull/145",
      "state": "OPEN",
      "author": "bytemare",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In opaque_ake.sage drop pre-hashing and carry only the transcript in the state + minor renaming to avoid confusion.\r\n\r\nSome typo fixing in the draft and suggestions for wording.\r\n\r\ncc @chris-wood",
      "createdAt": "2021-02-13T18:50:06Z",
      "updatedAt": "2021-02-14T00:43:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-opaque",
      "baseRefName": "master",
      "baseRefOid": "572f395c8c536694ed8efe35fa80db2b213cdefd",
      "headRepository": "bytemare/draft-irtf-cfrg-opaque",
      "headRefName": "master",
      "headRefOid": "681df8652f2e109a008884d54e252190bdb2b430",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "why not hash the transcript?",
          "createdAt": "2021-02-13T18:59:26Z",
          "updatedAt": "2021-02-13T18:59:26Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "It's not specified in the draft. ",
          "createdAt": "2021-02-13T19:00:42Z",
          "updatedAt": "2021-02-13T19:00:42Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "the poc, the rust and my implementation did it like that. i think it comes from the paper. and it makes sense. i'd like to stick with it and rather specify it in the spec, than to drop it.",
          "createdAt": "2021-02-13T20:47:30Z",
          "updatedAt": "2021-02-13T20:47:30Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Why do you pre-hash it before hmac ?",
          "createdAt": "2021-02-13T22:09:51Z",
          "updatedAt": "2021-02-13T22:09:51Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "My PR comes from a conversation with @kevinlewi and @chris-wood, and we couldn't explain where this came from.\r\n\r\nI think I found it. The V1 says\r\n\r\n> * The explicit concatenation of elements under transcript2 and transcript3 can be replaced with hashed values of these elements, or their combinations, using a collision-resistant hash (e.g., as in the transcript-hash of TLS 1.3 [RFC8446]). \r\n\r\n\r\nbut this section is now absent. \r\n\r\nRFC8446 justifies this with the following\r\n\r\n> The reason for this construction is to allow the server to do a\r\n>    stateless HelloRetryRequest by storing just the hash of ClientHello1\r\n>    in the cookie, rather than requiring it to export the entire\r\n>    intermediate hash state (see Section 4.2.2).\r\n\r\nIs this useful in OPAQUE?",
          "createdAt": "2021-02-13T22:20:36Z",
          "updatedAt": "2021-02-13T23:14:19Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "interesting. i looked in the original paper and it is not there. there is one benefit for prehashing, the fact that the server does not have to preserve all the inputs for the hmac between the create-credential-response and the explicit authentication where the server verifies the km3 mac of the user.",
          "createdAt": "2021-02-13T22:38:50Z",
          "updatedAt": "2021-02-13T22:38:50Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "As Transcript3 is defined, it is transcript2 + server mac, and can be assembled at the KE2 stage.\nKeeping a hash of Transcript3 reduces the size of the server's state, indeed.",
          "createdAt": "2021-02-13T22:45:10Z",
          "updatedAt": "2021-02-13T22:45:43Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "From a security perspective, though, pre-hashing is a weaker construction, as it relies on the collision resistance of the pre-hashing function. Not hashing protects against a theoretical attack, I don't know if this has been considered in our case.",
          "createdAt": "2021-02-14T00:14:44Z",
          "updatedAt": "2021-02-14T00:14:56Z"
        },
        {
          "author": "bytemare",
          "authorAssociation": "NONE",
          "body": "Actually, the server can compute the client_mac at KE2 as well. It doesn't actually need to preserve anything except the client_mac.\r\n\r\nSo the server does all its signing in KE2, the client all its signing in KE3, none need to carry any trace of transcript2 and transcripts. Hence, no pre-hashing needed.",
          "createdAt": "2021-02-14T00:40:33Z",
          "updatedAt": "2021-02-14T00:40:33Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "indeed with the elimination of info3/einfo3 this makes sense.",
          "createdAt": "2021-02-14T00:43:18Z",
          "updatedAt": "2021-02-14T00:43:18Z"
        }
      ],
      "reviews": []
    }
  ]
}